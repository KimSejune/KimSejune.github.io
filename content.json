{"meta":{"title":"KimSejune Start Study","subtitle":"Node.js, js, html, css","description":null,"author":"Sejune kim","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Node-Express","slug":"node-study-express","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-14T13:23:21.000Z","comments":true,"path":"2017/08/29/node-study-express/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-express/","excerpt":"","text":"Node Express 실습환경Glitch Tutorial 나의 Glitch Express Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크 내장하고 있는 기능은 매우 적으나, 미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음 공식 매뉴얼 한국어 번역 Express 앱의 기본 구조12345678910111213141516// Express Instance 생성const app = express()// 미들웨어 주입app.use(sessionMiddleware())app.use(authenticationMiddleware())// router handler registerapp.get('/', (request, response) =&gt; &#123; response.send('Hello express!')&#125;)// Server Startapp.listen(3000, ()=&gt;&#123; console.log('Example app listening on port 3000!')&#125;) Routing1234567891011121314151617181920212223const app = express()// HTTP Request Method (GET, POST, DELETE, PUT, ...)app.get('/articles', (req, res) =&gt; &#123; res.send('Hello Routing!')&#125;)// 특정 경로에만 미들웨어를 주입하는 것도 가능app.post('/articles', bodyParserMiddleware(), (req, res) =&gt; &#123; database.articles.create(req.body) // 요청한 body를 넣어둔다. .then(() =&gt; &#123; res.send(&#123;ok: true&#125;) &#125;)&#125;)// 경로의 특정 부분을 함수의 인자처럼 입력받을 수 있음app.get('/articles/:id', (req, res)=&gt; &#123; database.articles.find(req.params.id) // 'req.params.id'에 요청한 사람의 id가 저장된다. .then(article =&gt; &#123; res.send(article) &#125;)&#125;) Request 객체req.body requset.body를 적절한 형태의 자바스크립트 객체로 변환하여 이곳에 저장 (body-parser 미들웨어에 의해 처리됨) req.ip 요청한 쪽의 IP req.params route parameter req.query query string이 객체로 저장됨 Response 객체res.status(...) 응답의 상태 코드를 지정하는 메소드 res.append(...) 응답의 헤더를 지정하는 메소드 res.send(...) 응답의 바디를 지정하는 메소드 인자가 텍스트면 text/html, 객체면 application/json타입으로 응답 숫자를 send에 넣으면 error가 발생한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Express","slug":"Node-js/Express","permalink":"http://yoursite.com/categories/Node-js/Express/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://yoursite.com/tags/Express/"}]},{"title":"Node-Http","slug":"node-study-http","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-14T13:25:48.000Z","comments":true,"path":"2017/08/29/node-study-http/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-http/","excerpt":"","text":"HTTP History APIHTTP History API history.back() window.history.back(); history.forward() window.history.forward(); history.go() 히스토리에서 특정 위치로 가기 history.pushState() 히스토리 엔트리의 추가 및 변경 이 메서드들은 window.onpopstate 이벤트와 연동하여 동작합니다. HTTP 까보기 WireShark https를 사용하는 사이트는 wireshark로 찾아볼 수 없다. Chrome Devtools 검사탭 -&gt; Network HTTP 웹 브라우저와 웹 서버 간의 통신을 위해 개발된 통신규약 최근에는 REST API의 부상와 함꼐 다른 용도로도 널리 사용됨 모바일 앱 - 서버 간 통신 서버 - 서버 간 통신 80번 포트를 기본으로 사용 클라이언트의 요청(requert)과 서버의 응답(response)으로 이루어짐 HTTPS HTTP over SSL HTTP 통신을 암호화해 주고받는 내용을 중간에서 가로챌 수 없도록 함 443번 포트를 기본으로 사용 HTTP/2 구글의 SPDY 프로토콜을 기반으로 2015년에 확정된 새로운 HTTP 표준 속도 개선에 중점을 두고 개발됨 반드시 HTTPS를 사용해야 함 현재 전체 웹사이트 중 16% 이상이 사용중 HTTP 구성요소Request &amp; Response 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보냄 그에 따라 서버는 클라이언트에 응답(response)를 보냄 웹 브라우저의 경우, HTML 문서 형태의 응답이 오면 해당 문서를 분석한 후, 문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보냄 (이미지, 동영상, 오디오, CSS, JS, 폰트, …) Request Methods HTTP 명세에는 8 종류가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있음 GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH HTTP request methods 웹 브라우저는 특정 상황에서 특정 메소드로 요청을 보내도록 강제되어져 있음 Ajax와 같이 요청을 보내는 코드를 직접 짤 때는 요청 메소드를 선택할 수 있음 자료의 본문을 요청하는 GET메소드와, 새로운 자료를 등록하는 POST 메소드가 가장 많이 쓰임 (서버가 충족시켜야 하는) 메소드의 성질Safe 요청이 서버의 상태에 영향을 미치지 않아야 함. 즉, 읽기 전용 Idempotent 여러 번 같은 요청을 해도 한 번 요청한 것과 같은 효과여야 함. 네트워크가 불안정해도 안전하게 요청을 보낼 수 있음 Cacheable (특정 조건을 만족하면) 응답을 클라이언트에 저장해두었다가 다음 번 요청 때 다시 쓸 수 있음 fetch는 일부분만 바꿀때 사용하며, put은 전체를 바꿀때 사용한다, link 반드시 이 성질을 따르도록 서버를 구현해야 하는 것은 아니나, 구현했을 때의 이점이 있으므로 이대로 구현하는 것이 좋다 URL 2,3,4는 domain영역이다. 4(TOP)는 특별한 기관에서 관리를한다. Percent Encoding URL은 ASCII 문자(128개의 영문자+특수문자+제어문자)밖에 사용하지 못하기 때문에, non-ASCII 문자를 위한 표현방법이 필요함 # Percent encoding은 non-ASCII 문자를 위한 웹 표준 인코딩 방법으로, JavaScript에 관련 기능이 포함되어 있음 1234&gt; encodeURIComponent(\"한글\")\"%ED%95%9C%EA%B8%80\"&gt; decodeURIComponent(\"%ED%95%9C%EA%B8%80\")\"한글\" 1234const encoded = encodeURIComponent('패스트캠퍼스')undefineddecodeURIComponent(encoded)\"패스트캠퍼스\" Request Target일반적인 경우 아래와 같은 구조가 사용됨 absolute path + query string + fragment id 1GET /path/to/resource?foo=bar&amp;spam=hoge#fragid HTTP/1.1 Response Status 응답의 성공, 실패 여부와 종류를 나타내며, 상태 코드 + 상태 메시지의 형태로 응답에 포함됨 1HTTP/1.1 200 OK HTTP Status Codes Status Category2xx 성공 3xx 추가 작업이 필요함 4xx 실패 - 클라이언트 책임 5xx 실패 - 서버 책임 Status Code - 2xx200 ok 성공 201 Created 자료가 성공적으로 생성됨 Status Code - 3xx301 Moved Permanently (Redirection) 자료가 완전히 다른 곳으로 이동했음 302 Found (Redirection) 자료가 일시적으로 다른 곳에 있음 304 Not Modified (Cache) 클라이언트가 이미 가지고 있던 자료가 수정되지 않았음 (그대로 사용하면 됨) Status Code - 4xx400 Bad Request 요청의 형태가 잘못되어 응답할 수 없음 403 Forbidden 요청한 자료에 접근할 권한이 없음 404 Not Found 요청한 자료가 없음 Status Code - 5xx500 Internal Server Error 요청을 처리하던 중에 예상치 못한 오류가 발생함 503 Service Unavailable 서버가 일시적으로 응답을 할 수 없음 Header 요청과 응답에 대한 추가 정보를 표현하는 데 사용됨 인증, 캐싱, 쿠키, 보안, 내용협상, 프록시 등 웹 표준에 정의된 많은 기능을 제어하는 데 사용됨 Authorization 요청의 인증 정보 User-Agent 요청 중인 클라이언트의 정보 Location 301, 302 응답에서 자료의 위치 Accept 요청이 어떤 형태의 자료를 원하는지 나타냄 Content-Type 요청 혹은 응답이 어떤 형태의 자료인지 나타냄 Content Negotiation 요청의 Accept, Accept-Language 등의 헤더를 보고 서버가 그에 맞는 형태의 자료를 응답하는 절차를 content negotiation(내용협상)이라고 함","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Http","slug":"Node-js/Http","permalink":"http://yoursite.com/categories/Node-js/Http/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Http","slug":"Http","permalink":"http://yoursite.com/tags/Http/"}]},{"title":"Node-Template-Language","slug":"node-study-template-language","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-14T13:23:57.000Z","comments":true,"path":"2017/08/29/node-study-template-language/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-template-language/","excerpt":"","text":"Node Template LanguageStatic Web Page누가 어떻게 요청하든 미리 저장되어 있던 HTML 파일을 그대로 응답 Dynamic Web Page요청한 사람과 요청한 내용에 따라 각각 다른 내용으로 편집한 HTML을 응답 Template Engine템플릿과 데이터를 결합해 문서를 생성하는 프로그램, 혹은 라이브러리템플릿을 작성할 때 사용하는 언어를 템플릿 언어라고 함 EJSEmbedded JavaScript Template # Node.js 생태계에서 가장 많이 사용되는 템플릿 엔진 문법이 단순 JavaScript 코드를 템플릿 안에서 그대로 쓸 수 있음 .ejs VSCode Extension 1234567891011121314&lt;%# index.ejs %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"message\"&gt; &lt;%= message %&gt; &lt;/div&gt; &lt;% if (showSecret) &#123; %&gt; &lt;div&gt;my secret&lt;/div&gt; // showSecret이 true면 my secret을 보여주고 false면 보여주지 말아라. &lt;% &#125; %&gt; &lt;/body&gt;&lt;/html&gt; &lt;%= title %&gt; 을 사용하여서 데이터의 title을 가진 값을 집어 넣는다. Express에서 EJS 사용하기ejs 설치1$ npm install --save ejs template engine 설정1app.set('view engine', 'ejs') res.render()123456const data = &#123; title: 'Template Language', message: 'Hello EJS!', showSecret: true&#125;res.render('index.ejs', data) Serving Static Files 템플릿 파일에서 참조할 수 있다. 변하지 않는 파일들을 넣어서 보관해둔다.1234567// `public` 폴더에 있는 파일을 `/static` 경로 아래에서 제공app.set('view engine', 'ejs')app.use('/static', express.static('public'))&lt;!-- 템플릿 파일에서 참조할 수 있음 --&gt;&lt;link rel=\"stylesheet\" href=\"/static/index.css\"&gt;&lt;script type=\"text/javascript\" src=\"/static/index.js\"&gt;&lt;/script&gt;","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"template Language","slug":"Node-js/template-Language","permalink":"http://yoursite.com/categories/Node-js/template-Language/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"template Language","slug":"template-Language","permalink":"http://yoursite.com/tags/template-Language/"}]},{"title":"Node-Rest-API","slug":"node-study-restapi","date":"2017-08-28T03:54:00.000Z","updated":"2017-09-14T13:23:54.000Z","comments":true,"path":"2017/08/28/node-study-restapi/","link":"","permalink":"http://yoursite.com/2017/08/28/node-study-restapi/","excerpt":"","text":"Node Rest API 실습PostMan REST API를 시험해볼 수 있는 도구 다양한 편의기능 제공 Github Rest API https://api.github.com/users/KimSejune 나의 정보를 받아올수있다.Rest API link HTTP의 전송 GET/user/repo Authorization은 Basic, Digest, Bearer 3가지로 이루어져있다. Node.js NVM을 통하여 새로운 노드를 추가적으로 설치한다. nvm 설치방법curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash 터미널을 종료한 후에 123 export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 12345# 주석: `#`으로 시작하는 명령은 bash에서 무시됩니다.# 아래 명령을 한 줄씩 차례대로 입력하세요$ nvm install 8.4$ nvm use 8.4$ nvm alias default 8.4 # nvm-windows는 필요없음 다시 돌아가는 방법 nvm ls를 하고 nvm use system을 하면 원래사용하던 node로 돌아온다. nvm use default를 통해서 nvm으로 돌아온다. 1234567891011// 여러 줄에 나눠서 입력하기&gt; function factorial2(n) &#123;... return n &lt; 1 ? 1 : n * factorial(n-1)... &#125;undefined&gt; factorial2(4)24// `.exit`를 입력하거나 `Ctrl+C`를 두 번 입력해서 나가기&gt; .exit node.js module을 사용한다. 123456789// Node.js module 사용하기&gt; const os = require('os') // 급할땐 `os = ...`undefined&gt; os.platform()'darwin'&gt; os.freemem()658300928 운영체제에 상관없이 경로를 사용할 수 있게 해준다.node.js path api Node.js로 파일 실행시키기1$ node (파일 경로) Node js의 이론 node.js 는 js의 runtime이며 chrome의 Javascript V8 engine을 사용한다. event-drive, non-blocking I/O model을 사용한다. JavaSCript runtime js는 언어 js runtime은 js를 구동하기 위해 필요한 실행 환경 프로그래머는 런타임이 제공하는 도구를 응용해서 프로그램을 개발 웹 브라우저(chrome, edge)나 Node.js도 JavaScript 런타임의 일종 Chrome이 제공하는 웹 브라우저용 런타임 Node.js가 제공하는 서버용 런타임 MongoDB가 제공하는 데이터 처리용 런타임 Photoshop이 제공하는 전용 런타임 V8 JavaScript Engine JIT(Just-In-Time) compilation Code Optimization Used in Google Chrome Node.js MongoDB … js가 V8 js engine을 통하여 속도가 대폭 향상되었다. Event-driven Programming 프로그램의 흐름이 외부 요인에 의해 일어나는 사건에 의해 결정되는 프로그래밍 양식 약속된 방식으로 이벤트 핸들러를 작성함으로써 외부 이벤트가 일어났을 때 코드를 실행 마우스 입력 키보드 입력 다른 프로그램/컴퓨터로부터의 통신 123456789101112// DOM 이벤트 핸들러 등록 (웹 브라우저)domElement.addEventListener('click', function(e) &#123; e.stopPropagation() alert('hello')&#125;)// 서버도 똑같이 합니다.// (단, 프레임워크를 쓸 때는 직접 이벤트를 다룰 일이 별로 없음)// HTTP 응답 이벤트 핸들러 등록 (Node.js)httpResponse.on('data', data =&gt; &#123; console.log(data)&#125;) node.js를 할 때 직접적으로 이벤트를 다룰 일은 별로 없다. Non-blocking I/O Blocking I/O는 스레드가 입력/출력이 완료될 때까지 기다렸다가 다음 코드를 실행 Non-blocking I/O는 스레드가 입력/출력을 기다리지 않고 코드를 계속 실행 I/O 성능 향상 &amp; 복잡한 코드 Node.js Module123456789101112131415// name.js// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음module.exports = &#123; familyName: '김', givenName: '승하', fullName: function() &#123; return this.familyName + this.givenName &#125;&#125;// calc.js// `exports`로도 참조 가능exports.add = (x, y) =&gt; x + yexports.sub = (x, y) =&gt; x - y name.js에서 저장한 module.exports의 값들을 다른 파일에서 사용할 수 있게한다. module.exports 안에는 빈객체가 들어있어서 exports. ~~ 를해도 코드가 작동한다. module를 생략해도된다. 단) 객체를 통째로 생성할때는 module을 붙여준다. 123456789101112131415&gt; const name = require('./name.js')undefined&gt; name&#123; familyName: '김', givenName: '세준', fullName: [Function: fullName] &#125;&gt; name.familyName'김'&gt; name.givenName'세준'&gt; name.fullName[Function: fullName]&gt; name.fullName()'김세준'&gt; 객체를 내가원하는 함수에다가 바로 넘길수도 있다 ReceiveObjsct(require(&#39;./name.js&#39;)) node.js는 module마다 각각의 scope가 존재한다. 그래서 전역에다가 저장이 안되고 module scope에다가 저장을 한다. 다른 module에서 사용하려면 무조건 export안에 들어있어야한다. REPL에서 불러오기 Node.js 패키지 관리 도구 + 클라우드 패키지 저장소 의존 패키지 관리 스크립트 실행 패키지 설정 NPM에 패키지 배포 Node.js 종합 작업 도구 Hello NPM1234567891011121314151617$ mkdir hello-npm$ cd hello-npm$ npm init -y$ code .// package.json&#123; \"name\": \"hello-npm\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\"&#125; package.json 패키지 정보를 담고 있는 파일 dependencies npm install --save 명령으로 설치한 패키지가 기록됨 scripts 원래 목적은 패키지 생명주기마다 자동으로 실행되는 명령을 등록하기 위함이나, 개발자 편의를 위해 자주 사용되는 명령을 등록하는 용도로 더 많이 사용됨 1234567891011$ npm install --save randomstring # node_modules에 저장됨// index.jsconst randomstring = require('randomstring')console.log(randomstring.generate())// package.json... \"scripts\": &#123; \"start\": \"node index.js\" &#125;...$ npm start // start라는 이름으로 script에 등록을 하여서 실행시킬수있다. Concurrency(동시성)Concurrency Model(동시성 모델) 프로그램이 생애 주기가 겹치는 여러 실행 과정을 통해 실행된다 하더라도 프로그램의 결과에는 영향을 미치지 않는 성질 생애 주기가 겹치는 여러 실행 과정이 자원을 공유할 때 어떻게 충돌이 생기지 않도록 할 것인가? Resources CPU Memory Network thread 코드 실행의 가장 작은 단위 프로그램은 하나 이상의 스레드로 이루어짐 CPU 코어 하나는 한 번에 하나의 스레드를 실행 thread 확인방법 1$ sysctl -n hw.ncpu // 시스템의 코어개수 운영체제 차원의 도구 Process Thread Mutex (Mutual Exclusion) 언어 차원의 도구 Python - asyncio Go - goroutine Erlang - actor JavaScript - …? 자바스크립트의 동시성(Single-Threaded Event Loop) 자바스크립트를 실행시키는 스레드가 하나 뿐임 실행 과정(보통 콜백 연쇄)의 생애 주기가 겹칠 수는 있지만 어떤 경우에도 두 자바스크립트 실행과정이 동시에 실행되는 경우는 없음 내부적으로 메시지 큐를 활용하고 있으나, 모든 처리가 자동으로 이루어짐MDN 장점 프로그래머가 동시성에 대해 신경쓸 필요가 없어짐 프로그램 작성이 쉬워짐 단점 CPU를 많이 쓰는 작업에 부적절 오래 걸리는 자바스크립트 코드가 실행되면 전체 프로그램에 영향을 미침 전략 오래 걸리는 일은 외부에 위임하고 넘어간 뒤, 나중에 결과를 받아 처리하기 Database Node.js-External libraries Web browser - webAssembly 긴 실행과정을 여러개의 함수로 쪼개서한 번의 함수 실행이 금방 끝나게 만들기 Ascynchronous JavaScript non-blocking하고 비슷한 개념이다. 코드의 작성법에 대한 개념이다. Ascynchronous Callback 함수를 호출할 떄, 콜백까지 같이 인자에 넣어서 호출하는 비동기 프로그래밍 양식 콜백에서 에러 인자를 받는 방식으로 에러 처리를 함 Node.js 내장 모듈 전체가 이 방식을 사용하도록 만들어져 있음 모든 콜백이 비동기인 것은 아님 12&gt; [1,2,3].map(x =&gt; x*x)[ 1, 4, 9 ] 계산을 기다렸다가 바로 출력한다. readFile fs라는 file에 내장되어있다. 첫번째 인자를 err로 받는다. 123456789101112// readFile.js 비동기식 코드const fs = require('fs') // Node.js 내장 모듈fs.readFile('./calc.js', 'utf8', (err, data) =&gt; &#123; console.log(data)&#125;)console.log('done!')// readFileSync.js 동기식 코드const fs = require('fs') // Node.js 내장 모듈const data = fs.readFileSync('./calc.js', 'utf8')console.log(data)console.log('done!') try, catch는 동기식에서만 에러처리를 할 수 있다. request 설치12$ # hello-npm 폴더 안에서 실행$ npm install --save request Github REST API 호출123456789101112131415161718192021222324252627282930313233// 유저 이름, 저장소, 할당된 이슈 갯수 출력하기const request = require('request')const apiUrl = 'https://api.github.com'const option = &#123; json: true, auth: &#123; 'user': 'username', 'pass': 'password', &#125;, headers: &#123; 'User-Agent': 'request' &#125;&#125;request.get(`$&#123;apiUrl&#125;/user`, option, function (error, response, body) &#123; const name = body.name if (error) console.error(error) // 콜백 안에 콜백 request.get(`$&#123;apiUrl&#125;/user/repos`, option, function (error, response, body) &#123; if (error) console.error(error) const repoNames = body.map(item =&gt; item.name) // 콜백 안에 콜백 안에 콜백 request.get(`$&#123;apiUrl&#125;/issues`, option, function (error, response, body) &#123; if (error) console.error(error) const issueNum = body.length console.log(`name: $&#123;name&#125;`) console.log('repos:') repoNames.forEach(name =&gt; &#123; console.log(name) &#125;) console.log(`num of assigned issues: $&#123;issueNum&#125;`) &#125;) &#125;)&#125;) request function이 만든사람이 error, response, body 를 parameter로 받는다. Callback Hell Callback의 Hell을 방지하기 위해서 Promise를 사용한다. Promise 비동기 작업의 결과를 담는 객체 정확히 언제가 될지 모르지만, 결국 성공 또는 실패의 상태를 갖게 됨 12345678910111213141516171819// tenSec.jsmodule.exports = function tenSec(value) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(value) &#125;, 10000) &#125;)&#125;// REPL&gt; const tenSec = require('./tenSec')&gt; const p = tenSec(1)&gt; p // 만든지 10초가 지나기 전Promise &#123; [pending], ...&gt; p // 만든지 10초가 지난 후Promise &#123; 1, ... export안에 함수를 넣어서 값이 함수로 나온다. 12345678&gt; tenSec('hello promise').then(value =&gt; &#123;... console.log(value)... &#125;)Promise &#123; // `then`은 Promise를 반환 [pending], ...&gt; // 10초 후'hello promise' then안에서 promise를 return하면 promise를 벗기고 안의 값만 들어간다. 1234567891011121314151617181920212223// chaining.jsconst tenSec = require('./tenSec')tenSec('hello promise') .then(value =&gt; &#123; console.log(value) return 1 // 위 `.then`은 값이 1인 Promise를 반환함 &#125;) .then(value =&gt; &#123; console.log(value) return tenSec('new promise') // Promise도 반환할 수 있음 &#125;) .then(value =&gt; &#123; console.log(value) &#125;) .then(() =&gt; &#123; throw new Error('error in promise') &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) .then(() =&gt; &#123; // 에러 처리 이후에도 코드 실행 가능 console.log('done') &#125;) catch 앞의 then 부분에서 에러가 발생하면 catch안의 값이 실행된다. 맨 위의 then에서 에러가나면 바로 catch로 넘어간다. promise.all([…]) 배열안의 넘기는 값들이 모두 성공해야지 성공한다. promise.rase([…]) 배열안의 값중에서 먼저 성공한것을 나타낸다. readFile - promise node.js v8부터 새로들어온 함수이다. 1234567891011// readfilePromise.jsconst &#123;promisify&#125; = require('util') // Node.js 8.0.0부터 추가됨const fs = require('fs')const readFile = promisify(fs.readFile)readFile('./calc.js', 'utf8') .then(data =&gt; &#123; console.log(data) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 파일을 다읽으면 반환하는 promise파일을 반환한다. Promise의 특징 이미 resolve 된 Promise에도 콜백을 실행할 수 있음 12&gt; const resolved = Promise.resolve(1)&gt; resolved.then(v =&gt; console.log(v)) .then에 넘겨진 콜백은 무조건 다음 루프에 실행됨 12345678&gt; (function() &#123;... Promise.resolve(1).then(v =&gt; console.log(v))... console.log(&apos;done!&apos;)... &#125;)()/* 출력:done!1*/ Promise.all1234567891011121314151617181920212223242526272829// npm install --save request-promiseconst rp = require('request-promise')const apiUrl = 'https://api.github.com'const option = &#123; json: true, auth: &#123; 'user': 'username', 'pass': 'password', &#125;, headers: &#123; 'User-Agent': 'request' &#125;&#125;const userPromise = rp.get(`$&#123;apiUrl&#125;/user`, option)const reposPromise = rp.get(`$&#123;apiUrl&#125;/user/repos`, option)const issuesPromise = rp.get(`$&#123;apiUrl&#125;/issues`, option)// 배열 내의 모든 Promise 객체가 완료되었을 때// resolve 되는 Promise를 만든다.Promise.all([userPromise, reposPromise, issuesPromise]) .then(([user, repos, issues]) =&gt; &#123; console.log(`name: $&#123;user.name&#125;`) console.log('repos:') repos.forEach(repo =&gt; &#123; console.log(repo.name) &#125;) console.log(`num of assigned issues: $&#123;issues.length&#125;`) &#125;) axiosfetch api fetch api, axios를 통하여 Ajax통신을 promise를 통하여 통신을 할 수 있게한다. Async/Await javascript의 문법을 바꾸어버렸다. 비동기 코드를 동기식 코드처럼 편하게 짤 수 있게 만든 것이다. async function은 무조건 promise를 반환하며 await가 완료될때 까지 기다린다.12345678910const tenSec = require('./tenSec')async function resolveAfterTenSec() &#123; await tenSec() return 1&#125;resolveAfterTenSec().then(value =&gt; &#123; console.log(value)&#125;) ES2017에서 도입되어, 비동기식 코드를 동기식 코드처럼 쓸 수 있는 문법 제공 Chrome 55, Node.js 8.0.0 부터 사용가능 async function 안에서 반환된 값은 최종적으로 Promise 객체로 변환되어 반환된다. async function 안에서 쓸 수 있는 await 키워드는 현재 함수를 중단시키고 Promise 객체가 충족될 때까지 기다리지만, 스레드를 block 하지 않는다. 에러 처리는 동기식 코드처럼 try, catch 블록을 통해서 한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Rest-API","slug":"Node-js/Rest-API","permalink":"http://yoursite.com/categories/Node-js/Rest-API/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"RestAPI","slug":"RestAPI","permalink":"http://yoursite.com/tags/RestAPI/"}]}]}