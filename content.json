{"meta":{"title":"KimSejune Start Study","subtitle":"Node.js JavaScript","description":null,"author":"Sejune kim","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Node-Express-Middleware","slug":"node-study-node-Express-Middleware","date":"2017-09-04T03:54:00.000Z","updated":"2017-09-16T11:11:26.000Z","comments":true,"path":"2017/09/04/node-study-node-Express-Middleware/","link":"","permalink":"http://yoursite.com/2017/09/04/node-study-node-Express-Middleware/","excerpt":"","text":"Node Express MiddlewareMiddleware?1234567// 미들웨어 = 함수function helloMiddleware(res, req, next) &#123; console.log('hello') next()&#125;app.use(helloMiddleware) 요청이 발생할 때 마다 console.log(‘hello’)가 나타난다. Middleware 함수, 즉 안에서 어떤 작업이든 가능 request 객체, response 객체, next 함수를 인자로 받음 request 객체, response 객체를 조작해서 기능 구현 다음 미들웨어를 동작시키기 위해 next 함수를 인자 없이 호출 미들웨어는 등록된 순서가 중요하다 먼저 등록된 것이 먼저 시작되기 때문이다. 등록된 순서대로 실행됨 app.use미들웨어를 앱 전체에서 동작하도록 주입1app.use(helloMiddleware) 특정 경로에서만 동작하도록 주입1app.use('/some-path', helloMiddleware)\\ 한번에 여러 개 주입 1app.use(middleware1, middleware2, middleware3, ...) 미들웨어로 하는 일 로깅 HTTP body를 객체로 변환 사용자 인증 권한 관리 Why middleware?미들웨어로 할 수 있는 모든 일은 라우트 핸들러에서도 할 수 있으나, 여러 라우터에서 사용해야 하는 기능을 중복 작성하는 불편을 덜고 코드를 재사용하기 위해 미들웨어를 사용하는 것 미들웨어 생태계Express resourceNPM search 미들웨어 예제Link Express 미들웨어 예제 middlewares.js 파일에서 작성한 미들웨어를 server.js에서 불러와 사용하고 있습니다. 각각 어떤 방식으로 미들웨어를 사용하고 있는지 확인해보세요. next? 미들웨어는 req, res에 더해서 next라는 함수를 추가로 인자로 받습니다. next 함수를 호출하면 다음 미들웨어로 처리를 넘기는 효과가 있습니다. 만약에 미들웨어가 next 함수를 호출하지도 않고, 응답도 보내지 않으면 클라이언트는 응답을 받지 못하게 되므로 주의하세요! App Local, Response Local app.locals와 res.locals는 특별한 객체를 담고 있습니다. 템플릿에서는 res.render를 통해 명시적으로 주입받지 않아도 저 두 객체의 속성에 바로 접근할 수 있습니다. 템플릿을 가리지 않고 사용되는 정보들, 예를 들어 ‘현재 로그인 중인 사용자 정보’ 같은 것을 res.render에 매번 인자로 넘기는 것은 귀찮을 뿐더러 빠뜨리기도 쉽습니다. 그런 정보들을 템플릿에서 쉽게 사용하기 위해, app.locals나 res.locals에 우리가 원하는 이름으로 속성을 주입할 수 있습니다. app.locals는 앱 단위로 공통적으로 쓰이는 정보를 담는 목적으로 사용됩니다. res.locals는 각 요청마다 달라지는 정보를 담는 목적으로 사용됩니다. app.local 객체를 조작하는 것은 매우 쉽습니다. res 객체는 매 요청마다 새로 생성되어 미들웨어 바깥에서 접근할 수 있는 방법이 없으므로, res.locals를 조작하려면 미들웨어를 사용해야 합니다. 미들웨어에서도 직접 res.send를 통해서 값을 보낼 수 도있다 next or res.send 둘중하나는 꼭 해줘야한다. app.locals는 변하지 않는 값을 쓸때 사용하고 res.locals는 변경가능한 값을 쓸때 사용한다. 12345678910111213141516171819202122function makeAdder(x) &#123; return function(y) &#123; return x + y &#125;&#125;undefinedadd1 = makeAdder(1)ƒ (y) &#123; return x + y &#125;add1(2)3// 값이 이렇게 사용해도되는데 이것을 currying이라고 한다.makeAdder(3)(4)7 // 위의 함수와 같은 역할을 한다.makeAdder2 = x =&gt; y =&gt; x+yx =&gt; y =&gt; x+ymakeAdder2(4)(4)8 closure를 사용하여서 함수를 2가지를 사용한다 currying이라고도 불린다. 12345678910111213141516171819202122232425262728293031323334353637383940//server.jsconst express = require('express')const &#123; ipLoggingMiddleware, urlLoggingMiddleware, resLocalMiddleware, lock&#125; = require('./middlewares')const app = express()app.set('view engine', 'ejs')// 앱 단위 미들웨어는 모든 라우트 핸들러에서 실행됩니다.// 미들웨어는 등록된 순서대로 실행됩니다.// 아래 미들웨어 적용 순서를 바꿔보세요.app.use(urlLoggingMiddleware)app.use(ipLoggingMiddleware)// 라우트 단위 미들웨어는 적용된 라우트에서만 실행됩니다.app.get('/', resLocalMiddleware, (req, res) =&gt; &#123; res.render('index.ejs')&#125;)app.get('/secret', lock('thisisthekey'), (req, res) =&gt; &#123; res.send('my secret is...')&#125;)// 요청이 라우트 핸들러가 등록된 어떤 경로와도 일치하지 않을 때,// 맨 마지막 미들웨어를 실행시킬 수 있습니다. 이를 이용해 우리만의 404 페이지를 보여줄 수 있습니다.// 아래에 작성해보세요. (참고: http://expressjs.com/ko/starter/faq.html)app.use((req, res, next) =&gt; &#123; res.render('404.ejs')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) 12345678910111213141516171819202122232425//middlewares.jsexports.ipLoggingMiddleware = (req, res, next) =&gt; &#123; console.log(`request ip: $&#123;req.ip&#125;`) next()&#125;exports.urlLoggingMiddleware = (req, res, next) =&gt; &#123; console.log(`request url: $&#123;req.originalUrl&#125;`) next()&#125;exports.resLocalMiddleware = (req, res, next) =&gt; &#123; res.locals.myVar = 'FASTCAMPUS!' next()&#125;exports.lock = key =&gt; (req, res, next) =&gt; &#123; if (req.query.key === key) &#123; next() &#125; else &#123; res.status(403) res.send('403 Forbidden') &#125;&#125; 404관련 페이지는 가장 밑에서 실행해야한다. 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;%= myVar %&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 미들웨어 vs 라우트 핸들러 라우트 핸들러도 미들웨어 즉, next함수를 인자로 받는 것이 가능 1234567app.get('/', (req, res, next) =&gt; &#123; if (!someCondition) &#123; next() // 요청을 처리를 하지 않고 다른 핸들러로 넘김 &#125; else &#123; res.send('hello') &#125;&#125;) 오류 핸들러를 설정하는 방법 오류 처리 미들웨어는 다른 미들웨어와 동일한 방식으로 정의할 수 있지만, 다음과 같이 오류 처리 함수는 3개가 아닌 4개의 인수, 구체적으로 말하면 (err, req, res, next) 시그니처를 갖는다는 점이 다릅니다. bugsnag sentry 1234app.use(function(err, req, res, next) &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;);","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Express-Middlware","slug":"Node-js/Express-Middlware","permalink":"http://yoursite.com/categories/Node-js/Express-Middlware/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://yoursite.com/tags/Express/"},{"name":"Middleware","slug":"Middleware","permalink":"http://yoursite.com/tags/Middleware/"}]},{"title":"Node-Cookie","slug":"node-study-node-cookie","date":"2017-09-04T03:54:00.000Z","updated":"2017-09-16T11:07:34.000Z","comments":true,"path":"2017/09/04/node-study-node-cookie/","link":"","permalink":"http://yoursite.com/2017/09/04/node-study-node-cookie/","excerpt":"","text":"Node Cookie쿠키의 필요성 개별 클라이언트의 여러 요청에 걸친 정보의 유지 장바구니 로그인/로그아웃 방문 기록 HTTP Cookie 서버가 응답을 통해 웹 브라우저에 저장하는 이름+값 형태의 정보 웹 브라우저는 쿠키를 저장하기 위한 저장소를 가지고 있음 저장소는 자료의 유효기간과 접근 권한에 대한 다양한 옵션을 제공 쿠키 전송 절차 서버는 브라우저에 저장하고 싶은 정보를 응답과 같이 실어 보낸다(Set-Cookie 헤더) 12HTTP/1.1 200 OKSet-Cookie: cookieName=cookieValue; Secure; Max-Age=60000 브라우저는 같은 서버에 요청이 일어날 때마다 해당 정보를 요청에 같이 실어서 서버에 보낸다 (Cookie 헤더) 12GET / HTTP/1.1Cookie: cookieName=cookieValue; anotherName=anotherValue Set-Cookie OptionsExpires, Max-Age 쿠키의 지속 시간 설정 Secure HTTPS를 통해서만 쿠키가 전송되도록 설정 HttpOnly 자바스크립트에서 쿠키를 읽지 못하도록 설정 Domain, Path 쿠키의 scope 설정 (쿠키가 전송되는 URL을 제한) Express + Cookie쿠키 읽기 - req.cookies 요청에 실려온 쿠키가 객체로 변환되어 req.cookies에 저장됨(cookie-parser middleware 필요) 쿠키 쓰기 - res.cookie(name, value) 쿠키의 생성 혹은 수정 쿠키 예제Link 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const express = require('express')const cookieParser = require('cookie-parser')const app = express()app.set('trust proxy', 1)app.use(cookieParser())app.get('/', (req, res) =&gt; &#123; res.send(req.cookies)&#125;)app.get('/somePath', (req, res) =&gt; &#123; res.send(req.cookies)&#125;)// 별다른 옵션 없이 쿠키를 저장하는 응답을 보냅니다.app.get('/set', (req, res) =&gt; &#123; res.cookie('cookieName', 'cookieValue') res.redirect('/')&#125;)// httpOnly 옵션은 해당 쿠키를 자바스크립트에서 접근할 수 없게 합니다. 즉 보안성이 향상app.get('/httpOnly', (req, res) =&gt; &#123; res.cookie('httpOnlyCookie', 'value', &#123; httpOnly: true &#125;) res.redirect('/')&#125;)// secure 옵션은 http 프로토콜을 통한 요청에는 쿠키가 포함되지 않게 합니다. (https로 했을 때만 포함시킴)app.get('/secure', (req, res) =&gt; &#123; res.cookie('secureCookie', 'value', &#123; secure: true &#125;) res.redirect('/')&#125;)// maxAge 옵션은 쿠키가 해당 시간이 지났을 때 삭제되도록 합니다.app.get('/maxAge', (req, res) =&gt; &#123; res.cookie('maxAgeCookie', 'value', &#123; maxAge: 5000 &#125;) res.redirect('/')&#125;)// domain 옵션은 해당 도메인 및 서브도메인으로 쿠키가 전송되도록 합니다.app.get('/domain', (req, res) =&gt; &#123; res.cookie('domainCookie', 'value', &#123; domain: 'glitch.me' &#125;) res.redirect('/')&#125;)// path 옵션은 쿠키가 지정된 경로 및 그 하위 경로에 요청이 일어났을 때만 전송되도록 합니다.// 루트에서는 안보이고 somePath에서는 보인다.app.get('/path', (req, res) =&gt; &#123; res.cookie('pathCookie', 'value', &#123; path: '/somePath' &#125;) res.redirect('/')&#125;)// 여러 옵션을 한꺼번에 지정할 수도 있습니다.app.get('/multiple-options', (req, res) =&gt; &#123; res.cookie('multipleOption', 'value', &#123; secure: true, httpOnly: true, maxAge: 5000 &#125;) res.redirect('/')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) JavaScript + Cookie자바스크립트로도 쿠키를 읽고 쓰는 방법이 존재하지만, 보안 상 문제를 일으킬 수 있으므로 이런 접근 방식은 거의 사용되지 않는다. 자바스크립트에서 쿠키에 접근하지 못하도록 HttpOnly를 항상 설정하는 것이 best practice 쿠키의 한계점 US-ASCII 밖에 저장하지 못함. 보통 percent encoding을 사용 4000 바이트 내외(영문 4000자, percent encoding 된 한글 444자 가량)밖에 저장하지 못함 브라우저에 저장됨. 즉, 여러 브라우저에 걸쳐 공유되어야 하는 정보, 혹은 웹 브라우저가 아닌 클라이언트(모바일 앱)에 저장되어야 하는 정보를 다루기에는 부적절","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Cookie","slug":"Node-js/Cookie","permalink":"http://yoursite.com/categories/Node-js/Cookie/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"}]},{"title":"Node-Session","slug":"node-study-node-session","date":"2017-09-04T03:54:00.000Z","updated":"2017-09-16T11:12:55.000Z","comments":true,"path":"2017/09/04/node-study-node-session/","link":"","permalink":"http://yoursite.com/2017/09/04/node-study-node-session/","excerpt":"","text":"Node SessionSession사전적 의미 (특정한 활동을 위한) 시간 (의회 등의)회기; (법정의) 개정 (기간) 실질적 의미시작 조건과 종료조건이 있는 시간, 또는 회기정보 교환이 지속되는 시간, 또는 회기 세션의 예 HTTP session요청 - 응답 클라이언트가 TCP 연결을 수립합니다(또는 전송 계층이 TCP가 아닌 다른 적당한 연결로). 클라이언트는 요청을 전송한 뒤 응답을 기다립니다. 서버는 요청에 대해 처리하고 그에 대한 응답을 상태 코드 그리고 요청에 부합하는 데이터와 함께 돌려보냅니다. 로그인 세션로그인 - 로그아웃 Google Analytics 세션페이지 접속 - 30분간 접속이 없으면 종료로 간주 (커스터마이징 가능) 웹 서비스를 위한 세션의 구현 세션이 시작되면, 세션이 시작되었다는 사실을 쿠키에 저장 세션에 대한 정보를 여러 요청에 걸쳐서 지속시키기 위해, 정보를 어딘가에 저장 세션이 만료되면, 세션이 만료되었다는 사실을 쿠키에 반영 위 방식은 널리 사용되는 방식일 뿐, 반드시 위와 같이 구현해야 하는 것은 아닙니다. 세션 스토어세션에 대한 정보를 저장하는 어딘가 쿠키 데이터베이스 파일 기타 정보를 저장할 수 있는 곳 어디든 세션 스토어의 선택서비스의 요구사항에 맞춰서 적절한 저장소를 선택하면 됨 정보의 형태가 간단하고 자주 바뀔 일이 없으면 쿠키 저장해야 할 정보의 양이 많으면 데이터베이스 정보가 굉장히 자주 변경되면 메모리 기반 저장소 세션? 세션 스토어?&#39;세션&#39;과 &#39;세션 스토어&#39;는 엄연히 다른 말이지만 혼용되는 경우가 많습니다. &#39;세션에 정보를 저장한다&#39;는 말은 &#39;세션 스토어에 정보를 저장한다&#39;는 말과 같은 뜻이라고 생각하면 됩니다. Express + Sessioncookie-session 쿠키에 모든 정보를 저장하는 세션 스토어. 첫 방문시 무조건 세션 시작express-session 쿠키에는 세션 식별자만 저장하고 실제 정보의 저장은 외부 저장소(데이터베이스 등)를 이용하는 세션 스토어. 외부 저장소에 대한 별도의 설정 필요 cookie-session 예제Link cookie-session NPM 패키지는 쿠키를 세션 스토어로 사용할 수 있도록 해주며 세션 스토어를 쉽게 사용할 수 있는 방법을 제공합니다. server.js 파일과 앱을 열어 어떤 방식으로 동작하는 앱인지 확인하고, 크롬 개발자 도구를 이용해 쿠키가 전달되고 저장되는 모습을 확인하세요. cookie-session 동작 방식 cookie-session 미들웨어는 첫 요청이 일어났을 때 빈 세션 정보(빈 객체)를 req.session에 주입합니다. 프로그래머는 세션과 관련된 정보를 req.session에 저장합니다. req.session은 보통의 자바스크립트 객체로, JSON으로 표현될 수 있는 자료라면 뭐든지 저장할 수 있습니다. cookie-session 미들웨어는 응답이 일어나기 직전에 req.session 객체를 문자열로 바꾼 뒤(JSON &amp; base64), 쿠키에 저장합니다. cookie-session 미들웨어는 다음 번 요청부터 쿠키에 저장된 정보를 자바스크립트 객체로 변환해 req.session에 주입합니다. 프로그래머는 req.session 객체를 이용해 세션 정보를 읽을 수 있습니다. 또한 세션 정보를 통째로 삭제하기 위해 미들웨어 또는 라우트 핸들러에서 req.session = null을 대입할 수 있습니다. session.sig? 서명!session 쿠키에 저장된 정보는 일반인은 알아볼 수 없지만 프로그래머라면 쉽게 복원하거나 변경할 수 있습니다. (base64 디코더로 session 쿠키를 변환해보세요) 만약에 세션에 계정 정보가 들어있고, 악의적인 해커가 쿠키의 값을 변경해서 세션 스토어를 조작할 수 있다면, 마치 다른 사람인 척 행세할 수 있고 그에 따라 정보를 탈취당할 수도 있을 것입니다. 그래서, cookie-session 미들웨어는 보안 유지를 위해 서명(signature)을 활용하고 있습니다. 컴퓨터 분야에서의 서명이란, 비밀 키를 이용해 정보를 특별한 알고리즘(hashing)으로 변형시킨 것을 말합니다. 서명의 가장 중요한 성질은, 같은 비밀 키로 같은 정보를 서명했을 때 언제나 같은 결과가 나온다는 것, 그리고 비밀 키나 정보 중 어느 한 쪽만 바뀌어도 서명의 결과가 크게 달라진다는 것입니다. 비밀 키와 서명을 활용하면 정보가 조작되었는지의 여부를 알 수 있습니다. 어떤 정보를 서명과 함께 공개하고 비밀 키는 숨기면, 누군가가 정보를 조작해서 올바른 정보인 척 흉내를 내려고 해도 비밀 키를 모르기 때문에 서명을 할 수 없어서 금방 조작인 것이 탄로가 나겠죠. cookie-session 미들웨어는 응답을 보낼 때 session 쿠키에 저장된 문자열을 비밀 키로 서명해서 그 결과를 session.sig 쿠키에 저장합니다. 만약에 요청에 포함된 session 쿠키를 다시 같은 비밀 키로 서명했는데 session.sig 쿠키와 일치하지 않는다면, 정보가 조작된 것을 알아채고 세션을 아예 삭제해버리는 방식으로 조작을 막습니다! 서명을 활용할 때 주의할 점이 있습니다. 비밀 키는 당연히 공개되지 않도록 관리해야 합니다. 비밀 키와 서명 알고리즘이 공개되면 서명이 조작될 수 있습니다. 키의 길이를 충분히 길게 해야 합니다. 해커가 서명 알고리즘을 알고 있다면, 짧은 비밀 키는 어렵지 않게 계산해낼 수 있습니다. 서명은 정보의 조작을 막아주지만, 정보의 공개를 막아주지는 않습니다. session 쿠키만 하더라도 base64 디코딩만 거치면 어떤 정보가 들어있는지 바로 확인할 수 있죠. 따라서 비밀번호나 신용카드 번호 등은 cookie-session이 제공하는 세션 스토어에 저장하면 안 됩니다. 참고로, 이전에 다뤘던 cookie-parser 미들웨어도 옵션을 활성화하면 서명을 사용하여 조작을 방지할 수 있습니다. 곧 배울 JWT도 보안을 위해 서명을 사용하고 있습니다. 서명 과정을 직접 시험해보고 싶다면 여기를 참고하세요. 12345678910111213141516171819202122232425262728293031323334353637383940414243const express = require('express')const cookieSession = require('cookie-session')const app = express()app.set('trust proxy', 1) app.set('view engine', 'ejs')// cookie-session 설정// name: 쿠키 이름으로 사용할 문자열// secret: 세션 정보를 서명할 때 사용할 키// 여러가지 옵션을app.use(cookieSession(&#123; name: 'session', secret: process.env.SECRET&#125;))// req.session.count를 처리하는 미들웨어const countMiddleware = (req, res, next) =&gt; &#123; if ('count' in req.session) &#123; // count 속성이 있으면 1으. req.session.count += 1 &#125; else &#123; // count 속성이 없으면 처음 방문한 것이므로 1로 설정한다. req.session.count = 1 &#125; next()&#125;// 첫 방문 후, 쿠키 관련 헤더가 요청과 응답에 잘 포함되는지 살펴보고,// 실제로 쿠키가 어떻게 저장되어있는지 살펴보세요.app.get('/', countMiddleware, (req, res) =&gt; &#123; res.render('index.ejs', &#123;count: req.session.count&#125;)&#125;)app.post('/reset-count', (req, res) =&gt; &#123; delete req.session.count res.redirect('/')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) req.session에다가 값을 저장하면 cookie value에 값이 저장된다. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;%= count %&gt;번 째 방문하셨습니다. &lt;/div&gt; &lt;form action=\"/reset-count\" method=\"post\"&gt; &lt;button type=\"submit\"&gt; 초기화 &lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 인증(Authentication)과 인가(Authorization)인증(Authentication)은 클라이언트가 누구인지를 확인하는 과정입니다. 지금은 ‘인증과 로그인은 같은 말’이라고 생각하셔도 무방합니다. 인가는 클라이언트가 하려고 하는 작업이 해당 클라이언트에게 허가된 작업인지를 확인하는 과정입니다. ‘권한 설정’이라고 생각하셔도 무방합니다. 예를 들어 다음 카페나 네이버 클럽에서는 관리자만이 게시판을 만들거나 없앨 수 있도록 인가됩니다. 인증 구현 전략인증은 여러가지 방식으로 구현될 수 있으며, 여기에서는 우리가 쓰고 있는 cookie-session 의 기능에 맞추어서 구현해보도록 하겠습니다. cookie-session이 제공하는 미들웨어는 첫 방문시 바로 세션을 시작하고 (이를 guest session이라 부릅니다) 쿠키에 빈 세션 정보(빈 객체)를 저장합니다. 그래서 첫 방문자에 대해서도 session 객체를 바로 쓸 수 있습니다. 아래와 같은 규칙으로 인증을 구현해보도록 합니다. req.session.username === undefined이면 로그인된 사용자가 없는 것으로 간주합니다. 사용자가 로그인 폼을 전송하면 accounts 배열에 저장된 계정 정보 중에 일치하는 것이 있는지 확인하고, 있다면 req.session.username에 해당 사용자 이름을 저장합니다. 만약 일치하는 계정이 없으면 400 Bad Request 응답을 보냅니다. req.session.username에 저장된 값이 있다면 해당 사용자로 로그인이 되어 있다고 간주합니다. 로그아웃을 하기 위해 req.session = null와 같이 대입해서 세션을 초기화합니다. (인증이 된 뒤에는 req.user와 res.locals.user에 계정 객체를 주입해서 라우트 핸들러와 템플릿에서 편하게 접근할 수 있도록 미리 코드를 짜 두었습니다.) 인가 구현 전략관리자만이 비밀 정보(/secret)에 접근할 수 있도록 해 보겠습니다. 사용자가 관리자인지 아닌지의 여부는 계정 객체의 admin 속성에 저장되어 있습니다. 로그인한 정보를 맞는지 확인하여서 값을 찾아낸다.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//server.jsconst express = require('express')const cookieSession = require('cookie-session')const bodyParser = require('body-parser')const app = express()const urlencodedMiddleware = bodyParser.urlencoded(&#123;extended: false&#125;)app.set('trust proxy', 1) app.set('view engine', 'ejs')const accounts = [ &#123; username: 'tpwns', password: 'kim', name: '김세준' &#125;, &#123; username: 'fast', password: 'campus', name: '패스트캠퍼스', admin: true &#125;]app.use(cookieSession(&#123; name: 'session', secret: process.env.SECRET&#125;))app.use((req, res, next) =&gt; &#123; if (req.session.username) &#123; req.user = res.locals.user = accounts.find(acc =&gt; acc.username === req.session.username) &#125; else &#123; req.user = res.locals.user = null &#125; next()&#125;)app.get('/', (req, res) =&gt; &#123; res.render('index.ejs')&#125;)app.post('/login', urlencodedMiddleware, (req, res) =&gt; &#123; const account = accounts.find(acc =&gt; acc.username === req.body.username &amp;&amp; acc.password === req.body.password) // 인증 과정을 작성해주세요. if(account)&#123; req.session.username = account.username res.redirect('/') &#125;else &#123; res.status(400) res.send('400 Bad Request') &#125; &#125;)function onlyAdminMiddleware(req, res, next) &#123; // `/secret`에 접속했을 때 이 미들웨어가 작동합니다. // 관리자가 아니면 403 Forbidden 응답을 보내도록 작성해주세요. // 위에서 req.session.username에 저장한 값을 통해 비교한다. const manage = accounts.find(acc =&gt; acc.username === req.session.username) if(manage.admin == true)&#123; // next를 통하여 전달한다. next() &#125;else &#123; res.status(403) res.send('403 Forbidden') &#125;&#125;app.get('/secret', onlyAdminMiddleware, (req, res) =&gt; &#123; res.send('It is my secret')&#125;)app.post('/logout', urlencodedMiddleware, (req, res) =&gt; &#123; req.session = null res.redirect('/')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) MiddleWare에서는 성공시 next로 보내줘야한다. session.sig을 통하여 session의 보안성이 지켜진다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Session","slug":"Node-js/Session","permalink":"http://yoursite.com/categories/Node-js/Session/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Session","slug":"Session","permalink":"http://yoursite.com/tags/Session/"}]},{"title":"Node-Service-Develop","slug":"node-study-service-develope","date":"2017-08-30T03:54:00.000Z","updated":"2017-09-15T14:50:58.000Z","comments":true,"path":"2017/08/30/node-study-service-develope/","link":"","permalink":"http://yoursite.com/2017/08/30/node-study-service-develope/","excerpt":"","text":"Node Service DevelopURL Shortener goo.gl bit.ly urlo.cc 요구사항 긴 URL을 짧은 URL로 변경하는 것은 한 명의 관리자만 만들 수 있음 짧은 URL은 누구나 이용할 수 있음 시나리오 설계화면 설계데이터 설계프로젝트 세팅 npm init -y .gitignore 추가 Express 앱 세팅 npm install –save express 템플릿 엔진 설 npm script 추 static 라우트 설 템플릿, CSS 파일 추가 로깅과 인증 morgan 설정 express-basic-auth 설정 초기 데이터 작업 randomstring 표로 보여주기 .ejs extension 설치 emmet 사용법 템플릿 작성 짧은 URL의 리디렉션 핸들러 작성 (301 Moved Permanently) Redirection cache 짧은 URL 링크 만들기 폼 body-parser 인증 설정 폼, 핸들러 작성 스타일링 Bootstrap CSS now.sh를 통한 배포 now 설치 환경변수란? dotenv 관리자 계정을 포함시켜 배포 Discussion 최적의 개발 순서? 적절한 커밋의 단위는?","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Service Develop","slug":"Node-js/Service-Develop","permalink":"http://yoursite.com/categories/Node-js/Service-Develop/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Service Develop","slug":"Service-Develop","permalink":"http://yoursite.com/tags/Service-Develop/"}]},{"title":"Node-Web-Form","slug":"node-study-web-form","date":"2017-08-30T03:54:00.000Z","updated":"2017-09-16T11:08:18.000Z","comments":true,"path":"2017/08/30/node-study-web-form/","link":"","permalink":"http://yoursite.com/2017/08/30/node-study-web-form/","excerpt":"","text":"Node Web FormHTML FormHTML form의 기본 동작HTML form을 전송하면, 입력된 정보가 기본적으로 percent encoding 되어 요청됨 GET method 이름=값 형식으로 간다.12GET /search?query=%EA%B0%9C&amp;sort=latest HTTP/1.1... Post method 이름=값 형식으로 간다. urlencoded로는 파일을 보내기에 부적절해서 다른 Content-type인 multipart를 사용한다. 12345POST /form HTTP/1.1Content-Type: application/x-www-form-urlencoded...home=Cosby&amp;favorite+flavor=flies multipart/ form-data 기본 설정(percent encoding)으로는 폼으로 파일을 업로드하는 것은 불가능 (클라이언트 측) form 태그에 enctype=&quot;multipart/form-data&quot;속성을 적용하면 파일 업로드 가능 (서버 측) body-parser 미들웨어는 multipart/form-data 형태의 요청을 지원하지 않음 (multer 필요) json, url-encoded형식을 req.body에서 사용하기 위해서는 body-parser가 필요하다. HTML Form 예제 Link UUID Redirection after submission Form validation 클라이언트 측 validation을 잘하면 사용자가 사용하기에 편하다. 클라이언트 측 validation 구현방법 1&lt;input required type=\"text\" name=\"title\"&gt; redirect(‘/‘)는 300(301 Moved Permanently302 Found) 번대 에러가 발생했을 때 다른 곳으로 보내준다. post 응답이 redirect가아닌 새로고침을 하면 같은 값이 계속 간다. Ajax를 사용할때는 redirect를 하지 않아도 괜찮다. 301과 302의 차이 301응답이란? 사용자가 보내면 web browser는 그걸을 기억했다가 똑같은 요청이 온다면 web browser가 서버에 요청을 하지않고 web browser에서 그전의 저장한 정보를 보낸다. res.redirect는 302 상태코드로 응답합니다. UUID 범용 공용 식별자 : 어디에서든지 유니크한 아이디 128bit의 숫자로 이루어져 있으며","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Web Form","slug":"Node-js/Web-Form","permalink":"http://yoursite.com/categories/Node-js/Web-Form/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Web Form","slug":"Web-Form","permalink":"http://yoursite.com/tags/Web-Form/"}]},{"title":"Node-Express","slug":"node-study-express","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-16T11:08:16.000Z","comments":true,"path":"2017/08/29/node-study-express/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-express/","excerpt":"","text":"Node Express 실습환경Glitch Tutorial 나의 Glitch Express Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크 내장하고 있는 기능은 매우 적으나, 미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음 공식 매뉴얼 한국어 번역 Express 앱의 기본 구조12345678910111213141516// Express Instance 생성const app = express()// 미들웨어 주입app.use(sessionMiddleware())app.use(authenticationMiddleware())// router handler registerapp.get('/', (request, response) =&gt; &#123; response.send('Hello express!')&#125;)// Server Startapp.listen(3000, ()=&gt;&#123; console.log('Example app listening on port 3000!')&#125;) Routing1234567891011121314151617181920212223const app = express()// HTTP Request Method (GET, POST, DELETE, PUT, ...)app.get('/articles', (req, res) =&gt; &#123; res.send('Hello Routing!')&#125;)// 특정 경로에만 미들웨어를 주입하는 것도 가능app.post('/articles', bodyParserMiddleware(), (req, res) =&gt; &#123; database.articles.create(req.body) // 요청한 body를 넣어둔다. .then(() =&gt; &#123; res.send(&#123;ok: true&#125;) &#125;)&#125;)// 경로의 특정 부분을 함수의 인자처럼 입력받을 수 있음app.get('/articles/:id', (req, res)=&gt; &#123; database.articles.find(req.params.id) // 'req.params.id'에 요청한 사람의 id가 저장된다. .then(article =&gt; &#123; res.send(article) &#125;)&#125;) Request 객체req.body requset.body를 적절한 형태의 자바스크립트 객체로 변환하여 이곳에 저장 (body-parser 미들웨어에 의해 처리됨) req.ip 요청한 쪽의 IP req.params route parameter req.query query string이 객체로 저장됨 Response 객체res.status(...) 응답의 상태 코드를 지정하는 메소드 res.append(...) 응답의 헤더를 지정하는 메소드 res.send(...) 응답의 바디를 지정하는 메소드 인자가 텍스트면 text/html, 객체면 application/json타입으로 응답 숫자를 send에 넣으면 error가 발생한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Express","slug":"Node-js/Express","permalink":"http://yoursite.com/categories/Node-js/Express/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://yoursite.com/tags/Express/"}]},{"title":"Node-Http","slug":"node-study-http","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-14T13:25:48.000Z","comments":true,"path":"2017/08/29/node-study-http/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-http/","excerpt":"","text":"HTTP History APIHTTP History API history.back() window.history.back(); history.forward() window.history.forward(); history.go() 히스토리에서 특정 위치로 가기 history.pushState() 히스토리 엔트리의 추가 및 변경 이 메서드들은 window.onpopstate 이벤트와 연동하여 동작합니다. HTTP 까보기 WireShark https를 사용하는 사이트는 wireshark로 찾아볼 수 없다. Chrome Devtools 검사탭 -&gt; Network HTTP 웹 브라우저와 웹 서버 간의 통신을 위해 개발된 통신규약 최근에는 REST API의 부상와 함꼐 다른 용도로도 널리 사용됨 모바일 앱 - 서버 간 통신 서버 - 서버 간 통신 80번 포트를 기본으로 사용 클라이언트의 요청(requert)과 서버의 응답(response)으로 이루어짐 HTTPS HTTP over SSL HTTP 통신을 암호화해 주고받는 내용을 중간에서 가로챌 수 없도록 함 443번 포트를 기본으로 사용 HTTP/2 구글의 SPDY 프로토콜을 기반으로 2015년에 확정된 새로운 HTTP 표준 속도 개선에 중점을 두고 개발됨 반드시 HTTPS를 사용해야 함 현재 전체 웹사이트 중 16% 이상이 사용중 HTTP 구성요소Request &amp; Response 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보냄 그에 따라 서버는 클라이언트에 응답(response)를 보냄 웹 브라우저의 경우, HTML 문서 형태의 응답이 오면 해당 문서를 분석한 후, 문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보냄 (이미지, 동영상, 오디오, CSS, JS, 폰트, …) Request Methods HTTP 명세에는 8 종류가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있음 GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH HTTP request methods 웹 브라우저는 특정 상황에서 특정 메소드로 요청을 보내도록 강제되어져 있음 Ajax와 같이 요청을 보내는 코드를 직접 짤 때는 요청 메소드를 선택할 수 있음 자료의 본문을 요청하는 GET메소드와, 새로운 자료를 등록하는 POST 메소드가 가장 많이 쓰임 (서버가 충족시켜야 하는) 메소드의 성질Safe 요청이 서버의 상태에 영향을 미치지 않아야 함. 즉, 읽기 전용 Idempotent 여러 번 같은 요청을 해도 한 번 요청한 것과 같은 효과여야 함. 네트워크가 불안정해도 안전하게 요청을 보낼 수 있음 Cacheable (특정 조건을 만족하면) 응답을 클라이언트에 저장해두었다가 다음 번 요청 때 다시 쓸 수 있음 fetch는 일부분만 바꿀때 사용하며, put은 전체를 바꿀때 사용한다, link 반드시 이 성질을 따르도록 서버를 구현해야 하는 것은 아니나, 구현했을 때의 이점이 있으므로 이대로 구현하는 것이 좋다 URL 2,3,4는 domain영역이다. 4(TOP)는 특별한 기관에서 관리를한다. Percent Encoding URL은 ASCII 문자(128개의 영문자+특수문자+제어문자)밖에 사용하지 못하기 때문에, non-ASCII 문자를 위한 표현방법이 필요함 # Percent encoding은 non-ASCII 문자를 위한 웹 표준 인코딩 방법으로, JavaScript에 관련 기능이 포함되어 있음 1234&gt; encodeURIComponent(\"한글\")\"%ED%95%9C%EA%B8%80\"&gt; decodeURIComponent(\"%ED%95%9C%EA%B8%80\")\"한글\" 1234const encoded = encodeURIComponent('패스트캠퍼스')undefineddecodeURIComponent(encoded)\"패스트캠퍼스\" Request Target일반적인 경우 아래와 같은 구조가 사용됨 absolute path + query string + fragment id 1GET /path/to/resource?foo=bar&amp;spam=hoge#fragid HTTP/1.1 Response Status 응답의 성공, 실패 여부와 종류를 나타내며, 상태 코드 + 상태 메시지의 형태로 응답에 포함됨 1HTTP/1.1 200 OK HTTP Status Codes Status Category2xx 성공 3xx 추가 작업이 필요함 4xx 실패 - 클라이언트 책임 5xx 실패 - 서버 책임 Status Code - 2xx200 ok 성공 201 Created 자료가 성공적으로 생성됨 Status Code - 3xx301 Moved Permanently (Redirection) 자료가 완전히 다른 곳으로 이동했음 302 Found (Redirection) 자료가 일시적으로 다른 곳에 있음 304 Not Modified (Cache) 클라이언트가 이미 가지고 있던 자료가 수정되지 않았음 (그대로 사용하면 됨) Status Code - 4xx400 Bad Request 요청의 형태가 잘못되어 응답할 수 없음 403 Forbidden 요청한 자료에 접근할 권한이 없음 404 Not Found 요청한 자료가 없음 Status Code - 5xx500 Internal Server Error 요청을 처리하던 중에 예상치 못한 오류가 발생함 503 Service Unavailable 서버가 일시적으로 응답을 할 수 없음 Header 요청과 응답에 대한 추가 정보를 표현하는 데 사용됨 인증, 캐싱, 쿠키, 보안, 내용협상, 프록시 등 웹 표준에 정의된 많은 기능을 제어하는 데 사용됨 Authorization 요청의 인증 정보 User-Agent 요청 중인 클라이언트의 정보 Location 301, 302 응답에서 자료의 위치 Accept 요청이 어떤 형태의 자료를 원하는지 나타냄 Content-Type 요청 혹은 응답이 어떤 형태의 자료인지 나타냄 Content Negotiation 요청의 Accept, Accept-Language 등의 헤더를 보고 서버가 그에 맞는 형태의 자료를 응답하는 절차를 content negotiation(내용협상)이라고 함","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Http","slug":"Node-js/Http","permalink":"http://yoursite.com/categories/Node-js/Http/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Http","slug":"Http","permalink":"http://yoursite.com/tags/Http/"}]},{"title":"Node-Template-Language","slug":"node-study-template-language","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-15T14:51:19.000Z","comments":true,"path":"2017/08/29/node-study-template-language/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-template-language/","excerpt":"","text":"Node Template LanguageStatic Web Page누가 어떻게 요청하든 미리 저장되어 있던 HTML 파일을 그대로 응답 Dynamic Web Page요청한 사람과 요청한 내용에 따라 각각 다른 내용으로 편집한 HTML을 응답 Template Engine템플릿과 데이터를 결합해 문서를 생성하는 프로그램, 혹은 라이브러리템플릿을 작성할 때 사용하는 언어를 템플릿 언어라고 함 EJSEmbedded JavaScript Template # Node.js 생태계에서 가장 많이 사용되는 템플릿 엔진 문법이 단순 JavaScript 코드를 템플릿 안에서 그대로 쓸 수 있음 .ejs VSCode Extension 1234567891011121314&lt;%# index.ejs %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"message\"&gt; &lt;%= message %&gt; &lt;/div&gt; &lt;% if (showSecret) &#123; %&gt; &lt;div&gt;my secret&lt;/div&gt; // showSecret이 true면 my secret을 보여주고 false면 보여주지 말아라. &lt;% &#125; %&gt; &lt;/body&gt;&lt;/html&gt; &lt;%= title %&gt; 을 사용하여서 데이터의 title을 가진 값을 집어 넣는다. Express에서 EJS 사용하기ejs 설치1$ npm install --save ejs template engine 설정1app.set('view engine', 'ejs') res.render()123456const data = &#123; title: 'Template Language', message: 'Hello EJS!', showSecret: true&#125;res.render('index.ejs', data) Serving Static Files 템플릿 파일에서 참조할 수 있다. 변하지 않는 파일들을 넣어서 보관해둔다.1234567// `public` 폴더에 있는 파일을 `/static` 경로 아래에서 제공app.set('view engine', 'ejs')app.use('/static', express.static('public'))&lt;!-- 템플릿 파일에서 참조할 수 있음 --&gt;&lt;link rel=\"stylesheet\" href=\"/static/index.css\"&gt;&lt;script type=\"text/javascript\" src=\"/static/index.js\"&gt;&lt;/script&gt;","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Template Language","slug":"Node-js/Template-Language","permalink":"http://yoursite.com/categories/Node-js/Template-Language/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"template Language","slug":"template-Language","permalink":"http://yoursite.com/tags/template-Language/"}]},{"title":"Node-Rest-API","slug":"node-study-restapi","date":"2017-08-28T03:54:00.000Z","updated":"2017-09-14T13:23:54.000Z","comments":true,"path":"2017/08/28/node-study-restapi/","link":"","permalink":"http://yoursite.com/2017/08/28/node-study-restapi/","excerpt":"","text":"Node Rest API 실습PostMan REST API를 시험해볼 수 있는 도구 다양한 편의기능 제공 Github Rest API https://api.github.com/users/KimSejune 나의 정보를 받아올수있다.Rest API link HTTP의 전송 GET/user/repo Authorization은 Basic, Digest, Bearer 3가지로 이루어져있다. Node.js NVM을 통하여 새로운 노드를 추가적으로 설치한다. nvm 설치방법curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash 터미널을 종료한 후에 123 export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 12345# 주석: `#`으로 시작하는 명령은 bash에서 무시됩니다.# 아래 명령을 한 줄씩 차례대로 입력하세요$ nvm install 8.4$ nvm use 8.4$ nvm alias default 8.4 # nvm-windows는 필요없음 다시 돌아가는 방법 nvm ls를 하고 nvm use system을 하면 원래사용하던 node로 돌아온다. nvm use default를 통해서 nvm으로 돌아온다. 1234567891011// 여러 줄에 나눠서 입력하기&gt; function factorial2(n) &#123;... return n &lt; 1 ? 1 : n * factorial(n-1)... &#125;undefined&gt; factorial2(4)24// `.exit`를 입력하거나 `Ctrl+C`를 두 번 입력해서 나가기&gt; .exit node.js module을 사용한다. 123456789// Node.js module 사용하기&gt; const os = require('os') // 급할땐 `os = ...`undefined&gt; os.platform()'darwin'&gt; os.freemem()658300928 운영체제에 상관없이 경로를 사용할 수 있게 해준다.node.js path api Node.js로 파일 실행시키기1$ node (파일 경로) Node js의 이론 node.js 는 js의 runtime이며 chrome의 Javascript V8 engine을 사용한다. event-drive, non-blocking I/O model을 사용한다. JavaSCript runtime js는 언어 js runtime은 js를 구동하기 위해 필요한 실행 환경 프로그래머는 런타임이 제공하는 도구를 응용해서 프로그램을 개발 웹 브라우저(chrome, edge)나 Node.js도 JavaScript 런타임의 일종 Chrome이 제공하는 웹 브라우저용 런타임 Node.js가 제공하는 서버용 런타임 MongoDB가 제공하는 데이터 처리용 런타임 Photoshop이 제공하는 전용 런타임 V8 JavaScript Engine JIT(Just-In-Time) compilation Code Optimization Used in Google Chrome Node.js MongoDB … js가 V8 js engine을 통하여 속도가 대폭 향상되었다. Event-driven Programming 프로그램의 흐름이 외부 요인에 의해 일어나는 사건에 의해 결정되는 프로그래밍 양식 약속된 방식으로 이벤트 핸들러를 작성함으로써 외부 이벤트가 일어났을 때 코드를 실행 마우스 입력 키보드 입력 다른 프로그램/컴퓨터로부터의 통신 123456789101112// DOM 이벤트 핸들러 등록 (웹 브라우저)domElement.addEventListener('click', function(e) &#123; e.stopPropagation() alert('hello')&#125;)// 서버도 똑같이 합니다.// (단, 프레임워크를 쓸 때는 직접 이벤트를 다룰 일이 별로 없음)// HTTP 응답 이벤트 핸들러 등록 (Node.js)httpResponse.on('data', data =&gt; &#123; console.log(data)&#125;) node.js를 할 때 직접적으로 이벤트를 다룰 일은 별로 없다. Non-blocking I/O Blocking I/O는 스레드가 입력/출력이 완료될 때까지 기다렸다가 다음 코드를 실행 Non-blocking I/O는 스레드가 입력/출력을 기다리지 않고 코드를 계속 실행 I/O 성능 향상 &amp; 복잡한 코드 Node.js Module123456789101112131415// name.js// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음module.exports = &#123; familyName: '김', givenName: '승하', fullName: function() &#123; return this.familyName + this.givenName &#125;&#125;// calc.js// `exports`로도 참조 가능exports.add = (x, y) =&gt; x + yexports.sub = (x, y) =&gt; x - y name.js에서 저장한 module.exports의 값들을 다른 파일에서 사용할 수 있게한다. module.exports 안에는 빈객체가 들어있어서 exports. ~~ 를해도 코드가 작동한다. module를 생략해도된다. 단) 객체를 통째로 생성할때는 module을 붙여준다. 123456789101112131415&gt; const name = require('./name.js')undefined&gt; name&#123; familyName: '김', givenName: '세준', fullName: [Function: fullName] &#125;&gt; name.familyName'김'&gt; name.givenName'세준'&gt; name.fullName[Function: fullName]&gt; name.fullName()'김세준'&gt; 객체를 내가원하는 함수에다가 바로 넘길수도 있다 ReceiveObjsct(require(&#39;./name.js&#39;)) node.js는 module마다 각각의 scope가 존재한다. 그래서 전역에다가 저장이 안되고 module scope에다가 저장을 한다. 다른 module에서 사용하려면 무조건 export안에 들어있어야한다. REPL에서 불러오기 Node.js 패키지 관리 도구 + 클라우드 패키지 저장소 의존 패키지 관리 스크립트 실행 패키지 설정 NPM에 패키지 배포 Node.js 종합 작업 도구 Hello NPM1234567891011121314151617$ mkdir hello-npm$ cd hello-npm$ npm init -y$ code .// package.json&#123; \"name\": \"hello-npm\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\"&#125; package.json 패키지 정보를 담고 있는 파일 dependencies npm install --save 명령으로 설치한 패키지가 기록됨 scripts 원래 목적은 패키지 생명주기마다 자동으로 실행되는 명령을 등록하기 위함이나, 개발자 편의를 위해 자주 사용되는 명령을 등록하는 용도로 더 많이 사용됨 1234567891011$ npm install --save randomstring # node_modules에 저장됨// index.jsconst randomstring = require('randomstring')console.log(randomstring.generate())// package.json... \"scripts\": &#123; \"start\": \"node index.js\" &#125;...$ npm start // start라는 이름으로 script에 등록을 하여서 실행시킬수있다. Concurrency(동시성)Concurrency Model(동시성 모델) 프로그램이 생애 주기가 겹치는 여러 실행 과정을 통해 실행된다 하더라도 프로그램의 결과에는 영향을 미치지 않는 성질 생애 주기가 겹치는 여러 실행 과정이 자원을 공유할 때 어떻게 충돌이 생기지 않도록 할 것인가? Resources CPU Memory Network thread 코드 실행의 가장 작은 단위 프로그램은 하나 이상의 스레드로 이루어짐 CPU 코어 하나는 한 번에 하나의 스레드를 실행 thread 확인방법 1$ sysctl -n hw.ncpu // 시스템의 코어개수 운영체제 차원의 도구 Process Thread Mutex (Mutual Exclusion) 언어 차원의 도구 Python - asyncio Go - goroutine Erlang - actor JavaScript - …? 자바스크립트의 동시성(Single-Threaded Event Loop) 자바스크립트를 실행시키는 스레드가 하나 뿐임 실행 과정(보통 콜백 연쇄)의 생애 주기가 겹칠 수는 있지만 어떤 경우에도 두 자바스크립트 실행과정이 동시에 실행되는 경우는 없음 내부적으로 메시지 큐를 활용하고 있으나, 모든 처리가 자동으로 이루어짐MDN 장점 프로그래머가 동시성에 대해 신경쓸 필요가 없어짐 프로그램 작성이 쉬워짐 단점 CPU를 많이 쓰는 작업에 부적절 오래 걸리는 자바스크립트 코드가 실행되면 전체 프로그램에 영향을 미침 전략 오래 걸리는 일은 외부에 위임하고 넘어간 뒤, 나중에 결과를 받아 처리하기 Database Node.js-External libraries Web browser - webAssembly 긴 실행과정을 여러개의 함수로 쪼개서한 번의 함수 실행이 금방 끝나게 만들기 Ascynchronous JavaScript non-blocking하고 비슷한 개념이다. 코드의 작성법에 대한 개념이다. Ascynchronous Callback 함수를 호출할 떄, 콜백까지 같이 인자에 넣어서 호출하는 비동기 프로그래밍 양식 콜백에서 에러 인자를 받는 방식으로 에러 처리를 함 Node.js 내장 모듈 전체가 이 방식을 사용하도록 만들어져 있음 모든 콜백이 비동기인 것은 아님 12&gt; [1,2,3].map(x =&gt; x*x)[ 1, 4, 9 ] 계산을 기다렸다가 바로 출력한다. readFile fs라는 file에 내장되어있다. 첫번째 인자를 err로 받는다. 123456789101112// readFile.js 비동기식 코드const fs = require('fs') // Node.js 내장 모듈fs.readFile('./calc.js', 'utf8', (err, data) =&gt; &#123; console.log(data)&#125;)console.log('done!')// readFileSync.js 동기식 코드const fs = require('fs') // Node.js 내장 모듈const data = fs.readFileSync('./calc.js', 'utf8')console.log(data)console.log('done!') try, catch는 동기식에서만 에러처리를 할 수 있다. request 설치12$ # hello-npm 폴더 안에서 실행$ npm install --save request Github REST API 호출123456789101112131415161718192021222324252627282930313233// 유저 이름, 저장소, 할당된 이슈 갯수 출력하기const request = require('request')const apiUrl = 'https://api.github.com'const option = &#123; json: true, auth: &#123; 'user': 'username', 'pass': 'password', &#125;, headers: &#123; 'User-Agent': 'request' &#125;&#125;request.get(`$&#123;apiUrl&#125;/user`, option, function (error, response, body) &#123; const name = body.name if (error) console.error(error) // 콜백 안에 콜백 request.get(`$&#123;apiUrl&#125;/user/repos`, option, function (error, response, body) &#123; if (error) console.error(error) const repoNames = body.map(item =&gt; item.name) // 콜백 안에 콜백 안에 콜백 request.get(`$&#123;apiUrl&#125;/issues`, option, function (error, response, body) &#123; if (error) console.error(error) const issueNum = body.length console.log(`name: $&#123;name&#125;`) console.log('repos:') repoNames.forEach(name =&gt; &#123; console.log(name) &#125;) console.log(`num of assigned issues: $&#123;issueNum&#125;`) &#125;) &#125;)&#125;) request function이 만든사람이 error, response, body 를 parameter로 받는다. Callback Hell Callback의 Hell을 방지하기 위해서 Promise를 사용한다. Promise 비동기 작업의 결과를 담는 객체 정확히 언제가 될지 모르지만, 결국 성공 또는 실패의 상태를 갖게 됨 12345678910111213141516171819// tenSec.jsmodule.exports = function tenSec(value) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(value) &#125;, 10000) &#125;)&#125;// REPL&gt; const tenSec = require('./tenSec')&gt; const p = tenSec(1)&gt; p // 만든지 10초가 지나기 전Promise &#123; [pending], ...&gt; p // 만든지 10초가 지난 후Promise &#123; 1, ... export안에 함수를 넣어서 값이 함수로 나온다. 12345678&gt; tenSec('hello promise').then(value =&gt; &#123;... console.log(value)... &#125;)Promise &#123; // `then`은 Promise를 반환 [pending], ...&gt; // 10초 후'hello promise' then안에서 promise를 return하면 promise를 벗기고 안의 값만 들어간다. 1234567891011121314151617181920212223// chaining.jsconst tenSec = require('./tenSec')tenSec('hello promise') .then(value =&gt; &#123; console.log(value) return 1 // 위 `.then`은 값이 1인 Promise를 반환함 &#125;) .then(value =&gt; &#123; console.log(value) return tenSec('new promise') // Promise도 반환할 수 있음 &#125;) .then(value =&gt; &#123; console.log(value) &#125;) .then(() =&gt; &#123; throw new Error('error in promise') &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) .then(() =&gt; &#123; // 에러 처리 이후에도 코드 실행 가능 console.log('done') &#125;) catch 앞의 then 부분에서 에러가 발생하면 catch안의 값이 실행된다. 맨 위의 then에서 에러가나면 바로 catch로 넘어간다. promise.all([…]) 배열안의 넘기는 값들이 모두 성공해야지 성공한다. promise.rase([…]) 배열안의 값중에서 먼저 성공한것을 나타낸다. readFile - promise node.js v8부터 새로들어온 함수이다. 1234567891011// readfilePromise.jsconst &#123;promisify&#125; = require('util') // Node.js 8.0.0부터 추가됨const fs = require('fs')const readFile = promisify(fs.readFile)readFile('./calc.js', 'utf8') .then(data =&gt; &#123; console.log(data) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 파일을 다읽으면 반환하는 promise파일을 반환한다. Promise의 특징 이미 resolve 된 Promise에도 콜백을 실행할 수 있음 12&gt; const resolved = Promise.resolve(1)&gt; resolved.then(v =&gt; console.log(v)) .then에 넘겨진 콜백은 무조건 다음 루프에 실행됨 12345678&gt; (function() &#123;... Promise.resolve(1).then(v =&gt; console.log(v))... console.log(&apos;done!&apos;)... &#125;)()/* 출력:done!1*/ Promise.all1234567891011121314151617181920212223242526272829// npm install --save request-promiseconst rp = require('request-promise')const apiUrl = 'https://api.github.com'const option = &#123; json: true, auth: &#123; 'user': 'username', 'pass': 'password', &#125;, headers: &#123; 'User-Agent': 'request' &#125;&#125;const userPromise = rp.get(`$&#123;apiUrl&#125;/user`, option)const reposPromise = rp.get(`$&#123;apiUrl&#125;/user/repos`, option)const issuesPromise = rp.get(`$&#123;apiUrl&#125;/issues`, option)// 배열 내의 모든 Promise 객체가 완료되었을 때// resolve 되는 Promise를 만든다.Promise.all([userPromise, reposPromise, issuesPromise]) .then(([user, repos, issues]) =&gt; &#123; console.log(`name: $&#123;user.name&#125;`) console.log('repos:') repos.forEach(repo =&gt; &#123; console.log(repo.name) &#125;) console.log(`num of assigned issues: $&#123;issues.length&#125;`) &#125;) axiosfetch api fetch api, axios를 통하여 Ajax통신을 promise를 통하여 통신을 할 수 있게한다. Async/Await javascript의 문법을 바꾸어버렸다. 비동기 코드를 동기식 코드처럼 편하게 짤 수 있게 만든 것이다. async function은 무조건 promise를 반환하며 await가 완료될때 까지 기다린다.12345678910const tenSec = require('./tenSec')async function resolveAfterTenSec() &#123; await tenSec() return 1&#125;resolveAfterTenSec().then(value =&gt; &#123; console.log(value)&#125;) ES2017에서 도입되어, 비동기식 코드를 동기식 코드처럼 쓸 수 있는 문법 제공 Chrome 55, Node.js 8.0.0 부터 사용가능 async function 안에서 반환된 값은 최종적으로 Promise 객체로 변환되어 반환된다. async function 안에서 쓸 수 있는 await 키워드는 현재 함수를 중단시키고 Promise 객체가 충족될 때까지 기다리지만, 스레드를 block 하지 않는다. 에러 처리는 동기식 코드처럼 try, catch 블록을 통해서 한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Rest-API","slug":"Node-js/Rest-API","permalink":"http://yoursite.com/categories/Node-js/Rest-API/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"RestAPI","slug":"RestAPI","permalink":"http://yoursite.com/tags/RestAPI/"}]}]}