{"meta":{"title":"KimSejune Start Study","subtitle":"Node.js JavaScript","description":null,"author":"Sejune kim","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Node-Express","slug":"node-study-node-cookie","date":"2017-09-04T03:54:00.000Z","updated":"2017-09-16T11:06:23.000Z","comments":true,"path":"2017/09/04/node-study-node-cookie/","link":"","permalink":"http://yoursite.com/2017/09/04/node-study-node-cookie/","excerpt":"","text":"Node Cookie쿠키의 필요성 개별 클라이언트의 여러 요청에 걸친 정보의 유지 장바구니 로그인/로그아웃 방문 기록 HTTP Cookie 서버가 응답을 통해 웹 브라우저에 저장하는 이름+값 형태의 정보 웹 브라우저는 쿠키를 저장하기 위한 저장소를 가지고 있음 저장소는 자료의 유효기간과 접근 권한에 대한 다양한 옵션을 제공 쿠키 전송 절차 서버는 브라우저에 저장하고 싶은 정보를 응답과 같이 실어 보낸다(Set-Cookie 헤더) 12HTTP/1.1 200 OKSet-Cookie: cookieName=cookieValue; Secure; Max-Age=60000 브라우저는 같은 서버에 요청이 일어날 때마다 해당 정보를 요청에 같이 실어서 서버에 보낸다 (Cookie 헤더) 12GET / HTTP/1.1Cookie: cookieName=cookieValue; anotherName=anotherValue Set-Cookie OptionsExpires, Max-Age 쿠키의 지속 시간 설정 Secure HTTPS를 통해서만 쿠키가 전송되도록 설정 HttpOnly 자바스크립트에서 쿠키를 읽지 못하도록 설정 Domain, Path 쿠키의 scope 설정 (쿠키가 전송되는 URL을 제한) Express + Cookie쿠키 읽기 - req.cookies 요청에 실려온 쿠키가 객체로 변환되어 req.cookies에 저장됨(cookie-parser middleware 필요) 쿠키 쓰기 - res.cookie(name, value) 쿠키의 생성 혹은 수정 쿠키 예제Link 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const express = require('express')const cookieParser = require('cookie-parser')const app = express()app.set('trust proxy', 1)app.use(cookieParser())app.get('/', (req, res) =&gt; &#123; res.send(req.cookies)&#125;)app.get('/somePath', (req, res) =&gt; &#123; res.send(req.cookies)&#125;)// 별다른 옵션 없이 쿠키를 저장하는 응답을 보냅니다.app.get('/set', (req, res) =&gt; &#123; res.cookie('cookieName', 'cookieValue') res.redirect('/')&#125;)// httpOnly 옵션은 해당 쿠키를 자바스크립트에서 접근할 수 없게 합니다. 즉 보안성이 향상app.get('/httpOnly', (req, res) =&gt; &#123; res.cookie('httpOnlyCookie', 'value', &#123; httpOnly: true &#125;) res.redirect('/')&#125;)// secure 옵션은 http 프로토콜을 통한 요청에는 쿠키가 포함되지 않게 합니다. (https로 했을 때만 포함시킴)app.get('/secure', (req, res) =&gt; &#123; res.cookie('secureCookie', 'value', &#123; secure: true &#125;) res.redirect('/')&#125;)// maxAge 옵션은 쿠키가 해당 시간이 지났을 때 삭제되도록 합니다.app.get('/maxAge', (req, res) =&gt; &#123; res.cookie('maxAgeCookie', 'value', &#123; maxAge: 5000 &#125;) res.redirect('/')&#125;)// domain 옵션은 해당 도메인 및 서브도메인으로 쿠키가 전송되도록 합니다.app.get('/domain', (req, res) =&gt; &#123; res.cookie('domainCookie', 'value', &#123; domain: 'glitch.me' &#125;) res.redirect('/')&#125;)// path 옵션은 쿠키가 지정된 경로 및 그 하위 경로에 요청이 일어났을 때만 전송되도록 합니다.// 루트에서는 안보이고 somePath에서는 보인다.app.get('/path', (req, res) =&gt; &#123; res.cookie('pathCookie', 'value', &#123; path: '/somePath' &#125;) res.redirect('/')&#125;)// 여러 옵션을 한꺼번에 지정할 수도 있습니다.app.get('/multiple-options', (req, res) =&gt; &#123; res.cookie('multipleOption', 'value', &#123; secure: true, httpOnly: true, maxAge: 5000 &#125;) res.redirect('/')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) JavaScript + Cookie자바스크립트로도 쿠키를 읽고 쓰는 방법이 존재하지만, 보안 상 문제를 일으킬 수 있으므로 이런 접근 방식은 거의 사용되지 않는다. 자바스크립트에서 쿠키에 접근하지 못하도록 HttpOnly를 항상 설정하는 것이 best practice 쿠키의 한계점 US-ASCII 밖에 저장하지 못함. 보통 percent encoding을 사용 4000 바이트 내외(영문 4000자, percent encoding 된 한글 444자 가량)밖에 저장하지 못함 브라우저에 저장됨. 즉, 여러 브라우저에 걸쳐 공유되어야 하는 정보, 혹은 웹 브라우저가 아닌 클라이언트(모바일 앱)에 저장되어야 하는 정보를 다루기에는 부적절","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Cookie","slug":"Node-js/Cookie","permalink":"http://yoursite.com/categories/Node-js/Cookie/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"}]},{"title":"Node-Service-Develop","slug":"node-study-service-develope","date":"2017-08-30T03:54:00.000Z","updated":"2017-09-15T14:50:58.000Z","comments":true,"path":"2017/08/30/node-study-service-develope/","link":"","permalink":"http://yoursite.com/2017/08/30/node-study-service-develope/","excerpt":"","text":"Node Service DevelopURL Shortener goo.gl bit.ly urlo.cc 요구사항 긴 URL을 짧은 URL로 변경하는 것은 한 명의 관리자만 만들 수 있음 짧은 URL은 누구나 이용할 수 있음 시나리오 설계화면 설계데이터 설계프로젝트 세팅 npm init -y .gitignore 추가 Express 앱 세팅 npm install –save express 템플릿 엔진 설 npm script 추 static 라우트 설 템플릿, CSS 파일 추가 로깅과 인증 morgan 설정 express-basic-auth 설정 초기 데이터 작업 randomstring 표로 보여주기 .ejs extension 설치 emmet 사용법 템플릿 작성 짧은 URL의 리디렉션 핸들러 작성 (301 Moved Permanently) Redirection cache 짧은 URL 링크 만들기 폼 body-parser 인증 설정 폼, 핸들러 작성 스타일링 Bootstrap CSS now.sh를 통한 배포 now 설치 환경변수란? dotenv 관리자 계정을 포함시켜 배포 Discussion 최적의 개발 순서? 적절한 커밋의 단위는?","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Service Develop","slug":"Node-js/Service-Develop","permalink":"http://yoursite.com/categories/Node-js/Service-Develop/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Service Develop","slug":"Service-Develop","permalink":"http://yoursite.com/tags/Service-Develop/"}]},{"title":"Node-Express","slug":"node-study-web-form","date":"2017-08-30T03:54:00.000Z","updated":"2017-09-15T14:59:13.000Z","comments":true,"path":"2017/08/30/node-study-web-form/","link":"","permalink":"http://yoursite.com/2017/08/30/node-study-web-form/","excerpt":"","text":"Node Web FormHTML FormHTML form의 기본 동작HTML form을 전송하면, 입력된 정보가 기본적으로 percent encoding 되어 요청됨 GET method 이름=값 형식으로 간다.12GET /search?query=%EA%B0%9C&amp;sort=latest HTTP/1.1... Post method 이름=값 형식으로 간다. urlencoded로는 파일을 보내기에 부적절해서 다른 Content-type인 multipart를 사용한다. 12345POST /form HTTP/1.1Content-Type: application/x-www-form-urlencoded...home=Cosby&amp;favorite+flavor=flies multipart/ form-data 기본 설정(percent encoding)으로는 폼으로 파일을 업로드하는 것은 불가능 (클라이언트 측) form 태그에 enctype=&quot;multipart/form-data&quot;속성을 적용하면 파일 업로드 가능 (서버 측) body-parser 미들웨어는 multipart/form-data 형태의 요청을 지원하지 않음 (multer 필요) json, url-encoded형식을 req.body에서 사용하기 위해서는 body-parser가 필요하다. HTML Form 예제 Link UUID Redirection after submission Form validation 클라이언트 측 validation을 잘하면 사용자가 사용하기에 편하다. 클라이언트 측 validation 구현방법 1&lt;input required type=\"text\" name=\"title\"&gt; redirect(‘/‘)는 300(301 Moved Permanently302 Found) 번대 에러가 발생했을 때 다른 곳으로 보내준다. post 응답이 redirect가아닌 새로고침을 하면 같은 값이 계속 간다. Ajax를 사용할때는 redirect를 하지 않아도 괜찮다. 301과 302의 차이 301응답이란? 사용자가 보내면 web browser는 그걸을 기억했다가 똑같은 요청이 온다면 web browser가 서버에 요청을 하지않고 web browser에서 그전의 저장한 정보를 보낸다. res.redirect는 302 상태코드로 응답합니다. UUID 범용 공용 식별자 : 어디에서든지 유니크한 아이디 128bit의 숫자로 이루어져 있으며","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Web Form","slug":"Node-js/Web-Form","permalink":"http://yoursite.com/categories/Node-js/Web-Form/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Web Form","slug":"Web-Form","permalink":"http://yoursite.com/tags/Web-Form/"}]},{"title":"Node-Express","slug":"node-study-express","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-14T13:23:21.000Z","comments":true,"path":"2017/08/29/node-study-express/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-express/","excerpt":"","text":"Node Express 실습환경Glitch Tutorial 나의 Glitch Express Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크 내장하고 있는 기능은 매우 적으나, 미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음 공식 매뉴얼 한국어 번역 Express 앱의 기본 구조12345678910111213141516// Express Instance 생성const app = express()// 미들웨어 주입app.use(sessionMiddleware())app.use(authenticationMiddleware())// router handler registerapp.get('/', (request, response) =&gt; &#123; response.send('Hello express!')&#125;)// Server Startapp.listen(3000, ()=&gt;&#123; console.log('Example app listening on port 3000!')&#125;) Routing1234567891011121314151617181920212223const app = express()// HTTP Request Method (GET, POST, DELETE, PUT, ...)app.get('/articles', (req, res) =&gt; &#123; res.send('Hello Routing!')&#125;)// 특정 경로에만 미들웨어를 주입하는 것도 가능app.post('/articles', bodyParserMiddleware(), (req, res) =&gt; &#123; database.articles.create(req.body) // 요청한 body를 넣어둔다. .then(() =&gt; &#123; res.send(&#123;ok: true&#125;) &#125;)&#125;)// 경로의 특정 부분을 함수의 인자처럼 입력받을 수 있음app.get('/articles/:id', (req, res)=&gt; &#123; database.articles.find(req.params.id) // 'req.params.id'에 요청한 사람의 id가 저장된다. .then(article =&gt; &#123; res.send(article) &#125;)&#125;) Request 객체req.body requset.body를 적절한 형태의 자바스크립트 객체로 변환하여 이곳에 저장 (body-parser 미들웨어에 의해 처리됨) req.ip 요청한 쪽의 IP req.params route parameter req.query query string이 객체로 저장됨 Response 객체res.status(...) 응답의 상태 코드를 지정하는 메소드 res.append(...) 응답의 헤더를 지정하는 메소드 res.send(...) 응답의 바디를 지정하는 메소드 인자가 텍스트면 text/html, 객체면 application/json타입으로 응답 숫자를 send에 넣으면 error가 발생한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Express","slug":"Node-js/Express","permalink":"http://yoursite.com/categories/Node-js/Express/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://yoursite.com/tags/Express/"}]},{"title":"Node-Http","slug":"node-study-http","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-14T13:25:48.000Z","comments":true,"path":"2017/08/29/node-study-http/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-http/","excerpt":"","text":"HTTP History APIHTTP History API history.back() window.history.back(); history.forward() window.history.forward(); history.go() 히스토리에서 특정 위치로 가기 history.pushState() 히스토리 엔트리의 추가 및 변경 이 메서드들은 window.onpopstate 이벤트와 연동하여 동작합니다. HTTP 까보기 WireShark https를 사용하는 사이트는 wireshark로 찾아볼 수 없다. Chrome Devtools 검사탭 -&gt; Network HTTP 웹 브라우저와 웹 서버 간의 통신을 위해 개발된 통신규약 최근에는 REST API의 부상와 함꼐 다른 용도로도 널리 사용됨 모바일 앱 - 서버 간 통신 서버 - 서버 간 통신 80번 포트를 기본으로 사용 클라이언트의 요청(requert)과 서버의 응답(response)으로 이루어짐 HTTPS HTTP over SSL HTTP 통신을 암호화해 주고받는 내용을 중간에서 가로챌 수 없도록 함 443번 포트를 기본으로 사용 HTTP/2 구글의 SPDY 프로토콜을 기반으로 2015년에 확정된 새로운 HTTP 표준 속도 개선에 중점을 두고 개발됨 반드시 HTTPS를 사용해야 함 현재 전체 웹사이트 중 16% 이상이 사용중 HTTP 구성요소Request &amp; Response 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보냄 그에 따라 서버는 클라이언트에 응답(response)를 보냄 웹 브라우저의 경우, HTML 문서 형태의 응답이 오면 해당 문서를 분석한 후, 문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보냄 (이미지, 동영상, 오디오, CSS, JS, 폰트, …) Request Methods HTTP 명세에는 8 종류가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있음 GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH HTTP request methods 웹 브라우저는 특정 상황에서 특정 메소드로 요청을 보내도록 강제되어져 있음 Ajax와 같이 요청을 보내는 코드를 직접 짤 때는 요청 메소드를 선택할 수 있음 자료의 본문을 요청하는 GET메소드와, 새로운 자료를 등록하는 POST 메소드가 가장 많이 쓰임 (서버가 충족시켜야 하는) 메소드의 성질Safe 요청이 서버의 상태에 영향을 미치지 않아야 함. 즉, 읽기 전용 Idempotent 여러 번 같은 요청을 해도 한 번 요청한 것과 같은 효과여야 함. 네트워크가 불안정해도 안전하게 요청을 보낼 수 있음 Cacheable (특정 조건을 만족하면) 응답을 클라이언트에 저장해두었다가 다음 번 요청 때 다시 쓸 수 있음 fetch는 일부분만 바꿀때 사용하며, put은 전체를 바꿀때 사용한다, link 반드시 이 성질을 따르도록 서버를 구현해야 하는 것은 아니나, 구현했을 때의 이점이 있으므로 이대로 구현하는 것이 좋다 URL 2,3,4는 domain영역이다. 4(TOP)는 특별한 기관에서 관리를한다. Percent Encoding URL은 ASCII 문자(128개의 영문자+특수문자+제어문자)밖에 사용하지 못하기 때문에, non-ASCII 문자를 위한 표현방법이 필요함 # Percent encoding은 non-ASCII 문자를 위한 웹 표준 인코딩 방법으로, JavaScript에 관련 기능이 포함되어 있음 1234&gt; encodeURIComponent(\"한글\")\"%ED%95%9C%EA%B8%80\"&gt; decodeURIComponent(\"%ED%95%9C%EA%B8%80\")\"한글\" 1234const encoded = encodeURIComponent('패스트캠퍼스')undefineddecodeURIComponent(encoded)\"패스트캠퍼스\" Request Target일반적인 경우 아래와 같은 구조가 사용됨 absolute path + query string + fragment id 1GET /path/to/resource?foo=bar&amp;spam=hoge#fragid HTTP/1.1 Response Status 응답의 성공, 실패 여부와 종류를 나타내며, 상태 코드 + 상태 메시지의 형태로 응답에 포함됨 1HTTP/1.1 200 OK HTTP Status Codes Status Category2xx 성공 3xx 추가 작업이 필요함 4xx 실패 - 클라이언트 책임 5xx 실패 - 서버 책임 Status Code - 2xx200 ok 성공 201 Created 자료가 성공적으로 생성됨 Status Code - 3xx301 Moved Permanently (Redirection) 자료가 완전히 다른 곳으로 이동했음 302 Found (Redirection) 자료가 일시적으로 다른 곳에 있음 304 Not Modified (Cache) 클라이언트가 이미 가지고 있던 자료가 수정되지 않았음 (그대로 사용하면 됨) Status Code - 4xx400 Bad Request 요청의 형태가 잘못되어 응답할 수 없음 403 Forbidden 요청한 자료에 접근할 권한이 없음 404 Not Found 요청한 자료가 없음 Status Code - 5xx500 Internal Server Error 요청을 처리하던 중에 예상치 못한 오류가 발생함 503 Service Unavailable 서버가 일시적으로 응답을 할 수 없음 Header 요청과 응답에 대한 추가 정보를 표현하는 데 사용됨 인증, 캐싱, 쿠키, 보안, 내용협상, 프록시 등 웹 표준에 정의된 많은 기능을 제어하는 데 사용됨 Authorization 요청의 인증 정보 User-Agent 요청 중인 클라이언트의 정보 Location 301, 302 응답에서 자료의 위치 Accept 요청이 어떤 형태의 자료를 원하는지 나타냄 Content-Type 요청 혹은 응답이 어떤 형태의 자료인지 나타냄 Content Negotiation 요청의 Accept, Accept-Language 등의 헤더를 보고 서버가 그에 맞는 형태의 자료를 응답하는 절차를 content negotiation(내용협상)이라고 함","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Http","slug":"Node-js/Http","permalink":"http://yoursite.com/categories/Node-js/Http/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Http","slug":"Http","permalink":"http://yoursite.com/tags/Http/"}]},{"title":"Node-Template-Language","slug":"node-study-template-language","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-15T14:51:19.000Z","comments":true,"path":"2017/08/29/node-study-template-language/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-template-language/","excerpt":"","text":"Node Template LanguageStatic Web Page누가 어떻게 요청하든 미리 저장되어 있던 HTML 파일을 그대로 응답 Dynamic Web Page요청한 사람과 요청한 내용에 따라 각각 다른 내용으로 편집한 HTML을 응답 Template Engine템플릿과 데이터를 결합해 문서를 생성하는 프로그램, 혹은 라이브러리템플릿을 작성할 때 사용하는 언어를 템플릿 언어라고 함 EJSEmbedded JavaScript Template # Node.js 생태계에서 가장 많이 사용되는 템플릿 엔진 문법이 단순 JavaScript 코드를 템플릿 안에서 그대로 쓸 수 있음 .ejs VSCode Extension 1234567891011121314&lt;%# index.ejs %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"message\"&gt; &lt;%= message %&gt; &lt;/div&gt; &lt;% if (showSecret) &#123; %&gt; &lt;div&gt;my secret&lt;/div&gt; // showSecret이 true면 my secret을 보여주고 false면 보여주지 말아라. &lt;% &#125; %&gt; &lt;/body&gt;&lt;/html&gt; &lt;%= title %&gt; 을 사용하여서 데이터의 title을 가진 값을 집어 넣는다. Express에서 EJS 사용하기ejs 설치1$ npm install --save ejs template engine 설정1app.set('view engine', 'ejs') res.render()123456const data = &#123; title: 'Template Language', message: 'Hello EJS!', showSecret: true&#125;res.render('index.ejs', data) Serving Static Files 템플릿 파일에서 참조할 수 있다. 변하지 않는 파일들을 넣어서 보관해둔다.1234567// `public` 폴더에 있는 파일을 `/static` 경로 아래에서 제공app.set('view engine', 'ejs')app.use('/static', express.static('public'))&lt;!-- 템플릿 파일에서 참조할 수 있음 --&gt;&lt;link rel=\"stylesheet\" href=\"/static/index.css\"&gt;&lt;script type=\"text/javascript\" src=\"/static/index.js\"&gt;&lt;/script&gt;","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Template Language","slug":"Node-js/Template-Language","permalink":"http://yoursite.com/categories/Node-js/Template-Language/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"template Language","slug":"template-Language","permalink":"http://yoursite.com/tags/template-Language/"}]},{"title":"Node-Rest-API","slug":"node-study-restapi","date":"2017-08-28T03:54:00.000Z","updated":"2017-09-14T13:23:54.000Z","comments":true,"path":"2017/08/28/node-study-restapi/","link":"","permalink":"http://yoursite.com/2017/08/28/node-study-restapi/","excerpt":"","text":"Node Rest API 실습PostMan REST API를 시험해볼 수 있는 도구 다양한 편의기능 제공 Github Rest API https://api.github.com/users/KimSejune 나의 정보를 받아올수있다.Rest API link HTTP의 전송 GET/user/repo Authorization은 Basic, Digest, Bearer 3가지로 이루어져있다. Node.js NVM을 통하여 새로운 노드를 추가적으로 설치한다. nvm 설치방법curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash 터미널을 종료한 후에 123 export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 12345# 주석: `#`으로 시작하는 명령은 bash에서 무시됩니다.# 아래 명령을 한 줄씩 차례대로 입력하세요$ nvm install 8.4$ nvm use 8.4$ nvm alias default 8.4 # nvm-windows는 필요없음 다시 돌아가는 방법 nvm ls를 하고 nvm use system을 하면 원래사용하던 node로 돌아온다. nvm use default를 통해서 nvm으로 돌아온다. 1234567891011// 여러 줄에 나눠서 입력하기&gt; function factorial2(n) &#123;... return n &lt; 1 ? 1 : n * factorial(n-1)... &#125;undefined&gt; factorial2(4)24// `.exit`를 입력하거나 `Ctrl+C`를 두 번 입력해서 나가기&gt; .exit node.js module을 사용한다. 123456789// Node.js module 사용하기&gt; const os = require('os') // 급할땐 `os = ...`undefined&gt; os.platform()'darwin'&gt; os.freemem()658300928 운영체제에 상관없이 경로를 사용할 수 있게 해준다.node.js path api Node.js로 파일 실행시키기1$ node (파일 경로) Node js의 이론 node.js 는 js의 runtime이며 chrome의 Javascript V8 engine을 사용한다. event-drive, non-blocking I/O model을 사용한다. JavaSCript runtime js는 언어 js runtime은 js를 구동하기 위해 필요한 실행 환경 프로그래머는 런타임이 제공하는 도구를 응용해서 프로그램을 개발 웹 브라우저(chrome, edge)나 Node.js도 JavaScript 런타임의 일종 Chrome이 제공하는 웹 브라우저용 런타임 Node.js가 제공하는 서버용 런타임 MongoDB가 제공하는 데이터 처리용 런타임 Photoshop이 제공하는 전용 런타임 V8 JavaScript Engine JIT(Just-In-Time) compilation Code Optimization Used in Google Chrome Node.js MongoDB … js가 V8 js engine을 통하여 속도가 대폭 향상되었다. Event-driven Programming 프로그램의 흐름이 외부 요인에 의해 일어나는 사건에 의해 결정되는 프로그래밍 양식 약속된 방식으로 이벤트 핸들러를 작성함으로써 외부 이벤트가 일어났을 때 코드를 실행 마우스 입력 키보드 입력 다른 프로그램/컴퓨터로부터의 통신 123456789101112// DOM 이벤트 핸들러 등록 (웹 브라우저)domElement.addEventListener('click', function(e) &#123; e.stopPropagation() alert('hello')&#125;)// 서버도 똑같이 합니다.// (단, 프레임워크를 쓸 때는 직접 이벤트를 다룰 일이 별로 없음)// HTTP 응답 이벤트 핸들러 등록 (Node.js)httpResponse.on('data', data =&gt; &#123; console.log(data)&#125;) node.js를 할 때 직접적으로 이벤트를 다룰 일은 별로 없다. Non-blocking I/O Blocking I/O는 스레드가 입력/출력이 완료될 때까지 기다렸다가 다음 코드를 실행 Non-blocking I/O는 스레드가 입력/출력을 기다리지 않고 코드를 계속 실행 I/O 성능 향상 &amp; 복잡한 코드 Node.js Module123456789101112131415// name.js// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음module.exports = &#123; familyName: '김', givenName: '승하', fullName: function() &#123; return this.familyName + this.givenName &#125;&#125;// calc.js// `exports`로도 참조 가능exports.add = (x, y) =&gt; x + yexports.sub = (x, y) =&gt; x - y name.js에서 저장한 module.exports의 값들을 다른 파일에서 사용할 수 있게한다. module.exports 안에는 빈객체가 들어있어서 exports. ~~ 를해도 코드가 작동한다. module를 생략해도된다. 단) 객체를 통째로 생성할때는 module을 붙여준다. 123456789101112131415&gt; const name = require('./name.js')undefined&gt; name&#123; familyName: '김', givenName: '세준', fullName: [Function: fullName] &#125;&gt; name.familyName'김'&gt; name.givenName'세준'&gt; name.fullName[Function: fullName]&gt; name.fullName()'김세준'&gt; 객체를 내가원하는 함수에다가 바로 넘길수도 있다 ReceiveObjsct(require(&#39;./name.js&#39;)) node.js는 module마다 각각의 scope가 존재한다. 그래서 전역에다가 저장이 안되고 module scope에다가 저장을 한다. 다른 module에서 사용하려면 무조건 export안에 들어있어야한다. REPL에서 불러오기 Node.js 패키지 관리 도구 + 클라우드 패키지 저장소 의존 패키지 관리 스크립트 실행 패키지 설정 NPM에 패키지 배포 Node.js 종합 작업 도구 Hello NPM1234567891011121314151617$ mkdir hello-npm$ cd hello-npm$ npm init -y$ code .// package.json&#123; \"name\": \"hello-npm\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\"&#125; package.json 패키지 정보를 담고 있는 파일 dependencies npm install --save 명령으로 설치한 패키지가 기록됨 scripts 원래 목적은 패키지 생명주기마다 자동으로 실행되는 명령을 등록하기 위함이나, 개발자 편의를 위해 자주 사용되는 명령을 등록하는 용도로 더 많이 사용됨 1234567891011$ npm install --save randomstring # node_modules에 저장됨// index.jsconst randomstring = require('randomstring')console.log(randomstring.generate())// package.json... \"scripts\": &#123; \"start\": \"node index.js\" &#125;...$ npm start // start라는 이름으로 script에 등록을 하여서 실행시킬수있다. Concurrency(동시성)Concurrency Model(동시성 모델) 프로그램이 생애 주기가 겹치는 여러 실행 과정을 통해 실행된다 하더라도 프로그램의 결과에는 영향을 미치지 않는 성질 생애 주기가 겹치는 여러 실행 과정이 자원을 공유할 때 어떻게 충돌이 생기지 않도록 할 것인가? Resources CPU Memory Network thread 코드 실행의 가장 작은 단위 프로그램은 하나 이상의 스레드로 이루어짐 CPU 코어 하나는 한 번에 하나의 스레드를 실행 thread 확인방법 1$ sysctl -n hw.ncpu // 시스템의 코어개수 운영체제 차원의 도구 Process Thread Mutex (Mutual Exclusion) 언어 차원의 도구 Python - asyncio Go - goroutine Erlang - actor JavaScript - …? 자바스크립트의 동시성(Single-Threaded Event Loop) 자바스크립트를 실행시키는 스레드가 하나 뿐임 실행 과정(보통 콜백 연쇄)의 생애 주기가 겹칠 수는 있지만 어떤 경우에도 두 자바스크립트 실행과정이 동시에 실행되는 경우는 없음 내부적으로 메시지 큐를 활용하고 있으나, 모든 처리가 자동으로 이루어짐MDN 장점 프로그래머가 동시성에 대해 신경쓸 필요가 없어짐 프로그램 작성이 쉬워짐 단점 CPU를 많이 쓰는 작업에 부적절 오래 걸리는 자바스크립트 코드가 실행되면 전체 프로그램에 영향을 미침 전략 오래 걸리는 일은 외부에 위임하고 넘어간 뒤, 나중에 결과를 받아 처리하기 Database Node.js-External libraries Web browser - webAssembly 긴 실행과정을 여러개의 함수로 쪼개서한 번의 함수 실행이 금방 끝나게 만들기 Ascynchronous JavaScript non-blocking하고 비슷한 개념이다. 코드의 작성법에 대한 개념이다. Ascynchronous Callback 함수를 호출할 떄, 콜백까지 같이 인자에 넣어서 호출하는 비동기 프로그래밍 양식 콜백에서 에러 인자를 받는 방식으로 에러 처리를 함 Node.js 내장 모듈 전체가 이 방식을 사용하도록 만들어져 있음 모든 콜백이 비동기인 것은 아님 12&gt; [1,2,3].map(x =&gt; x*x)[ 1, 4, 9 ] 계산을 기다렸다가 바로 출력한다. readFile fs라는 file에 내장되어있다. 첫번째 인자를 err로 받는다. 123456789101112// readFile.js 비동기식 코드const fs = require('fs') // Node.js 내장 모듈fs.readFile('./calc.js', 'utf8', (err, data) =&gt; &#123; console.log(data)&#125;)console.log('done!')// readFileSync.js 동기식 코드const fs = require('fs') // Node.js 내장 모듈const data = fs.readFileSync('./calc.js', 'utf8')console.log(data)console.log('done!') try, catch는 동기식에서만 에러처리를 할 수 있다. request 설치12$ # hello-npm 폴더 안에서 실행$ npm install --save request Github REST API 호출123456789101112131415161718192021222324252627282930313233// 유저 이름, 저장소, 할당된 이슈 갯수 출력하기const request = require('request')const apiUrl = 'https://api.github.com'const option = &#123; json: true, auth: &#123; 'user': 'username', 'pass': 'password', &#125;, headers: &#123; 'User-Agent': 'request' &#125;&#125;request.get(`$&#123;apiUrl&#125;/user`, option, function (error, response, body) &#123; const name = body.name if (error) console.error(error) // 콜백 안에 콜백 request.get(`$&#123;apiUrl&#125;/user/repos`, option, function (error, response, body) &#123; if (error) console.error(error) const repoNames = body.map(item =&gt; item.name) // 콜백 안에 콜백 안에 콜백 request.get(`$&#123;apiUrl&#125;/issues`, option, function (error, response, body) &#123; if (error) console.error(error) const issueNum = body.length console.log(`name: $&#123;name&#125;`) console.log('repos:') repoNames.forEach(name =&gt; &#123; console.log(name) &#125;) console.log(`num of assigned issues: $&#123;issueNum&#125;`) &#125;) &#125;)&#125;) request function이 만든사람이 error, response, body 를 parameter로 받는다. Callback Hell Callback의 Hell을 방지하기 위해서 Promise를 사용한다. Promise 비동기 작업의 결과를 담는 객체 정확히 언제가 될지 모르지만, 결국 성공 또는 실패의 상태를 갖게 됨 12345678910111213141516171819// tenSec.jsmodule.exports = function tenSec(value) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(value) &#125;, 10000) &#125;)&#125;// REPL&gt; const tenSec = require('./tenSec')&gt; const p = tenSec(1)&gt; p // 만든지 10초가 지나기 전Promise &#123; [pending], ...&gt; p // 만든지 10초가 지난 후Promise &#123; 1, ... export안에 함수를 넣어서 값이 함수로 나온다. 12345678&gt; tenSec('hello promise').then(value =&gt; &#123;... console.log(value)... &#125;)Promise &#123; // `then`은 Promise를 반환 [pending], ...&gt; // 10초 후'hello promise' then안에서 promise를 return하면 promise를 벗기고 안의 값만 들어간다. 1234567891011121314151617181920212223// chaining.jsconst tenSec = require('./tenSec')tenSec('hello promise') .then(value =&gt; &#123; console.log(value) return 1 // 위 `.then`은 값이 1인 Promise를 반환함 &#125;) .then(value =&gt; &#123; console.log(value) return tenSec('new promise') // Promise도 반환할 수 있음 &#125;) .then(value =&gt; &#123; console.log(value) &#125;) .then(() =&gt; &#123; throw new Error('error in promise') &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) .then(() =&gt; &#123; // 에러 처리 이후에도 코드 실행 가능 console.log('done') &#125;) catch 앞의 then 부분에서 에러가 발생하면 catch안의 값이 실행된다. 맨 위의 then에서 에러가나면 바로 catch로 넘어간다. promise.all([…]) 배열안의 넘기는 값들이 모두 성공해야지 성공한다. promise.rase([…]) 배열안의 값중에서 먼저 성공한것을 나타낸다. readFile - promise node.js v8부터 새로들어온 함수이다. 1234567891011// readfilePromise.jsconst &#123;promisify&#125; = require('util') // Node.js 8.0.0부터 추가됨const fs = require('fs')const readFile = promisify(fs.readFile)readFile('./calc.js', 'utf8') .then(data =&gt; &#123; console.log(data) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 파일을 다읽으면 반환하는 promise파일을 반환한다. Promise의 특징 이미 resolve 된 Promise에도 콜백을 실행할 수 있음 12&gt; const resolved = Promise.resolve(1)&gt; resolved.then(v =&gt; console.log(v)) .then에 넘겨진 콜백은 무조건 다음 루프에 실행됨 12345678&gt; (function() &#123;... Promise.resolve(1).then(v =&gt; console.log(v))... console.log(&apos;done!&apos;)... &#125;)()/* 출력:done!1*/ Promise.all1234567891011121314151617181920212223242526272829// npm install --save request-promiseconst rp = require('request-promise')const apiUrl = 'https://api.github.com'const option = &#123; json: true, auth: &#123; 'user': 'username', 'pass': 'password', &#125;, headers: &#123; 'User-Agent': 'request' &#125;&#125;const userPromise = rp.get(`$&#123;apiUrl&#125;/user`, option)const reposPromise = rp.get(`$&#123;apiUrl&#125;/user/repos`, option)const issuesPromise = rp.get(`$&#123;apiUrl&#125;/issues`, option)// 배열 내의 모든 Promise 객체가 완료되었을 때// resolve 되는 Promise를 만든다.Promise.all([userPromise, reposPromise, issuesPromise]) .then(([user, repos, issues]) =&gt; &#123; console.log(`name: $&#123;user.name&#125;`) console.log('repos:') repos.forEach(repo =&gt; &#123; console.log(repo.name) &#125;) console.log(`num of assigned issues: $&#123;issues.length&#125;`) &#125;) axiosfetch api fetch api, axios를 통하여 Ajax통신을 promise를 통하여 통신을 할 수 있게한다. Async/Await javascript의 문법을 바꾸어버렸다. 비동기 코드를 동기식 코드처럼 편하게 짤 수 있게 만든 것이다. async function은 무조건 promise를 반환하며 await가 완료될때 까지 기다린다.12345678910const tenSec = require('./tenSec')async function resolveAfterTenSec() &#123; await tenSec() return 1&#125;resolveAfterTenSec().then(value =&gt; &#123; console.log(value)&#125;) ES2017에서 도입되어, 비동기식 코드를 동기식 코드처럼 쓸 수 있는 문법 제공 Chrome 55, Node.js 8.0.0 부터 사용가능 async function 안에서 반환된 값은 최종적으로 Promise 객체로 변환되어 반환된다. async function 안에서 쓸 수 있는 await 키워드는 현재 함수를 중단시키고 Promise 객체가 충족될 때까지 기다리지만, 스레드를 block 하지 않는다. 에러 처리는 동기식 코드처럼 try, catch 블록을 통해서 한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Rest-API","slug":"Node-js/Rest-API","permalink":"http://yoursite.com/categories/Node-js/Rest-API/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"RestAPI","slug":"RestAPI","permalink":"http://yoursite.com/tags/RestAPI/"}]}]}