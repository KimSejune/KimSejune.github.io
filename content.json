{"meta":{"title":"KimSejune Start Study","subtitle":"Node.js JavaScript","description":null,"author":"Sejune kim","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"React Router","slug":"Reactjs-study-router","date":"2017-12-14T03:54:00.000Z","updated":"2017-12-14T12:24:31.000Z","comments":true,"path":"2017/12/14/Reactjs-study-router/","link":"","permalink":"http://yoursite.com/2017/12/14/Reactjs-study-router/","excerpt":"","text":"React Router폴더 구조 설치방법기본 세팅 123456789101112// React typeScript Setting$ create-react-app react-router --scripts-version=react-scripts-ts// React router dom$ yarn add react-router-dom// typescript여서 설치를 해줘야한다.$ yarn add @types/react-router-dom// Semantic Ui $ yarn add semantic-ui-react$ yarn add semantic-ui-css 명령어 BrowserRouter =&gt; router로 최상위를 감싼다. Link =&gt; 누를 경우 그 경로로 이동시킨다. (to 사용) Route =&gt; path를 설정해준다. 3가지 전부 react-router-dom 에 존재한다. tsx prefix의 사용 =&gt; jsx라는 문법으로 랜더링을 하기에 typescript라서 tsx를 사용한다. 1234567891011121314151617181920212223242526// App.tsximport * as React from &apos;react&apos;;import MenuComponent from &apos;./components/Menu&apos;import &apos;semantic-ui-css/semantic.min.css&apos;;import &#123; BrowserRouter as Router, Route &#125; from &apos;react-router-dom&apos;;import Home from &apos;./pages/Home&apos;;import About from &apos;./pages/About&apos;;// Topics 폴더의 하위를 가져와야하기 때문이다.import Topics from &apos;./pages/Topics/&apos;;class App extends React.Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;MenuComponent /&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;/About&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;/Topics&quot; component=&#123;Topics&#125; /&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default App; BrowserRouter as인 router로 최상단을 감싼다음에 div안에 MenuComponent 와 Route들을 설정해준다. BrowserRouter안에는 1개의 child만 가능함으로 div로 묶어서 표시를 해줘야한다. 1234567891011121314151617181920212223242526272829303132333435// components/Menu.tsximport * as React from &apos;react&apos;;// &#123;Menu&#125;를 사용함으로써 semantic에서 Menu를 사용한다는 의미이다.import &#123; Menu &#125; from &apos;semantic-ui-react&apos;;// click시에 이동하게 하는 역할을 한다.import &#123; Link &#125; from &apos;react-router-dom&apos;;class MenuComponent extends React.Component &#123; // JSX.Element는 반환값의 type이다. render(): JSX.Element &#123; return ( &lt;Menu&gt; &lt;Link to=&quot;/About&quot;&gt; &lt;Menu.Item name=&quot;About&quot;&gt; About &lt;/Menu.Item&gt; &lt;/Link&gt; &lt;Link to=&quot;/&quot;&gt; &lt;Menu.Item name=&quot;Home&quot;&gt; Home &lt;/Menu.Item&gt; &lt;/Link&gt; &lt;Link to=&quot;/Topics&quot;&gt; &lt;Menu.Item name=&quot;Topics&quot;&gt; Topics &lt;/Menu.Item&gt; &lt;/Link&gt; &lt;/Menu&gt; ); &#125;&#125;export default MenuComponent; Menu.tsx에서 react-router-dom에서 Link tag를 사용하여서 원하는 url로 이동시킨다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Topics/index.tsximport * as React from &apos;react&apos;;import &#123; Menu &#125; from &apos;semantic-ui-react&apos;;import &#123; Link &#125; from &apos;react-router-dom&apos;;class Topics extends React.Component &#123; render() &#123; return ( &lt;Menu&gt; &lt;Menu.Item&gt;Topics&lt;/Menu.Item&gt; &lt;Link to=&quot;/A&quot;&gt; &lt;Menu.Item name=&quot;A&quot; /&gt; &lt;/Link&gt; &lt;Link to=&quot;/B&quot;&gt; &lt;Menu.Item name=&quot;B&quot; /&gt; &lt;/Link&gt; &lt;/Menu&gt; ); &#125;&#125;export default Topics;// Topics/A.tsximport * as React from &apos;react&apos;;class A extends React.Component &#123; render() &#123; return ( &lt;div&gt; 여긴 A &lt;/div&gt; ); &#125;&#125;export default A;// Topics/B.tsximport * as React from &apos;react&apos;;class B extends React.Component &#123; render() &#123; return ( &lt;div&gt; 여긴 B &lt;/div&gt; ); &#125;&#125;export default B; component로 값을 분리하여 url를 통하여 값을 연결하는 과정을 구현하였다. 아직 topics의 depth영역은 구현하지 못하였다.","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"},{"name":"Router","slug":"React/Router","permalink":"http://yoursite.com/categories/React/Router/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Router","slug":"Router","permalink":"http://yoursite.com/tags/Router/"}]},{"title":"Algorithm 2016년의 원하는 요일구하기","slug":"algorithm-study-getDayName","date":"2017-12-12T03:54:00.000Z","updated":"2017-12-12T12:53:14.000Z","comments":true,"path":"2017/12/12/algorithm-study-getDayName/","link":"","permalink":"http://yoursite.com/2017/12/12/algorithm-study-getDayName/","excerpt":"","text":"원하는 요일구하기 2016년의 원하는 요일구하기 고려사항 Month의 자리수가 2자리가 아닌경우와 day의 자리수가 2자리가 아닌경우를 고려해서 0을 붙여줘야한다. DateFormat을 yyyyMMdd로 맞춰줘야 Year Month Day로 표현된다. Calender함수를 사용하여서 값을 구한다. 12345678910111213141516171819202122232425262728293031323334353637383940package getDayName;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;public class GetDayName &#123; public String getDayName(int a, int b) throws Exception &#123; String answer = \"\"; String[] week = &#123;\"SUN\",\"MON\",\"TUE\",\"WED\",\"THU\",\"FRI\",\"SAT\"&#125;; String sour = \"2016\"; if(a &lt; 10 &amp;&amp; b &lt; 10) &#123; sour += \"0\"+a+\"\"+\"0\"+b; &#125;else if (a &lt; 10)&#123; sour += \"0\"+a+\"\"+b; &#125;else if (b &lt; 10) &#123; sour += a+\"\"+\"0\"+b; &#125;else &#123; sour += a+\"\"+b; &#125; System.out.println(sour); SimpleDateFormat format = new SimpleDateFormat(\"yyyyMMdd\"); Date date = format.parse(sour); Calendar cal = Calendar.getInstance(); cal.setTime(date); int num = cal.get(Calendar.DAY_OF_WEEK)-1; answer = week[num]; return answer; &#125; public static void main(String[] args) throws Exception &#123; GetDayName gdn = new GetDayName(); int a = 1, b = 1; System.out.println(gdn.getDayName(a,b)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"level2","slug":"Algorithm/level2","permalink":"http://yoursite.com/categories/Algorithm/level2/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"2016년의 원하는 요일구하기","slug":"2016년의-원하는-요일구하기","permalink":"http://yoursite.com/tags/2016년의-원하는-요일구하기/"}]},{"title":"Algorithm 최소값 만들기","slug":"algorithm-study-getminsum","date":"2017-12-11T03:54:00.000Z","updated":"2017-12-11T13:02:58.000Z","comments":true,"path":"2017/12/11/algorithm-study-getminsum/","link":"","permalink":"http://yoursite.com/2017/12/11/algorithm-study-getminsum/","excerpt":"","text":"최소값 만들기 최솟값 만들기는 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱한 값을 누적하여 더합니다. A, B의 길이는 같습니다. 접근방법 두 배열의 곱이 최소가 될려면 정렬을 해야한다 곱을 하지않은 A배열의 가장 작은 수와 B배열의 가장 큰 수를 길이만큼 반복하여 곱한다. 곱한값들을 answer에다가 합친다. 123456789101112131415161718192021222324252627282930package getMinSum;import java.util.Arrays;public class GetMinSum &#123; public int getMinSum(int[] A, int[] B) &#123; // TODO Auto-generated method stub int answer = 0; Arrays.sort(A); Arrays.sort(B); int i = 0; while(i &lt; A.length) &#123; answer += A[i] * B[B.length-i-1]; i++; &#125; return answer; &#125; public static void main(String[] args) &#123; GetMinSum gms = new GetMinSum(); int[] A = &#123;1,5,2&#125;; int[] B = &#123;2,5,3&#125;; System.out.println(gms.getMinSum(A,B)); &#125; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"level2","slug":"Algorithm/level2","permalink":"http://yoursite.com/categories/Algorithm/level2/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"최소값 만들기","slug":"최소값-만들기","permalink":"http://yoursite.com/tags/최소값-만들기/"}]},{"title":"React Syntax","slug":"Reactjs-study-syntax","date":"2017-12-11T03:54:00.000Z","updated":"2017-12-11T08:35:28.000Z","comments":true,"path":"2017/12/11/Reactjs-study-syntax/","link":"","permalink":"http://yoursite.com/2017/12/11/Reactjs-study-syntax/","excerpt":"","text":"React Syntaxcreate-React-app 설치법12345678$ npm install create-react-app -g// 대문자를 사용하면 안된다!!$ create-react-app [ProjectName]// 시작할때 2개중 하나를 사용하면된다.$ yarn start $ npm start 12345678910// index.jsimport React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import registerServiceWorker from './registerServiceWorker';// id가 root인 곳에 App.js이라는 component를 연결한다.ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));registerServiceWorker(); ReactDOM을 통하여 root라는 id를 가져오고 App으로 import한 App.js의 component를 연결한다. 123456789101112131415161718192021import React, &#123; Component &#125; from 'react';import logo from './logo.svg';import './App.css';class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;h1 className=\"App-title\"&gt;Welcome to React&lt;/h1&gt; &lt;/header&gt; &lt;p className=\"App-intro\"&gt; To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;export default App; Component 만들기component : 페이지에서 나누어지는 덩어리로 표현가능하다. state와 props가 component의 데이터를 관장한다. render를 다시 해준다.props : 외부에서 값을 component로 넣는다. (read only)state : component의 상태를 나타낸다. (read only) stateless component: component 내에서 상태관리를 할 필요가 없을 떄(function) class 로 만들어지는 component 12345678910111213141516// index.jsimport React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import registerServiceWorker from './registerServiceWorker';const myage = 25const gender = \"남자\"// id가 root인 곳에 App.js이라는 component를 연결한다.ReactDOM.render(&lt;App age=&#123;myage&#125; gender=&#123;gender&#125;&gt; 나는 props의 자식!! &lt;/App&gt;, document.getElementById('root'));// 아래처럼 사용가능하다.// ReactDOM.render(&lt;App age=&#123;myage&#125; gender=&#123;gender&#125;&gt; &lt;Her&gt; &lt;/Her&gt; &lt;/App&gt;, document.getElementById('root'));registerServiceWorker(); return 안에는 div 1개만 가능하다. 1234567891011121314151617181920212223242526272829// App.jsimport React, &#123; Component &#125; from 'react';import logo from './logo.svg';import './App.css';import Her from './Her';class App extends Component &#123; constructor(props)&#123; super(props); this.state = &#123; name:'KimSejune' &#125; &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.name&#125; &#123;this.props.age&#125; &#123;this.props.gender&#125; &#123;this.props.children&#125; &lt;Her&gt;&lt;/Her&gt; &lt;/div&gt; ); &#125;&#125;export default App; 123456789//Her.jsimport React, &#123; Component &#125; from 'react';export default function Her() &#123; return( &lt;h2&gt;stateless&lt;/h2&gt; )&#125;","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"},{"name":"Syntax","slug":"React/Syntax","permalink":"http://yoursite.com/categories/React/Syntax/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Syntax","slug":"Syntax","permalink":"http://yoursite.com/tags/Syntax/"}]},{"title":"Algorithm 하샤드수","slug":"algorithm-study-HarshadNumber","date":"2017-12-10T03:54:00.000Z","updated":"2017-12-10T12:45:25.000Z","comments":true,"path":"2017/12/10/algorithm-study-HarshadNumber/","link":"","permalink":"http://yoursite.com/2017/12/10/algorithm-study-HarshadNumber/","excerpt":"","text":"하샤드수 입력된 값의 자리수의 합으로 나눴을 경우 나누어지는 경우를 하샤드수라고 한다. 입력된 값의 모든 자리수를 더해서 나눴을때 나누어 떨어지면 true, 아니면 false를 반환하라. 12345678910111213141516171819202122package harshadnumber;public class HarshadNumber &#123; public boolean isHarshad(int num) &#123; int answer = num; int sum = 0; boolean flag = true; while(num &gt; 0) &#123; sum += num%10; num = num/10; &#125; // 3항연산자를 사용하여서 조금 더 간편하게 사용. flag = answer%sum == 0 ? true : false; return flag; &#125; public static void main(String[] args) &#123; HarshadNumber hm = new HarshadNumber(); System.out.println(hm.isHarshad(18)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"level2","slug":"Algorithm/level2","permalink":"http://yoursite.com/categories/Algorithm/level2/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"하샤드수","slug":"하샤드수","permalink":"http://yoursite.com/tags/하샤드수/"}]},{"title":"Algorithm 소수찾기","slug":"algorithm-study-NumOfPrime","date":"2017-12-10T03:54:00.000Z","updated":"2017-12-10T12:55:51.000Z","comments":true,"path":"2017/12/10/algorithm-study-NumOfPrime/","link":"","permalink":"http://yoursite.com/2017/12/10/algorithm-study-NumOfPrime/","excerpt":"","text":"소수찾기 입력된 값이 n일경우 1~n까지중 소수의 개수를 반환하여라 10이 들어온다면 2, 3, 5, 7 4개가 존재함으로 4를 반환 12345678910111213141516171819202122232425262728293031323334353637package numberofprime;public class NumOfPrime &#123; public static boolean isPrime(int n) &#123; boolean flag = true; int count = 0; int i = 1; while(n &gt;= i) &#123; if(n%i == 0) &#123; count++; &#125; i++; &#125; flag = (count == 2) ? true : false; return flag; &#125; int numberOfPrime(int n) &#123; int result = 0; // 함수를 완성하세요. while(n &gt; 0) &#123; if(isPrime(n)) &#123; result++; &#125; n--; &#125; return result; &#125; public static void main(String[] args) &#123; NumOfPrime prime = new NumOfPrime(); System.out.println( prime.numberOfPrime(10) ); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"level2","slug":"Algorithm/level2","permalink":"http://yoursite.com/categories/Algorithm/level2/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"소수찾기","slug":"소수찾기","permalink":"http://yoursite.com/tags/소수찾기/"}]},{"title":"Algorithm 나누어 떨어지는 숫자 배열","slug":"algorithm-study-divisible","date":"2017-12-07T03:54:00.000Z","updated":"2017-12-07T12:58:39.000Z","comments":true,"path":"2017/12/07/algorithm-study-divisible/","link":"","permalink":"http://yoursite.com/2017/12/07/algorithm-study-divisible/","excerpt":"","text":"나누어 떨어지는 숫자 배열 나누어 떨어지는 숫자 배열을 구하여라. 입력된 문자중 divisor로 나누어지는 값만을 배열로 반환하여라. 1234567891011121314151617181920212223242526272829303132333435package divisible;import java.util.Arrays;public class Divisible &#123; public int[] divisible(int[] array, int divisor) &#123; // ret에 array에 포함된 정수중, divisor로 나누어 떨어지는 숫자를 순서대로 넣으세요. int div = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] % divisor == 0) &#123; div++; &#125; &#125; int[] ret = new int[div]; int j = 0; // ret index 번호를 나타낸다. for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] % divisor == 0) &#123; ret[j] = array[i]; j++; &#125; &#125; return ret; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; Divisible div = new Divisible(); int[] array = &#123; 5, 9, 7, 10 &#125;; System.out.println(Arrays.toString(div.divisible(array, 5))); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"level1","slug":"Algorithm/level1","permalink":"http://yoursite.com/categories/Algorithm/level1/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"나누어 떨어지는 숫자 배열","slug":"나누어-떨어지는-숫자-배열","permalink":"http://yoursite.com/tags/나누어-떨어지는-숫자-배열/"}]},{"title":"Algorithm 최대값 최소값 찾기","slug":"algorithm-study-maxmin","date":"2017-12-03T03:54:00.000Z","updated":"2017-12-03T09:09:16.000Z","comments":true,"path":"2017/12/03/algorithm-study-maxmin/","link":"","permalink":"http://yoursite.com/2017/12/03/algorithm-study-maxmin/","excerpt":"","text":"최대값 최소값 찾기 입력된 배열에서 최대값 최소값 찾아라. 입력된 배열에서 값을 비교하여 최대값과 최소값을 찾아라. 방법1. 조건문을 통한 비교 123456789101112131415161718192021222324252627282930package getMinMaxString;public class GetMinMaxString &#123; public String getMinMaxString(String str) &#123; String[] array = str.split(\" \"); int max = Integer.parseInt(array[0]); int min = Integer.parseInt(array[0]); if(array.length != 0) &#123; for (int i = 0; i &lt; array.length; i++) &#123; if(max &lt; Integer.parseInt(array[i])) &#123; max = Integer.parseInt(array[i]); &#125; if(min &gt; Integer.parseInt(array[i])) &#123; min = Integer.parseInt(array[i]); &#125; &#125; &#125; return Integer.toString(min) + \" \" +Integer.toString(max); &#125; public static void main(String[] args) &#123; String str = \"-13 -2 -4 16\"; GetMinMaxString minMax = new GetMinMaxString(); // 아래는 테스트로 출력해 보기 위한 코드입니다. System.out.println(\"최대값과 최소값은?\" + minMax.getMinMaxString(str)); &#125;&#125; 방법2. Math method를 사용 개인적으로 이방법을 선호합니다 12345678910111213141516171819202122232425public class GetMinMaxString &#123; public String getMinMaxString(String str) &#123; String[] array = str.split(\" \"); int max = Integer.parseInt(array[0]); int min = Integer.parseInt(array[0]); if(array.length != 0) &#123; for (int i = 0; i &lt; array.length; i++) &#123; max = Math.max(max, Integer.parseInt(array[i])); min = Math.min(min, Integer.parseInt(array[i])); &#125; &#125; return Integer.toString(min) + \" \" +Integer.toString(max); &#125; public static void main(String[] args) &#123; String str = \"-13 -2 -4 16\"; GetMinMaxString minMax = new GetMinMaxString(); // 아래는 테스트로 출력해 보기 위한 코드입니다. System.out.println(\"최대값과 최소값은?\" + minMax.getMinMaxString(str)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"level1","slug":"Algorithm/level1","permalink":"http://yoursite.com/categories/Algorithm/level1/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"최대값 최소값 찾기","slug":"최대값-최소값-찾기","permalink":"http://yoursite.com/tags/최대값-최소값-찾기/"}]},{"title":"Algorithm 문자열 내림차순으로 배치하기","slug":"algorithm-study-reverseStr","date":"2017-12-03T03:54:00.000Z","updated":"2017-12-03T12:17:05.000Z","comments":true,"path":"2017/12/03/algorithm-study-reverseStr/","link":"","permalink":"http://yoursite.com/2017/12/03/algorithm-study-reverseStr/","excerpt":"","text":"문자열 내림차순으로 배치하기 입력된 문자열 내림차순으로 배치하여라. 입력된 문자를 큰것부터 작은 순으로 정렬해 새로운 String을 리턴해주세요. 방법1. List로 변경한 후에 reverse하기 12345678910111213141516171819202122232425262728293031package reversestr;import java.util.Arrays;import java.util.Collections;import java.util.List;public class ReverseStr &#123; public String reverseStr(String str) &#123; String answer = \"\"; String[] arr = str.split(\"\"); // 방법 1. Arrays.sort(arr); List&lt;String&gt; inarr = Arrays.asList(arr); Collections.reverse(inarr); arr = inarr.toArray(new String[inarr.size()]); for (int i = 0; i &lt; arr.length; i++) &#123; answer += arr[i]; &#125; return answer; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; ReverseStr rs = new ReverseStr(); System.out.println(rs.reverseStr(\"Zbcdefg\")); &#125;&#125; 방법2. 정렬할 때 한번에 reverse하기 1234567891011121314151617181920212223242526272829package reversestr;import java.util.Arrays;import java.util.Collections;import java.util.List;public class ReverseStr &#123; public String reverseStr(String str) &#123; String answer = \"\"; String[] arr = str.split(\"\"); // 방법 2. 정렬을 하고 역순으로 배치를 하라. Arrays.sort(arr, Collections.reverseOrder()); for (int i = 0; i &lt; arr.length; i++) &#123; answer += arr[i]; &#125; return answer; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; ReverseStr rs = new ReverseStr(); System.out.println(rs.reverseStr(\"Zbcdefg\")); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"level1","slug":"Algorithm/level1","permalink":"http://yoursite.com/categories/Algorithm/level1/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"문자열 내림차순으로 배치하기","slug":"문자열-내림차순으로-배치하기","permalink":"http://yoursite.com/tags/문자열-내림차순으로-배치하기/"}]},{"title":"Algorithm 배열의 합","slug":"algorithm-study-summatrix","date":"2017-12-01T03:54:00.000Z","updated":"2017-12-01T05:47:29.000Z","comments":true,"path":"2017/12/01/algorithm-study-summatrix/","link":"","permalink":"http://yoursite.com/2017/12/01/algorithm-study-summatrix/","excerpt":"","text":"배열의 합 배열의 합을 구하여라 배열은 각자 같은 위치의 값끼리 더한다. 어떤 배열을 입력하여도 적용되게만들어라. 1234567891011121314151617181920212223242526272829package summatrix;public class SumMatrix &#123; int[][] sumMatrix(int[][] A, int[][] B) &#123; int[][] answer = new int[A.length][A[0].length]; for (int i = 0; i &lt; answer.length; i++) &#123; for(int j = 0; j &lt; answer[i].length; j++) &#123; answer[i][j] = A[i][j] + B[i][j]; &#125; &#125; return answer; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; SumMatrix c = new SumMatrix(); int[][] A = &#123; &#123; 1, 2 &#125;, &#123; 2, 3 &#125; &#125;; int[][] B = &#123; &#123; 3, 4 &#125;, &#123; 5, 6 &#125; &#125;; int[][] answer = c.sumMatrix(A, B); if (answer[0][0] == 4 &amp;&amp; answer[0][1] == 6 &amp;&amp; answer[1][0] == 7 &amp;&amp; answer[1][1] == 9) &#123; System.out.println(\"맞았습니다. 제출을 눌러 보세요\"); &#125; else &#123; System.out.println(\"틀렸습니다. 수정하는게 좋겠어요\"); &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"level1","slug":"Algorithm/level1","permalink":"http://yoursite.com/categories/Algorithm/level1/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"SumMatrix","slug":"SumMatrix","permalink":"http://yoursite.com/tags/SumMatrix/"}]},{"title":"Algorithm 가운데 글자 구하기","slug":"algorithm-study-getmiddle","date":"2017-12-01T03:54:00.000Z","updated":"2017-12-01T05:44:48.000Z","comments":true,"path":"2017/12/01/algorithm-study-getmiddle/","link":"","permalink":"http://yoursite.com/2017/12/01/algorithm-study-getmiddle/","excerpt":"","text":"가운데 글자 구하기 가운데 글자를 구하라 입력받은 글자의 가운데 글자를 구하여라 만약 짝수면 가운데 한자리와 그 바로 뒤자리까지 2자리를, 홀수면 가운데 한자리만 구하여라 12345678910111213141516171819package getmiddle;public class StringExercise &#123; String getMiddle(String word) &#123; if(word.length() % 2 == 0) &#123; word = word.substring((word.length()/2)-1, word.length()/2+1); &#125;else &#123; word = word.substring(word.length()/2, (word.length()/2)+1); &#125; return word; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; StringExercise se = new StringExercise(); System.out.println(se.getMiddle(\"poweer\")); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"level1","slug":"Algorithm/level1","permalink":"http://yoursite.com/categories/Algorithm/level1/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"getMiddle","slug":"getMiddle","permalink":"http://yoursite.com/tags/getMiddle/"}]},{"title":"Algorithm 서울에서 김서방 찾기","slug":"algorithm-study-findkim","date":"2017-12-01T03:54:00.000Z","updated":"2017-12-01T06:03:35.000Z","comments":true,"path":"2017/12/01/algorithm-study-findkim/","link":"","permalink":"http://yoursite.com/2017/12/01/algorithm-study-findkim/","excerpt":"","text":"서울에서 김서방 찾기 서울에서 김서방 찾아라 입력된 배열에서 “Kim”이 어디에 존재하는지 찾아라. 어디 = index를 나타낸다. 12345678910111213141516171819202122package findkim;import java.util.Arrays;public class FindKim &#123; public String findKim(String[] seoul) &#123; // x에 김서방의 위치를 저장하세요. int x = 0; x = Arrays.asList(seoul).indexOf(\"Kim\"); return \"김서방은 \" + x + \"에 있다\"; &#125; // 실행을 위한 테스트코드입니다. public static void main(String[] args) &#123; FindKim kim = new FindKim(); String[] names = &#123; \"Queen\", \"Tod\", \"Kim\" &#125;; System.out.println(kim.findKim(names)); &#125;&#125; Arrays.asList()는 Arrays의 지정된 배열을 기본으로하는 고정 사이즈의리스트를 돌려줍니다.java.util.ArrayList 와는 다른 클래스이다. get(), set(), contains() method는 존재하지만 값을 추가할 수는 없다. ArrayList로 변환하고 싶을떄 1ArrayList&lt;String&gt; arrList = new ArrayList&lt;String&gt;(Arrays.asList(arr));","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"level1","slug":"Algorithm/level1","permalink":"http://yoursite.com/categories/Algorithm/level1/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"서울에서 김서방 찾기","slug":"서울에서-김서방-찾기","permalink":"http://yoursite.com/tags/서울에서-김서방-찾기/"}]},{"title":"Algorithm 최대공약수와 최소공배수","slug":"algorithm-study-gcdlcm","date":"2017-11-30T03:54:00.000Z","updated":"2017-12-01T05:37:33.000Z","comments":true,"path":"2017/11/30/algorithm-study-gcdlcm/","link":"","permalink":"http://yoursite.com/2017/11/30/algorithm-study-gcdlcm/","excerpt":"","text":"최대공약수 최소공배수 최대공약수 최소공배수를 구하기 위한 방법 최대공약수는 입력받은 값의 약수중 최대값을 찾는 것임으로 먼저 입력받은 값의 약수를 먼저찾는다. 약수중 같은 값을 찾고 그중 가장 큰값을 answer[0]에다가 저장한다. 최소공배수는 입력받은 a와 b를 곱한뒤에 최대공약수로 나눈다음에 answer[1]에다가 저장한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Arrays;class TryHelloWorld &#123; public int[] gcdlcm(int a, int b) &#123; int[] answer = new int[2]; int[] alist = new int[a]; int[] blist = new int[b]; answer[0] = 0; for(int i = 1; i &lt;=a; i++) &#123; if(a%i == 0 ) &#123; alist[i-1] = i; System.out.println(\"alist\" + alist[i-1]); &#125; &#125; for(int i = 1; i &lt;=b; i++) &#123; if(b%i == 0 ) &#123; blist[i-1] = i; System.out.println(\"blist\" + blist[i-1]); &#125; &#125; for(int i = 0; i&lt;alist.length; i++) &#123; Arrays.sort(blist); int idx = Arrays.binarySearch(blist, alist[i]); if(idx&gt;=0) &#123; if(answer[0] &lt;= alist[i]) &#123; answer[0] = alist[i]; &#125; &#125; &#125; answer[1] = (a*b)/answer[0]; return answer; &#125; // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args) &#123; TryHelloWorld c = new TryHelloWorld(); System.out.println(Arrays.toString(c.gcdlcm(3, 12))); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"level1","slug":"Algorithm/level1","permalink":"http://yoursite.com/categories/Algorithm/level1/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"최대공약수 최소공배수","slug":"최대공약수-최소공배수","permalink":"http://yoursite.com/tags/최대공약수-최소공배수/"}]},{"title":"Algorithm Dynamic Fibonacci","slug":"algorithm-study-fibo","date":"2017-11-30T03:54:00.000Z","updated":"2017-12-01T05:37:30.000Z","comments":true,"path":"2017/11/30/algorithm-study-fibo/","link":"","permalink":"http://yoursite.com/2017/11/30/algorithm-study-fibo/","excerpt":"","text":"FibonacciFibonacci를 구현하다보면 재귀를 사용하는 경우가 흔한 경우이다 하지만 재귀를 사용하면 중복되는 코드가 많이 발생하다보니 코드 수행시간이 길어진다.이를 해결하기 위한 방법이 Dynamic Fibonacci이다. 재귀 Fibonacci12345678910111213public int fibonacci(int num) &#123; int first = 0; int second = 1; int sum = 0; if(num &lt;=2) &#123; sum = first + second; &#125;else &#123; sum = fibonacci(num-1) + fibo(num-2); &#125; return sum;&#125; Dynamic FibonacciDynamic Fibonacci는 값을 지속적으로 저장하면서 코드를 실행한다 그러기 때문에 속도가 재귀보다 우수하다. 12345678910111213141516171819202122232425262728public class intfibonacci &#123; // long type을 사용하는 것이 중요하다. public long fibonacci(int num) &#123; int answer = 0; int[] arr = new int[num + 1]; arr[0] = 0; arr[1] = 1; if (num &lt;= 2) &#123; answer = 1; &#125; else &#123; for (int i = 2; i &lt;= num; i++) &#123; arr[i] = arr[i-1] + arr[i-2]; &#125; &#125; answer = arr[num]; return answer; &#125; public static void main(String[] args) &#123; intfibonacci c = new intfibonacci(); for (int i = 2; i &lt;= 70; i++) &#123; System.out.println(i + \" \" + c.fibonacci(i)); &#125; &#125;&#125; 하지만 여기서 또다른 issue사항이 발생한다 바로 int로 값을 표현하였기 때문에 표현할 수 있는 문자열의 한계가 존재한다 그래서 47번째 fibonacci부터 -값이 저장이된다. 값을 해결하기위하여 long type을 사용합니다. int 표현범위 -2147483648 ~ 2147483647 long 표현범위 -9223372036854775808 ~ 9223372036854775807 12345678910111213141516171819202122232425262728public class fiboexample &#123; // long type을 사용하는 것이 중요하다. public long fibonacci(int num) &#123; long answer = 0; long[] arr = new long[num + 1]; arr[0] = 0; arr[1] = 1; if (num &lt;= 2) &#123; answer = 1; &#125; else &#123; for (int i = 2; i &lt;= num; i++) &#123; arr[i] = arr[i-1] + arr[i-2]; &#125; &#125; answer = arr[num]; return answer; &#125; public static void main(String[] args) &#123; fiboexample c = new fiboexample(); for (int i = 2; i &lt;= 65; i++) &#123; System.out.println(i + \" \" + c.fibonacci(i)); &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"},{"name":"level1","slug":"Algorithm/level1","permalink":"http://yoursite.com/categories/Algorithm/level1/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"Fibonacci","slug":"Fibonacci","permalink":"http://yoursite.com/tags/Fibonacci/"}]},{"title":"Node Developer Connect","slug":"node-developer-connect","date":"2017-11-09T03:54:00.000Z","updated":"2017-11-30T12:20:30.000Z","comments":true,"path":"2017/11/09/node-developer-connect/","link":"","permalink":"http://yoursite.com/2017/11/09/node-developer-connect/","excerpt":"","text":"Play Node 발표내용 정리 GraphQL + Relay + Serverless필요한 리소스만 요청하고 사용하는 API 만들기장바구니 개발시 Component : cart, proudectlist, productdata 등등단점 : 모바일에서 네트워크 콜을 4가지를 해야하는데 이것이 네트워크가 안좋을때 받기가 힘들다.해결법 : queryString? =&gt; 장기적 개발이 힘들다.해결법 : custom된 endpoint를 생성한다 기기별로(모바일, 웹 등등) =&gt; 여러개의 엔드포인트를 만들기에는 문제가 있다.해결법 : BFF(soundcloud) 모바일을 위해 최적화된 endpoint를 만들어준다. =&gt; 고객마다 needs가 달라서 어렵다. BFF? 프론트엔드를 중심으로 백엔드가 들어간다. 최고의 해결법 : GraphQL =&gt; A Query Language for API API를 위한 질의 언어 12345678910111213141516171819202122232425// 요청&#123; me &#123; name: , company: &#125;&#125;// 응답&#123; me &#123; name: \"김세준\", company: \"학생\" &#125;&#125;// 해당유저의 정보만 요청가능하다&#123; &#123; user(id=1) &#123; name: \"김세준\", company: \"학생\" &#125; &#125;&#125; Post /graphql을 통해 여러개의 component를 1개로 보내준다. GraphQL은 강력한 TypeSystem으로 적용된다. 1234567891011121314151617181920// 형태type Query &#123; cart: Cart&#125;type Cart &#123; products: [product] ! shippingAddess: String!&#125;type Product &#123; imageUrl: String!, description: String!&#125;// 요청&#123; &#123; cart &#125;&#125; Mutation 기존의 것을 변형해서 가져온다. Mutation 1234567891011mutation &#123; createProduct(&#123; input: &#123; desciption: \"clothes\" &#125; &#125;)&#125;&#123; price &#123; product &#125;&#125; =&gt; client가 원하는 데이터 GraphQL의 최대의 강점은 Client가 원하는 값을 딱 그정도만 준다. 단 서버단에서 미리 맞춰야한다. Relay : passing 역할을 합니다. Client가 요청한 데이터를 중간에 Relay가 가로챈다 Relay의 요구사항특정한 id에 대해 요청을 하고 그에대한 응답을 해야합니다. ServerlessFunctions이 핵심 기능이다. input은 event이다. 서버관리의 모든걸 클라우드에게 맡기자 Event가 발생할때만 사용하기 때문에 Price가 적어진다. =&gt; 실행시간, 메모리 소비량, 요청 횟수를 줄인다. GrapeQL하나의 Endpoint에 모든 CRUD, 혹은 그에 속하기 애매한 모든 행위를 담음 POST의 경우 HTTP Payload를 적극적으로 활용application/jsonapplication/graphql 함수형 프로그래밍함수형 프로그래밍 특징 - 순수 함수일급객체 = 변수에 저장할 수 있는가, 파라미터로 전달할 수 있는가, return value로 사용될 수 있을까Persistent Immutable Data = 지속적이고 불변하는 데이터 함수형 프로그래밍이란? 데이터를 가공하는 컨베이어 벨트같은 것이다. 인프런 함수형-프로그래밍 Ramda 실용적인 함수형 프로그래밍 라이브러리 Ramda의 함수들은 모두 자동적으로 Curry 됩니다. R.isNil, R.path, R.compose(a,b,c,d) 1R.compose(R.isNil, R.path([\"req\", \"query\", itemName]))(httpParam); Node.js API 서버 성능 개선기서버 하나의 한계 파악병목구간 확인코드 개선 후 비교 ARTILLERY.IO =&gt; Node.js 작성된 부하 테스트 도구 #","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"PlayNode","slug":"Node-js/PlayNode","permalink":"http://yoursite.com/categories/Node-js/PlayNode/"}],"tags":[{"name":"PlayNode","slug":"PlayNode","permalink":"http://yoursite.com/tags/PlayNode/"}]},{"title":"Node-kue","slug":"node-study-elasticache","date":"2017-10-27T03:54:00.000Z","updated":"2017-10-27T12:26:37.000Z","comments":true,"path":"2017/10/27/node-study-elasticache/","link":"","permalink":"http://yoursite.com/2017/10/27/node-study-elasticache/","excerpt":"","text":"Kue file-type을 이용한 파일 형식 감지 Redis In-memory Database Kue를 이용한 작업 큐 구현 aws-sdk를 통한 AWS S3 사용 Sharp를 이용한 이미지 처리 이미지 처리 라이브러리 express.Router multer를 이용한 multipart/form-data 처리 파일 업로드 지원 JSDoc 주석을 통한 문서 생성 RedisRedis는 대표적인 In-memory 데이터베이스입니다. 간단히 key-value 스토어로 사용하거나, 내장된 다양한 자료구조를 사용할 수 있습니다. 설치macOS의 경우 아래 명령을 통해 설치합니다. 12brew install redisbrew services start redis KueKue는 Node.js 기반 비동기 작업 큐입니다. 데이터 저장과 통신을 위해 Redis를 사용합니다. 주로 CPU 부하가 큰 작업(멀티미디어 처리, PDF 생성 등)을 웹 서버와 분리된 다른 프로세스에서 실행시키기 위한 목적으로 사용됩니다. 어떤 작업을 다른 서버로 넘기기위한 방법이다. ElastiCacheElastiCache는 AWS에서 제공하는 Redis이다. ElastiCache를 사용할 때에는 const queue = kue.createQueue()안에서 AWS에서 생성한 ElastiCache의 end-point를 설정해야한다. ElastiCache를 실행시킬 worker.js를 실행시키기 위해서는 PM2로 실행한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Elasticache","slug":"Node-js/Elasticache","permalink":"http://yoursite.com/categories/Node-js/Elasticache/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"AWS","slug":"AWS","permalink":"http://yoursite.com/tags/AWS/"},{"name":"Elasticache","slug":"Elasticache","permalink":"http://yoursite.com/tags/Elasticache/"}]},{"title":"Node-Project","slug":"node-project-dada-redis","date":"2017-10-08T03:54:00.000Z","updated":"2017-11-30T12:32:52.000Z","comments":true,"path":"2017/10/08/node-project-dada-redis/","link":"","permalink":"http://yoursite.com/2017/10/08/node-project-dada-redis/","excerpt":"","text":"Node Project DADA Redis Google Vision API와 S3upload를 Promise.All로 처리하면서 sharp로 이미지를 변환하였으나 CPU의 부하를 줄여주기 위하여 Kue + Redis를 사용 하였다. Redis는 In memory Database라고 불리며 배열 형식의 데이터 처리에 특화되어있다. 먼저 promise.all로 구현이 되어있던 부분 중에서 sharp로 처리하는 부분을 제거하고 새로운 promise로 queue.create()를 한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// queue를 사용하기 위해서는 createQueue()를 해주어야 한다. const kue = require('kue')const queue = kue.createQueue()/*createQueue를 설정하는 방법이다.const queue = kue.createQueue(&#123; prefix: 'q', redis: &#123; port: 1234, host: '10.0.50.20', auth: 'password', db: 3, // if provided select a non-default redis db options: &#123; // see https://github.com/mranney/node_redis#rediscreateclient &#125; &#125;&#125;)*/router.post('/', upload.single('upload_img'), (req, res) =&gt; &#123; // jpg image/jpeg &lt;&lt; [ ext, mime ] const &#123; ext, mime &#125; = fileType(req.file.buffer) if (!supportImageExt.includes(ext)) &#123; res.status(400) res.send('지원하지 않는 파일입니다.') &#125; else if (req.file.size &gt; maxFileSize) &#123; res.status(400) res.send('파일 용량은 3mb 까지 입니다.') &#125; const fileName = `$&#123;uuid.v4()&#125;.$&#123;ext&#125;` Promise.all([googleVision(req.file.buffer), s3upload(req.file.buffer, fileName, mime)]) .then(result =&gt; &#123; const filterText = ['food', 'cuisine', 'american food', 'baking', 'flavor', 'recipe', 'fast food', 'dessert', 'dish', 'cookie', 'organism', 'snack', 'font', 'baked goods', 'finger food', 'junk food', 'side dish', 'vegetarian food'] const out = result[0].filter(item =&gt; &#123; if (filterText.indexOf(item.description) &lt; 0) &#123; return item &#125; &#125;) const output = &#123; 'visionAnalysis': out, 'imgUrl': result[1].Location &#125; res.send(output) return output &#125;) .then(result =&gt; &#123; // sharp로 처리하였던 부분을 redis로 처리하기 위하여 새로운 promise 작성 return new Promise((resolve, reject) =&gt; &#123; // queue.create를 생성시 queue.process와 같게 해야하며 2번째 인자로는 전달할 값을 넣어주어야 한다. queue.create('thumbnail', &#123; 'imgUrl': result.imgUrl &#125;) .removeOnComplete(true) .save(err =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve() &#125; &#125;) &#125;) &#125;) .catch(err =&gt; &#123; res.status(400) res.send(err) &#125;)&#125;) redis를 실행시킬 파일 12345678910111213141516171819202122232425262728293031323334const kue = require('kue')const queue = kue.createQueue()// queue.create와 같게 만들어야한다. // 생성시 2번째로 보내주는 값이 url이기 때문에 axios를 통하여 값을 get해야한다.queue.process('thumbnail', (job, done) =&gt; &#123; // image를 다운받기 때문에 responseType에 유의해야한다. axios(&#123; 'method': 'get', 'url': `$&#123;job.data.imgUrl&#125;`, // / options are 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // default // 이곳에서는 arraybuffer가 사용된다. 'responseType': 'arraybuffer' &#125;) .then(response =&gt; &#123; // `data` is the response that was provided by the server console.log('response.body', response.data) const &#123; ext, mime &#125; = fileType(response.data) console.log('ext!!!!!!!!!!!Mim11', ext, mime) const fileName = `$&#123;uuid.v4()&#125;.$&#123;ext&#125;` return sharp(response.data) .resize(200, 200) .crop(sharp.gravity.center) .toBuffer() .then(resizeFile =&gt; &#123; console.log('done') return s3upload(resizeFile, `thumb/$&#123;fileName&#125;`) &#125;) .then(() =&gt; &#123; done() &#125;) &#125;)&#125;) 팀원의 요청으로 인하여 S3의 가공전 upload filename과 가공후의 filename의 이름을 맞춰달라고 하여서 추가 작업을 진행하였다. queue.create 할때 fileName을 함께보내준다. 12345678910111213141516171819202122232425262728293031323334353637383940router.post('/', upload.single('upload_img'), (req, res) =&gt; &#123; // jpg image/jpeg &lt;&lt; [ ext, mime ] const &#123; ext, mime &#125; = fileType(req.file.buffer) if (!supportImageExt.includes(ext)) &#123; res.status(400) res.send('지원하지 않는 파일입니다.') &#125; else if (req.file.size &gt; maxFileSize) &#123; res.status(400) res.send('파일 용량은 3mb 까지 입니다.') &#125; const fileName = `$&#123;uuid.v4()&#125;.$&#123;ext&#125;` Promise.all([googleVision(req.file.buffer), s3upload(req.file.buffer, fileName, mime)]) .then(result =&gt; &#123; const output = &#123; 'visionAnalysis': result[0], 'imgUrl': result[1].Location &#125; res.send(output) return output &#125;) .then(result =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; queue.create('thumbnail', &#123; 'imgUrl': result.imgUrl, 'fileName': fileName &#125;) .removeOnComplete(true) .save(err =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve() &#125; &#125;) &#125;) &#125;) .catch(err =&gt; &#123; res.status(400) res.send(err) &#125;)&#125;) worker.js 파일에서는 queue.process부분에서 fileName을 추가해주었다. 123456789101112131415161718192021222324queue.process('thumbnail', (job, done) =&gt; &#123; axios(&#123; 'method': 'get', 'url': `$&#123;job.data.imgUrl&#125;`, 'fileName': `$&#123;job.data.fileName&#125;`, 'responseType': 'arraybuffer' &#125;) .then(response =&gt; &#123; // response.data안에 파일의 정보가 저장되어있다. // fileName은 response.config안에 저장되어있다. const fileName = `$&#123;response.config.fileName&#125;` const &#123; ext, mime &#125; = fileType(response.data) return sharp(response.data) .resize(200, 200) .crop(sharp.gravity.center) .toBuffer() .then(resizeFile =&gt; &#123; return s3upload(resizeFile, `thumb/$&#123;fileName&#125;`) &#125;) .then(() =&gt; &#123; done() &#125;) &#125;)&#125;)","categories":[{"name":"Project","slug":"Project","permalink":"http://yoursite.com/categories/Project/"},{"name":"redis","slug":"Project/redis","permalink":"http://yoursite.com/categories/Project/redis/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Knex","slug":"Knex","permalink":"http://yoursite.com/tags/Knex/"}]},{"title":"Node-Project","slug":"node-project-dada","date":"2017-10-08T03:54:00.000Z","updated":"2017-11-30T12:25:06.000Z","comments":true,"path":"2017/10/08/node-project-dada/","link":"","permalink":"http://yoursite.com/2017/10/08/node-project-dada/","excerpt":"","text":"Node Project DADA Da, Da&lt;기록과 통계&gt;를 통해 식습관을 모니터링 할 수 있고,칼로리 카운트를 통해 식단을 관리할 수 있는 회원제 &lt;다이어트 다이어리&gt; 서비스 서비스 목표바른 다이어트를 위해서는 건강하고 균형잡힌 식습관을 유지할 필요가 있다. 사용자가 복잡하고 번거로운 칼로리/영양성분 계산을 하지 않아도 되게 하자. 사용자가 식단을 기록하고, 통계를 확인하면서 본인의 식습관을 차차 교정하도록 유도하자. 사용자가 건강한 식습관을 유지할 수 있도록 식단 관리를 서포트해주는 편리한 서비스를 제공하자. 서비스 기능 요약1. 기록(주요 기능) 식단 기록 텍스트 검색과 사진 검색을 지원한다. 검색을 통해 아침/점심/저녁/간식 식사 정보를 기록할 수 있다. 사진 기록 사진을 업로드할 수 있다. 업로드한 사진은 앨범을 통해 보관할 수 있다. 앨범에 저장된 사진은 이후 다른 날 식단 다이어리에서도 첨부하거나 사진 검색에 활용할 수 있다. 일기 기록 당일 장문의 일기와 짧은 반성 일기를 남길 수 있다. 반성 일기는 다음 날 로그인시 홈 로딩화면 위에 표시된다. 체중 기록 시작/목표/현재 체중을 사용자가 직접 입력하거나 삭제 할 수 있다. 시작 체중으로부터 현재 체중까지 변화 양상을 확인할 수 있는 그래프를 제공한다. 2. 리포트 주 별 통계 (차트)사용자의 식사 패턴(식사 시간대, 3대 영양소 비율)에 대한 막대그래프와 요약 정보를 제공한다. 3. 레시피 검색 검색텍스트 검색과 사진 검색을 지원한다. 레시피 정보 원하는 레시피 정보를 조회할 수 있다. 레시피 화면을 통해 요리 진행 사항을 체크할 수 있다. (체크박스 제공) 레시피 재료의 양 정보를 기준 인분 수 입력을 통해 조정된 값으로 제공받을 수 있다. 레시피로 조리된 음식을 식단에 기록할 수 있다. 4. 로그인 로그인은 소셜로그인만 지원한다. 네이버, 카카오, 페이스북, 인스타그램 로그인을 지원한다. 5. SNS공유 식단 및 통계를 미리 디자인된 정적 페이지로 각 소셜에 공유할 수 있다. 팀 구성원프론트엔드 김나영 이혜승 백엔드 김세준 임옥택 조수현 기술 스택 &amp; 툴ProtoType &amp; Design Google spread sheet Sketch Invision Frontend1) UI React React-Router Redux CSS 1-1) Extension or Frameworks Semantic-ui-react (CSS Framework) Draft.js (Text editor Framework) recharts.js (Chart Package) 2) Network fetch API 3) Package Manager yarn 4) Convention &amp; Task Manager editor config prettier (formatter) eslint webpack Backend1) Server Node.js Express 2) Database MYSQL KNEX (node-mysql connector) 3) Open API Googl Vision API AWS (supported: EC2, S3(Image Storage), Caddy): Cloud Web Server Redis(supported: KUE): In-memory data structure store 4) Package Manager npm 5) Convention editor config eslint 6) Error Reporting Manager BugSnag Team Work Git (소스 코드 버전 관리) Zeplin (디자인 시안 공유) 매주 월/화/목 HangOut 온라인 회의: 데일리 스크럼 매주 수/금 오프라인 정기 회의: 이슈 공유 및 논의, 코드 리뷰 Scrum Board 작성: Google Spread Sheet (매일 진행 사항 공유 &amp; 일정 관리) Github &amp; Github Projects (작업 분담(기능별 &amp; 페이지별) 및 이슈 관리) API Document Summary1. 기획1) 와이어프레임 2) 프로토타입 프로토타입 보기 2. 디자인1) 디자인 시안 더 많은 디자인 시안 보기 3. 개발","categories":[{"name":"Project","slug":"Project","permalink":"http://yoursite.com/categories/Project/"},{"name":"ReadMe","slug":"Project/ReadMe","permalink":"http://yoursite.com/categories/Project/ReadMe/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Knex","slug":"Knex","permalink":"http://yoursite.com/tags/Knex/"}]},{"title":"Node-Testablility","slug":"node-study-testablility","date":"2017-09-27T03:54:00.000Z","updated":"2017-10-07T08:46:42.000Z","comments":true,"path":"2017/09/27/node-study-testablility/","link":"","permalink":"http://yoursite.com/2017/09/27/node-study-testablility/","excerpt":"","text":"Testablility테스트 용이성(Testability)는 소프트웨어에 대한 테스트가 얼마나 쉬운지를 말하는 용어입니다. 테스트 용이성이 높을 수록 소프트웨어의 설계가 유연하고 컴포넌트 간 결합도가 낮기 때문에, 좋은 설계라고 할 수 있습니다. 이번 프로젝트에서는 Node.js 기반 소프트웨어를 테스트하는 방법과, Testability를 고려한 설계 방법, 지속적인 통합(Continuous Integration, CI)를 다룹니다. assert 내장 모듈 assert.ok(true) true로 들어오면 true이다. =&gt; !! 뒤에 값을 붙여서 확인가능하다. assert.equal(a, b) a == b가 같은지 확인 assert.strictEqual(a, b) a === b 가 같은지 확인 assert.deepEqual([1,2,3], [1,2,3]) 배열, 객체까지도 같은지를 확인한다. assert.throws(() =&gt; {throw new Error() } ) 나의 의도대로 에러가 발생하는지 테스트 할 때 사용 ex) assert.throws(() =&gt; {throw new MyError()}, MyError) Mocha test framework SuperAgent &amp; SuperTest Testability를 높이기 위한 의존성 주입과 Sinon 지속적인 통합 &amp; Travis CI","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Testablility","slug":"Node-js/Testablility","permalink":"http://yoursite.com/categories/Node-js/Testablility/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Testablility","slug":"Testablility","permalink":"http://yoursite.com/tags/Testablility/"}]},{"title":"Node-Linux-AWS(EC2)","slug":"node-linux-awsEC2","date":"2017-09-26T03:54:00.000Z","updated":"2017-10-06T12:55:43.000Z","comments":true,"path":"2017/09/26/node-linux-awsEC2/","link":"","permalink":"http://yoursite.com/2017/09/26/node-linux-awsEC2/","excerpt":"","text":"Linux TutorialEC2AWS EC2(Elastic Compute Cloud)는 리눅스 및 Windows 가상 서버를 제공하는 AWS 서비스입니다. 서버를 사용한 시간만큼만 과금되고, 필요에 따라 서버의 갯수를 늘였다가 줄였다가 하는 일을 자유롭게 할 수 있습니다. 또한 서버를 다시 구축할 필요 없이 서버의 사양을 높이거나 낮출 수도 있습니다. 인스턴스 및 AMI 리전 및 가용 영역 IAM 역할 EC2에 AWS roles를 꼭 붙인다. 보안 그룹 Elastic Block Store 키 페어 EC2 인스턴스에 접속하기 위해 키 페어가 필요합니다. 인스턴스 생성 시 다운로드 받은 비밀 키를 잃어버리면 인스턴스에 접속할 수 없게 되니 주의하세요. SSHSSH(Secure Shell)는 네트워크 상의 다른 컴퓨터에 접속해서 명령을 실행하거나 파일을 전송할 수 있도록 해 주는 응용 프로그램, 혹은 그 프로토콜을 말합니다. 보통 22번 포트를 사용합니다. SSH는 통신을 암호화하기 때문에 다른 사람이 통신의 내용을 엿볼 수 없습니다. Git 역시 통신을 위해 SSH 프로토콜을 사용하고 있습니다. EC2 인스턴스 역시 SSH를 통해 접속할 수 있습니다. 접속을 위해서 인스턴스 생성 시에 부여받은 비밀 키가 필요합니다. EC2 Instances 페이지 상단의 Connect 버튼을 눌러 가이드를 따라하세요. 리눅스에서 자주 사용되는 명령아래에 자주 사용하는 리눅스 명령을 모아두었습니다. man 명령을 사용하면 다른 명령에 대한 도움말을 표시할 수 있습니다. (예: man ls) 파일 관리 명령 ls: 디렉토리의 내용을 표시합니다. pwd: 작업 디렉토리를 표시합니다. touch: 빈 파일을 만듭니다. cp: 파일 혹은 디렉토리를 복사합니다. mv: 파일 혹은 디렉토리를 이동합니다. 이름을 바꿀 때에도 사용됩니다. rm: 파일 혹은 디렉토리를 삭제합니다. chmod: 파일의 접근 권한을 설정합니다. chown: 파일의 소유자를 변경합니다. ln: 파일 링크를 만듭니다. symbolic link를 만든다. =&gt; symbolic link는 절대경로를 사용해야한다 ls -al 를 통하여 자세한 정보를 받아올 수 있다. 시스템 및 접속 정보 who: 시스템에 접속 중인 계정을 표시합니다. whoami: 현재 접속자의 계정 이름을 표시합니다. date: 현재 시간을 표시합니다. top: 시스템 자원과 프로세스의 정보를 표시합니다. 이와 유사하지만 더 편리하게 사용할 수 있는 htop라는 도구도 있습니다. free: 시스템의 메모리 사용량을 표시합니다. df: 시스템의 디스크 사용량을 표시합니다. du: 파일 및 디렉토리의 디스크 사용량을 표시합니다. -r option으로 폴더도 복사할 수 있다. rm -rf 으로 폴더를 삭제할 수 있다. 프로세스 관리 sleep: 쉘을 일정 시간동안 정지시킵니다. ps: 시스템에서 실행되고 있는 프로세스의 정보를 표시합니다. jobs: 현재 쉘에서 실행 중인 작업을 표시합니다. fg: 중지되었거나 백그라운드에서 실행되고 있는 작업을 포그라운드로 표시합니다. bg: 중지되어 있는 작업을 백그라운드에서 실행시킵니다. kill: 특정 프로세스를 종료합니다. nohup: 터미널이 종료되어도 프로세스가 종료되지 않도록 합니다. 파일의 내용 표시 cat: 파일의 내용을 출력합니다. less: 파일의 내용을 스크롤하며 탐색합니다. tail: 파일의 마지막 부분의 내용을 출력합니다. echo: 문자열을 출력합니다. wc: 파일의 단어 갯수를 세어 표시합니다. tee: 표준 입력으로 출력과 파일 저장을 동시에 합니다. 기타 grep: 파일의 내용을 필터링합니다. curl: URL을 통해 통신을 합니다. curl 명령을 통해 파일을 다운로드 받을 수 있습니다. clear: 터미널 화면의 내용을 비웁니다. sudo: 관리자 권한으로 명령을 실행합니다. 패키지 관리 apt: 데비안 계열 리눅스의 패키니 매니저인 패키지를 설치합니다. 리눅스 참고자료SubshellRedirectionPipeJobSignal CyberduckCyberduck은 SSH를 통해 파일을 전송할 수 있는 프로토콜인 SFTP을 지원하는 파일 브라우저입니다. SFTP 외에도 많은 프로토콜 및 서비스를 지원합니다. Cyberduck을 이용해 편하게 EC2에 파일 전송을 할 수 있습니다. SFTP 연결을 새로 만들고 EC2 주소와 EC2 비밀 키를 넣어 주면 됩니다. RDSRDS는 클라우드에서 관계형 데이터베이스를 제공하는 AWS 서비스입니다. EC2와 유사하게 유연한 배포 및 확장이 가능합니다. MySQL, PostgreSQL, Oracle, MS SQL 등의 다양한 RDBMS를 지원합니다. RDS 보안 그룹RDS 보안 그룹의 소스로 다른 보안 그룹을 지정할 수 있습니다. 이렇게 설정하면, 외부(인터넷)으로부터의 접속은 막히는 대신 해당 보안 그룹을 사용하는 모든 인스턴스(일반적으로 애플리케이션 서버)에서 수신 트래픽이 허용됩니다. 자세한 내용은 공식 문서를 참고해주세요. 위와 같은 보안 그룹 설정을 적용하면 일반적인 방식으로는 보안 그룹 바깥에서 RDS 인스턴스에 접속할 수 없게 됩니다. 대신 SSH 터널링을 활용해 SSH를 거쳐서 접속하면, 바깥에서도 RDS 인스턴스에 접속할 수 있습니다. MySQL Workbench를 이용하면 SSH를 거치는 MySQL 커넥션을 쉽게 만들 수 있습니다. Git을 이용한 웹 서버 배포이제 이전에 실습했었던 채팅 서버를 EC2와 RDS를 사용해서 배포해보겠습니다. 일단 서버에서 Github 저장소를 복제하기 위해서는 SSH key 생성과 등록이 필요합니다. 12$ ssh-keygen$ cat ~/.ssh/id_rsa.pub 그 다음, 보안 그룹이 잘 설정되었는지 확인하고 EC2 주소에 접속해보세요. Route 53Route 53은 도메인과 관련된 기능을 제공하는 AWS 서비스입니다. Route 53을 통해 도메인 구입, DNS 서버 설정 등을 할 수 있습니다. Route 53에서 구입한 도메인을 EC2 인스턴스에 연결시킬 수 있습니다. 자세한 내용은 공식 문서를 참고해주세요. PM2Node.js로 만들어진 웹 서버는 예기치 못한 에러 때문에 종료되어버리는 경우도 있고, 메모리 누수가 발생하는 경우도 잦습니다. 이런 문제를 해결하기 위해 서버가 예상치 못한 이유로 종료되었을 때 서버를 재시작해주고, 또 메모리 사용량이 일정량 이상이 되면 서버를 재시작해주는 등의 작업이 필요합니다. 이런 작업을 자동화해주는 도구를 보고 프로세스 매니저라고 부릅니다. PM2는 Node.js 생태계에서 가장 널리 사용되는 프로세스 매니저입니다. 비슷한 다른 도구들과 비교했을 때 사용하기 쉽고 편의 기능이 많습니다. 또한 Node.js 모니터링 도구인 Keymetrics와 긴밀하게 통합됩니다. 또한 PM2에는 Node.js cluster를 자동 생성해주는 기능 및 로드 밸런서가 포함되어 있어서, 고성능 웹 서버를 쉽게 운영할 수 있도록 해줍니다. Cluster에 대한 자세한 설명은 공식 문서를 참고해주세요. 많은 서버를 다룰때에는 Node.js cluster를 통해서 서버를 다룰줄 알아야한다. 보통 아래와 같이 프로세스 정의 파일을 통해 실행할 스크립트와 환경변수 등을 설정한 후, 해당 설정에 이름을 붙여서 실행하게 됩니다. 자세한 사용법은 공식 문서를 참고해주세요. pm2로 실행을 해두면 터미널을 종료하여도 서버가 끝나지 않는다. pm2를 사용할때 여러개의 서버를 한번에 관리할 수 있다. 1234567891011121314# 설치방법npm install -g pm2# 실행방법pm2 start src/index.js# 실행 목록pm2 ls# 실행 목록 삭제pm2 appname delete# 원하는 이름으로 실행pm2 start src/index.js --name 원하는이름 12345678910111213# process.ymlapps: - script : ./api.js name : 'api-app' instances: 4 exec_mode: cluster - script : ./worker.js name : 'worker' watch : true env : NODE_ENV: development env_production: NODE_ENV: production 123456789101112131415161718192021222324252627282930313233343536$ pm2 start process.yml --name myapp``` ## Reverse Proxy리버스 프록시는 웹 서버의 일종으로, 시스템의 바깥 쪽에서 내부에 있는 웹 서버로 요청을 전달해주는 기능을 합니다. 리버스 프록시는 보통 다음과 같은 역할을 수행합니다. - DDoS 등의 공격을 막는 방화벽- 부하를 분산시키는 로드 밸런서- 정적 컨텐츠 제공- 압축- 하나의 IP 주소와 포트를 이용해 여러 개의 웹 서버 운영## Caddy[Caddy](https://caddyserver.com/)는 [리버스 프록시 기능](https://caddyserver.com/docs/proxy)을 내장하고 있는 웹 서버로, 인증서 등록 및 설치를 자동으로 해주기 때문에 굉장히 편하게 HTTPS 웹 서버를 운영할 수 있습니다. 또한 Caddyfile이라는 간단한 문법의 설정 파일을 통해 웹 서버를 설정하도록 하고 있습니다. 아래는 리버스 프록시 설정을 한 Caddyfile 예제입니다. - EC2를 실행한 후에 Caddy를 실행시킬 수 있습니다.```bash# https://example.com URI로 들어온 요청을 http://localhost:3000 서버에 연결시킴# http://example.com 쪽으로 들어온 요청은 https로 리다이렉트example.com &#123; proxy / localhost:3000 &#123; # 리버스 프록시에 요청이 어떤 형태(IP, 프로토콜)로 왔는지를 # 뒤쪽 서버에 별도의 헤더를 통해 전달 transparent &#125;&#125;chat.example.com &#123; proxy / localhost:4000 &#123; transparent # 웹소켓 요청도 전달하기 websocket &#125;&#125; Caddyfile을 작성한 뒤에 해당 폴더에서 caddy 명령을 통해 Caddy 웹 서버를 실행시킬 수 있습니다. 터미널이 꺼져도 계속 Caddy가 실행되게 하려면 아래의 명령을 실행하면 됩니다. 1$ nohup caddy &amp; HTTPS를 사용하려면 먼저 DNS 설정이 되어 있어야 합니다. Route 53에서 먼저 DNS 설정을 한 뒤에 Caddy를 실행시켜 주세요. Reverse Proxy + Express리버스 프록시를 통해 운영되는 Express 웹 서버가 IP 추적 기능이나 쿠키를 사용한다면 반드시 trust proxy 옵션을 설정해주어야 합니다. 자세한 사항은 공식 문서를 참고해주세요.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Linux","slug":"Node-js/Linux","permalink":"http://yoursite.com/categories/Node-js/Linux/"},{"name":"AWS","slug":"Node-js/Linux/AWS","permalink":"http://yoursite.com/categories/Node-js/Linux/AWS/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"AWS","slug":"AWS","permalink":"http://yoursite.com/tags/AWS/"}]},{"title":"Node-Rest-API","slug":"node-study-restapi2","date":"2017-09-25T03:54:00.000Z","updated":"2017-10-05T02:38:41.000Z","comments":true,"path":"2017/09/25/node-study-restapi2/","link":"","permalink":"http://yoursite.com/2017/09/25/node-study-restapi2/","excerpt":"","text":"REST(Representaitonal State Transfer)REST(Representaitonal State Transfer)는 HTTP나 JSON 같은 기술 표준아닙니다. REST는 로이 필딩이라는 사람이 아파치 웹 서버와 HTTP 1.1을 설계할 때 세웠던 원칙들을 모아서 쓴 그의 박사학위 논문에서 처음 제시한 뒤 널리 퍼진 개념입니다. REST는 웹 서비스를 만들 때 아래와 같은 설계 규칙을 지키도록 명시하고 있습니다. 클라이언트-서버 아키텍처 무상태(statelessness): 클라이언트의 세션 상태는 웹 서버 대신 클라이언트에 저장되어야 합니다. 어떤 값이 어디에 저장될지 모르기 때문에 웹 서버에 저장되면 안된다. 캐시 가능: 웹 서버의 응답은, 캐시 가능 여부에 대한 정보를 포함해야 합니다. 계층 시스템: 클라이언트는 요청이 정확히 어느 웹 서버에 도달할 지, 중간 매체가 있는지 없는지를 모르더라도 별다른 문제없이 서비스를 사용할 수 있어야 합니다. 일관된 인터페이스 자원은 URI를 통해서 식별하고, 자원의 제공 형태를 식별자에 포함시키지 않습니다. 서버가 요청을 잘 처리할 수 있도록 각 요청은 충분한 정보를 포함하고 있어야 합니다. (Content-Type 등) 필요 시 코드 전송(Code on demand): 웹 서버는 자바 애플릿, 플래시, 자바스크립트 등의 제공을 통해 클라이언트의 기능을 확장시킬 수 있습니다. 위 설계 원칙을 따름으로써 웹 서버는 아래의 좋은 속성들을 가질 수 있게 됩니다. 높은 성능 확장가능성(Scalability) 인터페이스의 단순함 웹 서버의 실시간 업데이트가 가능 Sticky Session 사용자가 사용했던 한개의 서버로만 접속하게 하는 것 : 좋지 않은 방법이다. REST API위의 REST 원칙을 따르는 웹 API를 가지고 REST API라고 부릅니다. REST API 역시 REST와 같이 표준화 된 기술은 아닙니다만, 개발자 커뮤니티에서 합의가 되어 있는 best practice 들이 있습니다. RESTful URI 설계REST API의 URI는 기본적으로 ‘자원’을 나타냅니다. URI를 통해 자원을 표현할 때는 다음과 같은 기본 원칙을 따르도록 합니다. 슬래시(/) 문자는 자원 간 계층관계를 나타내는 데 사용합니다. 마지막 문자로 슬래시를 포함하지 않습니다. 띄어쓰기를 표현할 때는 하이픈(-)을 사용하고, 밑줄(_)을 사용하지 않는다 대문자 대신 소문자만을 사용합니다. 경로에 확장자를 쓰지 않습니다. 내용 협상을 위해서는 Accept 헤더를 사용합니다. 자원은 하나일 수도, 여러 개일수도, 혹은 특정한 동작을 나타내는 것일 수도 있습니다. Document도큐먼트는 보통 하나의 객체 혹은 데이터베이스 레코드를 나타내는 단일 자원입니다. URI에서는 아래와 같이 단수 명사로 표기합니다. 123https://api.example.com/userhttps://api.example.com/service-infohttps://api.example.com/resource Collection컬렉션은 보통 여러 개의 객체 복수의 자원 혹은 데이터베이스의 여러 레코드를 나타내는 자원입니다. 도큐먼트는 파일에, 컬렉션은 폴더에 비유할 수 있습니다. 12https://api.example.com/todoshttps://api.example.com/articles 컬렉션 뒤에 자원의 식별자를 붙여서 도큐먼트를 나타낼 수도 있습니다. 12https://api.example.com/todos/123https://api.example.com/articles/how-to-design-rest-api Controller자원에 대한 단순한 CRUD(Create, Read, Update, Delete)는 HTTP 메소드를 통해서 할 수 있지만, 단순 CRUD가 아닌 경우에는 자원 뒤에 동사를 붙여서 해당 동작을 표현할 수 있습니다. 우리의 절차를 걸치지 않고 다른 사람이 데이터베이스를 변경할 수 도 있다. 밑에 예제 처럼해야한다. controller에 대해서는 없는 기능에 대해서는 post 요청을 사용한다. 1https://api.example.com/todos/123/finish REST API 통신 설계기본적으로 의미에 맞는 HTTP 메소드와 상태 코드를 사용해주세요. 컬렉션, 도큐먼트, 컨트롤러에 대해서는 HTTP 메소드를 아래와 같이 사용합니다. 123456789# 컬렉션에 속해있는 자원을 모두 가져오기 위해 컬렉션 URI에 GET 요청을 보냅니다.GET https://api.example.com/todos# 컬렉션에 대한 filtering이나 pagination을 위해 쿼리 스트링을 사용할 수 있습니다.GET https://api.example.com/todos?complete=true&amp;assignee=meGET https://api.example.com/todos?page=2# 컬렉션 내에 새로운 자원을 생성하기 위해 POST 요청을 보냅니다.POST https://api.example.com/todos 12345678910# 단일 도큐먼트를 읽어오기 위해 도큐먼트 URI에 GET 요청을 보냅니다.GET https://api.example.com/userGET https://api.example.com/todos/123# 도큐먼트를 수정하기 위해 PUT(치환) 혹은 PATCH(변경) 요청을 보냅니다.PUT https://api.example.com/todos/123PATCH https://api.example.com/user# 도큐먼트를 삭제하기 위해 DELETE 요청을 보냅니다.DELETE https://api.example.com/todos/123 이런 식으로 하면 안 됩니다! 12345678# 자원의 생성을 위한 URI가 따로 존재하고 GET 메소드를 사용하는 경우GET /add_todo?title=mytodo# 자원 식별자를 쿼리 스트링에 포함시키는 경우GET /todo?id=1# 자원의 삭제를 위해 POST 메소드를 사용하는 경우POST /todos/1/delete?id=1 get으로 절대로 자원을 생성해서는 안된다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Rest-API","slug":"Node-js/Rest-API","permalink":"http://yoursite.com/categories/Node-js/Rest-API/"}],"tags":[{"name":"RestAPI","slug":"RestAPI","permalink":"http://yoursite.com/tags/RestAPI/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"Node-SPA-security-authentication","slug":"node-study-spa-security-authentication","date":"2017-09-25T03:54:00.000Z","updated":"2017-10-05T02:38:34.000Z","comments":true,"path":"2017/09/25/node-study-spa-security-authentication/","link":"","permalink":"http://yoursite.com/2017/09/25/node-study-spa-security-authentication/","excerpt":"","text":"170925 WPSN SPA Security &amp; AuthenticationSPA SecuritySPA(Single-Page Application)은 사용자 경험이 좋은 만큼 프론트엔드와 백엔드의 코드가 복잡해지는 경우가 많습니다. SPA와 API 서버의 출처가 같은 경우, 보안과 인증을 위해 전통적 방식대로 쿠키를 쓸 수 있습니다. 다만 쿠키를 위한 보안 정책(CSRF 등)은 당연히 적용해야 합니다. SPA와 API 서버의 출처가 다른 경우에도 쿠키를 사용할 수 있지만, 여러가지 문제(구현 상 불편함, 보안의 취약함)때문에 보통 쿠키 대신 JWT와 같은 토큰을 사용하는 경우가 많습니다. 일단은 출처가 다르므로 CORS 보안 정책에 대한 구현이 필요한데, 이 때 설정을 통해서 특정 출처의 Ajax 요청에 대해서만 API 서버에 접근 가능하도록 제한을 둘 수 있습니다. 1234app.use(cors(&#123; origin: 'http://example.com', optionsSuccessStatus: 200 // some legacy browsers (IE11, various SmartTVs) choke on 204 &#125;)) 기존 page : window.open(‘http:google.com’)열린 page : window.opener // 나를 연 page를 참조 window.opener.postMessage(‘send message’, ‘*’) 기존 page : window.addEventListerner(‘message’, e =&gt; { console.log(e.data)}) SPA AuthenticationSPA의 인증을 위해 단순하게 인증을 위한 REST API를 둘 수도 있을 것입니다. 하지만 회원가입과 로그인은 누구나 할 수 있어야 한다는 특성때문에 REST API가 공격을 받을 위험이 커지게 됩니다. 그래서 회원가입과 로그인 만큼은 SPA + REST API를 통해서 하는 것이 아니라, CSRF와 Captcha 등의 보안 정책을 적용한 별도의 웹 페이지를 통해 해주는 것이 좋습니다. 이런 전략을 사용하면 SPA와 웹 페이지 간에 토큰을 주고 받을 필요가 있는데, 이를 위해 팝업(window.open)과 윈도우 간 메시지 통신(window.postMessage)을 사용합니다. redirect 로그인, 회원가입을 하면 토큰을 포함 시킨 경로를 가지고 spa로 redirect 시킬 수 있다. popup =&gt; window.open, window.postMessage사용 아래의 두 프로젝트를 통해 직접 SPA 인증 절차를 시험해 볼 수 있습니다. api 프로젝트는 passport를 이용해서 Github OAuth 로그인을 구현한 프로젝트입니다. spa 프로젝트는 React를 이용해서 API 서버에 접속할 수 있는 프로젝트입니다. 인증 절차는 다음과 같이 구현되었습니다. SPA에서 API 서버의 /auth/ 경로에 대해 팝업을 열고 message 이벤트에 대한 핸들러를 등록합니다. 사용자는 API 서버에 대해 열린 팝업에서 로그인을 시도합니다. 로그인이 성공하면, 팝업에서 window.opener.postMessage(…)를 통해 SPA에 토큰을 전달합니다. 이제부터 SPA에서 토큰을 통해 인증된 요청을 보낼 수 있게 됩니다. 인증 절차에 대한 자세한 사항은 코드를 참고해주세요.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"SPA","slug":"Node-js/SPA","permalink":"http://yoursite.com/categories/Node-js/SPA/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"SPA","slug":"SPA","permalink":"http://yoursite.com/tags/SPA/"}]},{"title":"Node-kue","slug":"node-study-kue","date":"2017-09-21T03:54:00.000Z","updated":"2017-10-04T11:37:38.000Z","comments":true,"path":"2017/09/21/node-study-kue/","link":"","permalink":"http://yoursite.com/2017/09/21/node-study-kue/","excerpt":"","text":"Kue file-type을 이용한 파일 형식 감지 Redis In-memory Database Kue를 이용한 작업 큐 구현 aws-sdk를 통한 AWS S3 사용 Sharp를 이용한 이미지 처리 이미지 처리 라이브러리 express.Router multer를 이용한 multipart/form-data 처리 파일 업로드 지원 JSDoc 주석을 통한 문서 생성 file-typefile-type은 파일의 내용을 확인해서 그 파일이 어떤 형식의 파일인지를 탐지해주는 라이브러리입니다. 웹 브라우저와 Node.js 모두에서 동작합니다. Node.js의 경우 바이너리 파일을 담는 클래스인 Buffer의 인스턴스를 이용해 파일 형식을 탐지할 수 있습니다. fs 모듈의 readFile 혹은 readFileSync 메소드를 이용하면 Buffer 클래스를 사용해볼 수 있습니다. fs는 내장 모듈로써 설치하지 않아도 바로 사용가능하다. 12345678const fs = require('fs')const fileType = require('file-type')const buffer = fs.readFileSync('image.png')console.log(buffer instanceof Buffer)// trueconsole.log(fileType(buffer))// &#123; ext: 'png', mime: 'image/png' &#125; RedisRedis는 대표적인 In-memory 데이터베이스입니다. 간단히 key-value 스토어로 사용하거나, 내장된 다양한 자료구조를 사용할 수 있습니다. 설치macOS의 경우 아래 명령을 통해 설치합니다. 12brew install redisbrew services start redis Key-value storeredis-cli를 실행해서 아래 명령을 시험해보세요. 123456789101112131415161718192021222324252627// redis-cli 시작redis-cli// key-value 추가set mykey 'Hello Redis!'// value 가져오기get mykey// value 1 증가시키기incr mycount// value 5 증가시키기incrby mycount 5// value 1 감소시키기decr mycount// key가 존재하는지 확인exists mykeyexists yourkey// key 삭제del mykey// 5초 뒤 key 삭제expire mycount 5 Data structuresRedis는 다양한 데이터 구조를 내장하고 있습니다. 아래 list 관련 명령을 시험해보세요. 123456789101112131415// 리스트 오른쪽에 요소 추가rpush mylist 1rpush mylist 2 3 4 5// 범위 가져오기lrange mylist 0 2// 리스트 왼쪽에 요소 추가lpush mylist 6 7 8 9// 리스트 왼쪽 요소 제거lpop mylist// 리스트 오른쪽 요소 제거rpop mylist 아래 hash 관련 명령을 시험해보세요. 12345678// 해시 속성 추가hmset user:1000 username fast password campus birthyear 2014// 해시 속성 가져오기hget user:1000 username// 해시 속성 모두 가져오기hgetall user:1000 아래 set 관련 명령을 시험해보세요. 12345678910111213// 집합에 요소 추가sadd myset 1 2 3// 모든 요소 가져오기smembers myset// 집합의 요소인지 확인sismember myset 1// 랜덤 뽑기sadd deck 1 2 3 4 5spop deckspop deck 이 밖에 Redis는 sorted set, bitmap, hyperloglog 등의 자료 구조를 지원합니다. 자세한 내용은 공식문서를 참고해주세요. Pub/SubRedis는 데이터의 저장 외에 프로세스 간 통신을 위한 발행/구독 기능을 가지고 있습니다. 두 개의 redis-cli를 실행한 다음 한 쪽에서는 구독, 한 쪽에서는 발행 명령을 실행해보세요. sub으로 채널을 생성한다. pub으로 sub로 생성된 채널에 메시지를 보낼 수 있다. 12345// 채널 구독subscribe mychannel// 메시지 발행publish mychannel 'Hello Redis!' KueKue는 Node.js 기반 비동기 작업 큐입니다. 데이터 저장과 통신을 위해 Redis를 사용합니다. 주로 CPU 부하가 큰 작업(멀티미디어 처리, PDF 생성 등)을 웹 서버와 분리된 다른 프로세스에서 실행시키기 위한 목적으로 사용됩니다. 어떤 작업을 다른 서버로 넘기기위한 방법이다. 다음과 같이 작업을 생성합니다. 1234567891011121314151617const kue = require('kue')const queue = kue.createQueue(&#123; /* 작업 큐 설정 */ // 이곳에서 radis관련 설정을 할 수 있다.&#125;)const jobData = &#123; imageUrl: 'https://example.com/image.png', type: 'png'&#125;queue.createJob('make-thumbnail', jobData)// 작업이 끝난 뒤에 꼭 지워주는 removeOnComplete 옵션을 써야한다. .removeOnComplete(true) .save(err =&gt; &#123; if (err) &#123; /* 에러 처리 */ &#125; &#125;) 위에서 생성된 작업을 다음과 같이 받아서 실행합니다.123456789101112131415const kue = require('kue')const queue = kue.createQueue(&#123; /* 작업 큐 설정 */&#125;)// 작업을 동시에 10개까지 실행 job 개겣를 받는다.queue.process('make-thumbnail', 10, (job, done) =&gt; &#123; processImage(job.imageUrl, job.type) .then(() =&gt; &#123; done() &#125;) .catch(err =&gt; &#123; done(err) &#125;)&#125;) AWS S3AWS S3는 클라우드 파일 저장소입니다. 여러 프로그래밍 언어로 된 API를 통해 파일을 관리할 수 있고, 저장소 용량에 제한이 없으며 사용한 만큼만 비용을 지불하면 됩니다. (프리 티어 계정이라면 본 실습에서 사용하는 사용량 정도로는 과금이 될 일이 없으니 안심하세요!) S3 사용을 위해서는 AWS 계정과 AWS CLI 설정이 필요합니다. AWS CLI 설치macOS 사용자는 터미널에서 아래의 명령을 차례대로 실행하세요. 1234brew install python3pip3 install --user --upgrade awscliecho 'PATH=$HOME/Library/Python/3.6/bin:$PATH' &gt;&gt; ~/.zshrcaws --version 설치 후, aws configure 명령을 실행하여 계정 생성시에 부여받은 AWS access key ID와 secret key를 입력하세요. 파일 업로드Node.js에서는 aws-sdk npm 패키지를 통해 AWS의 모든 서비스를 사용할 수 있습니다. 아래와 같이 S3에 파일을 업로드할 수 있습니다. aws sdk 참고 자료 1234567891011121314151617const aws = require('aws-sdk')const s3 = new aws.S3(&#123; apiVersion: '2006-03-01'&#125;)const buffer = ... // 업로드 할 파일s3.upload(&#123; ACL: 'public-read', // 익명의 사용자도 파일 경로만 알면 읽기 가능하도록 설정 Body: buffer, Bucket: 'my-bucket-name', Key: 'my-file-name', ContentDisposition: ... // Content-Disposition 헤더 ContentType: ... // Content-Type 헤더&#125;, (err, data) =&gt; &#123; console.log(data.Location)&#125;) s3에서 버킷을 생성한다. 버킷은 URL에 들어갈 수 있는 이름으로 작성해야한다. sharpsharp는 Node.js에서 사용할 수 있는 고속 이미지 프로세싱 라이브러리입니다. 다양한 이미지 처리를 지원합니다. (크기 조정, 병합, 회전, 블러, 색조 변경 등) 자세한 사용법은 공식 문서를 참고하세요. 이 프로젝트에서는 썸네일 이미지 생성을 위해 크기 조정 기능을 사용해보겠습니다. 아래와 같이 크기 조정을 할 수 있습니다. 설치가 되지 않을 경우1. xcode-select --install2. npm install node-gyp 123456sharp('image.png') .resize(200, 200) // 비율에 맞게 줄인다. .crop(sharp.gravity.center) // 중앙을 남기고 잘른다. .toFile('output.png', (err, info) =&gt; &#123; console.log(info) &#125;) Buffer를 사용하는 경우 아래와 같이 작성할 수도 있습니다. 1234567sharp(inputBuffer) .resize(200, 200) .crop(sharp.gravity.center) .toBuffer() .then(buffer =&gt; &#123; ... &#125;) 12345678910111213141516const sharp = require('sharp')const fs = require('fs')sharp('photo.jpg') .resize(200, 200) .crop(sharp.gravity.center) .toFile('output.png', (err, info) =&gt; &#123; console.log(info) &#125;)const buffer = fs.readFileSync('photo.jpg')sharp(buffer) .resize(200, 200) .crop(sharp.gravity.center) .toFile('output2.png', (err, info) =&gt; &#123; console.log(info) &#125;) express.Routerexpress.Router를 사용하면 여러 라우트 핸들러를 묶어 모듈화시킬 수 있습니다. Router 인스턴스는 app과 비슷하게 사용하며, Router 인스턴스 자체도 미들웨어이므로 app.use메소드를 통해 사용할 수 있습니다. 1234567891011const router = express.Router()router.use(...)router.get('/some-path', (req, res) =&gt; &#123; ...&#125;)router.post('/other-path', (req, res) =&gt; &#123;&#125;) 1234567891011121314151617181920212223242526272829const express = require('express')const app = express()const router = express.Router()router.get('/', (req, res) =&gt; &#123; res.send('hello router')&#125;)const router2 = express.Router()router2.get('/', (req, res) =&gt; &#123; res.send('hello router2')&#125;)router2.use((req, res, next) =&gt; &#123; res.status(404) res.end('Not Fount')&#125;)app.use(router)app.use('/router2', router2)app.listen('3000', (req, res) =&gt; &#123; console.log('connect!!')&#125;) 위와 같이 라우터 인스턴스를 정의한 이후 app에 마운트하여 사용합니다. 123456789101112131415161718192021222324252627282930313233343536373839// 아래와 같이 마운트하면 됩니다.app.use(router)// 혹은 특정 경로에 마운트할 수도 있습니다.// 이제부터 /api/some-path, /api/other-path 주소로 접속해야 합니다.app.use('/api', router)``` &gt; api경로를 사용하는 router들을 다른 .js파일로 만들어서 개발하면 좋다.## multer`multer는` body-parser와 유사하지만, application/x-www-form-urlencoded 대신 multipart/form-data 형태의 폼 데이터를 처리하기 위해 사용됩니다. multer를 이용해 폼 데이터가 처리되면, `파일을 나타내는 객체`는 `req.file` 혹은 `req.files`에 저장되고 나머지 폼 데이터는 body-parser와 비슷하게 req.body에 저장됩니다. ```jsconst multer = require('multer')const upload = multer()// 하나의 파일 처리app.post('/photo', upload.single('photo'), (req, res) =&gt; &#123; // req.file : 파일 객체 // req.body : 나머지 폼 데이터&#125;)// 여러 개의 파일 처리 (파일 필드가 모두 같은 이름을 사용할 때)app.post('/photos', upload.array('photo'), (req, res) =&gt; &#123; // req.files : 파일 객체로 이루어진 배열 // req.body : 나머지 폼 데이터&#125;)// 여러 개의 파일 처리 (각각 다른 필드 이름 사용 시)const uploadMiddleware = upload.fields([ &#123; name: 'avatar', maxCount: 1 &#125;, &#123; name: 'gallery', maxCount: 8 &#125;])app.post('/photos', uploadMiddleware, (req, res) =&gt; &#123; // req.files : 필드 이름을 속성 이름으로, 파일 객체로 이루어진 배열을 값으로 하는 객체 // req.body : 나머지 폼 데이터&#125;) 123456789101112131415161718192021222324252627282930// multer.jsconst express = require('express')const multer = require('multer')const sharp = require('sharp')const app = express()const upload = multer()app.set('view engine', 'pug')app.get('/', (req, res) =&gt; &#123; res.render('index.pug')&#125;)app.post('/', upload.single('photo'), (req, res) =&gt; &#123; // 들어오는 photo가 buffer에 들어온다. sharp(req.file.buffer) .resize(200, 200) .crop(sharp.gravity.center) .toFile('output3.png', (err, info) =&gt; &#123; console.log(info) res.redirect('/') &#125;)&#125;)app.listen('3000', (req, res) =&gt; &#123; console.log('connect!!')&#125;) JSDocJSDoc은 특별한 형태의 주석을 소스코드에 작성하면 그에 따라 문서를 자동으로 생성해주는 문서 생성 도구입니다. JSDoc을 위한 주석을 아래와 같이 작성합니다. 12345678910111213// image.js/** 를 치면 나온다./** * 썸네일 생성 작업을 작업 큐에 추가합니다. * @param queue - kue queue 인스턴스 * @param &#123;string&#125; location - S3에 업로드된 파일의 public url * @returns &#123;Promise&#125; */function createThumbnailJob(queue, id) &#123; ...&#125; jsdoc을 설치하고 아래 명령을 실행하면, out 폴더에 문서가 자동으로 생성됩니다. 12345npm install -g jsdocjsdoc image.js// 문서가 생성된다.open out/index.html","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"kue","slug":"Node-js/kue","permalink":"http://yoursite.com/categories/Node-js/kue/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"kue","slug":"kue","permalink":"http://yoursite.com/tags/kue/"}]},{"title":"Node-Passport","slug":"node-study-passport","date":"2017-09-19T03:54:00.000Z","updated":"2017-10-02T14:02:38.000Z","comments":true,"path":"2017/09/19/node-study-passport/","link":"","permalink":"http://yoursite.com/2017/09/19/node-study-passport/","excerpt":"","text":"Passport TutorialPassport는 다양한 인증 수단을 지원할 수 있도록 추상화된 인증 미들웨어입니다. 전통적인 웹 개발에서는 사용자 이름과 암호를 이용해 인증을 하는 방식이 대부분이었지만 최근에는 다양한 인증 제공자(Facebook, Twitter, Google 등)를 통한 인증이 많이 활용되는 추세입니다. 그런데 여러 인증 제공자를 활용하기 위해 각각의 인증 제공자를 위한 서버 코드를 따로따로 작성하는 일은 개발자에게는 힘든 작업일 것입니다. Passport를 사용하면 어떤 인증 방식을 사용하건 간에 통일된 방식으로 인증 절차를 정의할 수 있습니다. Passport가 강제하는 방식으로 인증을 하게 되면, 다양한 인증 수단을 활용하기 위해 필요한 구현 비용이 많이 줄어듭니다. StrategyPassport는 인증 절차를 정의하기 위해 strategy라는 개념을 사용합니다. 특정 인증 방식에 대해 정해진 방식대로 strategy를 구현하기만 하면, express와 같은 웹 서버와 쉽게 연동할 수 있습니다. 다양한 인증 방식을 위한 strategy가 이미 준비되어 있습니다. Strategy 마다 구현 방법이 조금씩 다르니, 자세한 구현 방법은 해당 strategy의 문서를 참고해주세요. 아래는 사용자 이름과 암호를 사용하는 인증 절차를 나타내는 passport-local strategy 예제입니다. 1234567891011121314151617// passport가 \"사용자 이름과 암호 기반 인증\"을 수행하도록 strategy 등록passport.use(new LocalStrategy((username, password, done) =&gt; &#123; query.compareUser(username, password) .then(user =&gt; &#123; // 인증 성공 done(error, 성공값) done(null, user) &#125;) .catch(err =&gt; &#123; if (err instanceof query.LoginError) &#123; // 인증 실패: 사용자 책임 done(null, false, &#123;message: err.message&#125;) &#125; else &#123; // 인증 실패: 서버 책임 done(err) &#125; &#125;)&#125;)) passport.authenticate()위에서 구현한 strategy를 이용해 passport가 인증을 위한 라우트 핸들러를 생성하게 할 수 있습니다. 즉 위에서 strategy를 만들면 passport의 method를 사용할 수 있다. 123456// passport-local을 통해 생성한 라우트 핸들러app.post('/login', passport.authenticate(('local'), &#123; successRedirect: '/', // 인증 성공 시 리다이렉트시킬 경로 failureRedirect: '/login', // 인증 실패 시 리다이렉트시킬 경로 failureFlash: '아이디 혹은 패스워드가 잘못되었습니다.' // 인증 실패 시 표시할 메시지&#125;)) stategy구현과 authenticate는 1개의 세트로 보며 만약 네이버, 구글, 다음으로 로그인 하고 싶다면 3세트를 구현해주어야한다. serializeUser, deserializeUser프로그램 상의 어떤 객체를 바이너리 혹은 텍스트의 형태로 변환하는 작업을 직렬화(serialization), 그 반대를 역직렬화(deserialization)라고 합니다. 세션을 이용한 인증을 할 때, 일반적으로 user 객체를 대표하는 특정 속성(id 혹은 username)을 세션에 저장하는 작업을 합니다. 또한 세션에 들어있는 유저 정보를 통해 데이터베이스에서 user 객체를 얻어오는 작업도 합니다. 이 또한 각각 직렬화, 역직렬화라고 할 수 있을 것입니다. passport는 사용 중인 인증 방식에 관계없이 통일된 방식으로 직렬화/역직렬화를 하도록 강제합니다. 이를 따르면 여러 인증 방식을 사용하더라도 문제 없이 세션에 인증 정보를 저장하고 세션으로부터 인증 정보를 추출할 수 있습니다. req.user에다가 passport가 값을 넣어주는 작업을 한다. 이 작업은 위의 세트와 다르게 1번만 구현하면 다른 방식으로 로그인 하는 것도 대응 가능하다. 12345678910111213141516// passport가 유저 정보를 세션에 저장할 수 있도록 직렬화passport.serializeUser((user, done) =&gt; &#123; done(null, user.id)&#125;)// passport가 세션으로부터 유저 객체를 가져올 수 있도록 역직렬화passport.deserializeUser((id, done) =&gt; &#123; query.getUserById(id) .then(user =&gt; &#123; if (user) &#123; done(null, user) // req.user에 저장됨 &#125; else &#123; done(new Error('해당 아이디를 가진 사용자가 없습니다.')) &#125; &#125;)&#125;) req.login, req.logoutreq.login(user)는 user 객체를 직렬화한 뒤 세션에 저장해서, 해당 세션을 로그인시키는 메소드입니다. passport.authenticate 메소드가 생성한 라우트 핸들러를 사용한다면, 이 라우트 핸들러 안에서 req.login 메소드가 호출되기 때문에 따로 로그인을 시켜줄 필요는 없습니다. 보통 req.login 메소드는 아래와 같이 회원 가입 이후에 자동으로 로그인을 시켜주려는 목적으로 사용됩니다. 1234567891011121314app.post('/register', (req, res, next) =&gt; &#123; query.createUser(req.body.username, req.body.password) .then(user =&gt; &#123; // 회원 가입 시 자동으로 로그인 시키고 리다이렉트 req.login(user, err =&gt; &#123; if (err) &#123; next(err) &#125; else &#123; res.redirect('/') &#125; &#125;) &#125;) .catch(util.flashError(req, res))&#125;) req.logout 메소드는 현재 세션에 들어있는 인증 정보를 지우고 로그아웃을 시키는 메소드입니다. 아래와 같이 사용할 수 있습니다. 12345app.post('/logout', (req, res) =&gt; &#123; // passport가 제공하는 `req.logout` 메소드 req.logout() res.redirect('/login')&#125;) passport.initialize()Express 앱에서 Passport를 사용하기 위해서는 다음과 같이 미들웨어를 주입해주어야 합니다. 인증 과정에서 세션을 사용하지 않는다면 passport.session()은 주입하지 않아도 무방합니다.123// passport 관련 미들웨어 삽입app.use(passport.initialize())app.use(passport.session())","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Passport","slug":"Node-js/Passport","permalink":"http://yoursite.com/categories/Node-js/Passport/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Passport","slug":"Passport","permalink":"http://yoursite.com/tags/Passport/"}]},{"title":"Node-OAuth","slug":"node-study-oauth","date":"2017-09-19T03:54:00.000Z","updated":"2017-10-04T11:40:04.000Z","comments":true,"path":"2017/09/19/node-study-oauth/","link":"","permalink":"http://yoursite.com/2017/09/19/node-study-oauth/","excerpt":"","text":"OAuth TutorialWPSN OAuth 튜토리얼최근에 웹을 사용한 경험이 있는 분들은 대부분 “페이스북으로 로그인” 버튼을 한 번 쯤 사용해보셨을 겁니다. 이 때 사용되는 인증 절차가 바로 OAuth입니다. OAuth가 사용되기 전에는 인증 방식의 표준이 없었기 때문에, 회사들마다 각자의 인증 방식을 사용했습니다. 이렇게 제각각이던 인증 방식을 표준화한 것이 바로 OAuth입니다. OAuth는 현재 2.0 버전까지 나와있는 상태로, 유명한 소셜 네트워크나 API 제공자들은 대부분 OAuth 2.0을 지원하고 있습니다. OAuth를 사용하면 사용자의 아이디와 암호가 노출되지 않도록 하면서도 애플리케이션에 API 접근 권한을 안전하게 위임할 수 있습니다. OAuth 역할OAuth 인증 과정에 참여하는 역할들이 아래에 나와있습니다. ex) Trello에 Google id로 로그인한다. 자원 소유자OAuth를 통해 보호되고 있는 자원을 소유하고 있는 자원의 실제 소유자입니다. 웹 애플리케이션의 사용자입니다. 보통의 경우 사람을 나타낸다. google로 로그인한 나를 나타낸다. 자원 서버사용자 소유의 자원을 제공하는 서버. API 서버라고 봐도 무방합니다. google 서버를 나타낸다. 인증 서버소규모 서비스의 경우 자원 서버와 같은 서버에 위치해있는 경우가 많습니다. google 서버를 나타낸다. 클라이언트OAuth를 통해 보호되고 있는 자원에 사용자 대신 접근하려고 하는 주체를 말합니다. 보통 자원 서버가 제공하는 API를 사용하려고 하는 웹 애플리케이션 서버를 가리킵니다. Trello이다 why? 나를 대신해서 google 계정으로 로그인하기 때문이다. OAuth 2.0 Server-side FlowOAuth 2.0에는 다양한 형태의 인증 절차가 준비되어 있습니다만, 보통 Server-side Flow 방식을 많이 사용합니다. Server-side Flow 방식의 절차는 아래 그림과 같습니다. Client도 Authorization Server에다가 등록을 해줘야한다. 사용자(자원 소유자)는 웹 애플리케이션(OAuth 클라이언트)에 인증 시작을 위한 요청을 보낸다. 웹 애플리케이션은 인증 서버로 사용자의 웹 브라우저를 리다이렉트 시킨다. (OAuth 클라이언트 정보가 포함됨) 사용자는 인증 서버에서 보여주는 화면을 통해 웹 애플리케이션이 요구하는 권한을 확인하고, 웹 애플리케이션이 본인 대신에 인증 정보를 활용할 수 있도록 허가한다. 인증 서버는 사용자의 웹 브라우저를 다시 웹 애플리케이션으로 리다이렉트 시킨다 (인증 코드 포함) 웹 애플리케이션은 인증 코드를 포함시킨 요청을 인증 서버에 보내고, 액세스 토큰을 응답받는다. 웹 애플리케이션은 이제부터 액세스 토큰을 이용해 자원 서버를 사용할 수 있게 된다. 보통 가장 처음으로 사용자에 대한 정보를 가져온다. 해당 사용자 정보를 이용해 성공적으로 인증이 되었다는 사실을 사용자에게 보여준다. 사용자는 웹 애플리케이션을 통해서 자원 서버에 저장되어 있는 정보를 활용할 수 있게 된다. OAuth의 구현위에서 보셨다시피 OAuth를 통한 인증을 직접 구현하기에는 그 절차가 굉장히 복잡합니다. 다행히, 유명한 인증 제공자(Google, Facebook, Twitter 등)에 대해서는 npm에 미리 준비되어 있는 Passport strategy만 구현을 함으로써, 애플리케이션에 OAuth 인증을 쉽게 추가할 수 있습니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"OAuth","slug":"Node-js/OAuth","permalink":"http://yoursite.com/categories/Node-js/OAuth/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"OAuth","slug":"OAuth","permalink":"http://yoursite.com/tags/OAuth/"}]},{"title":"Node-CSRF","slug":"node-study-csrf","date":"2017-09-18T03:54:00.000Z","updated":"2017-10-01T09:59:33.000Z","comments":true,"path":"2017/09/18/node-study-csrf/","link":"","permalink":"http://yoursite.com/2017/09/18/node-study-csrf/","excerpt":"","text":"CSRF 예제CSRF(Cross-site Request Forgery, 사이트 간 요청 위조)는 사용자가 악의적인 웹 페이지에 접속했을 때 해당 웹 페이지에서 다른 서버로 요청을 보내어 정보를 조작하는 공격 기법입니다. 전통적인 웹 개발에서 자주 일어나는 보안 사고입니다. (2008년 옥션 개인정보 유출 사건을 참고하세요.) URL shotener 서버로 CSRF 공격을 시험해볼 수 있습니다. 로컬 서버를 켜고 상단의 Show 버튼으로 웹 페이지를 열어 요청을 보내보세요. CSRF 공격이 가능한 이유는 웹 서버로 오는 요청이 어떤 웹 페이지에서 출발했던 간에 쿠키가 자동으로 포함되어 오기 때문입니다. (Ajax 요청은 제외) 이렇게 쿠키는 편하긴 하지만 잘못 다루었을 경우에 보안에 심각한 위협이 될 수 있습니다. CSRF 공격을 방어하기 위해서는, 사용자가 우리 웹 페이지에 접속하지 않고는 데이터를 조작하는 요청(POST)을 보낼 수 없게만들어야 합니다. 이를 위해 우리 웹 페이지에 접속해야만 받을 수 있는 정보(이를 CSRF 토큰이라 부릅니다)를 요청에 포함시켜 보냄으로써 CSRF 공격을 방어할 수 있습니다. express 기반 웹 사이트에서는 csurf 미들웨어를 사용해 CSRF 공격을 방어할 수 있습니다. CRURF 123456789101112131415161718192021222324var cookieParser = require('cookie-parser')var csrf = require('csurf')var bodyParser = require('body-parser')var express = require('express') // setup route middlewares var csrfProtection = csrf(&#123; cookie: true &#125;)var parseForm = bodyParser.urlencoded(&#123; extended: false &#125;) // create express app var app = express() // parse cookies // we need this because \"cookie\" is true in csrfProtection app.use(cookieParser()) app.get('/form', csrfProtection, function(req, res) &#123; // pass the csrfToken to the view res.render('send', &#123; csrfToken: req.csrfToken() &#125;)&#125;) app.post('/process', parseForm, csrfProtection, function(req, res) &#123; res.send('data is being processed')&#125;) 123456&lt;form action=\"/process\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"_csrf\" value=\"&lt;%= csrfToken %&gt;\"&gt; Favorite color: &lt;input type=\"text\" name=\"favoriteColor\"&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt; csrf는 cookie session을 사용할때 문제가 된다. jwt를 사용할때는 csrf는 필요가 없다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"CSRF","slug":"Node-js/CSRF","permalink":"http://yoursite.com/categories/Node-js/CSRF/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"CSRF","slug":"CSRF","permalink":"http://yoursite.com/tags/CSRF/"}]},{"title":"Node-Knex-Seed","slug":"node-study-knex-seed","date":"2017-09-18T03:54:00.000Z","updated":"2017-10-01T10:00:24.000Z","comments":true,"path":"2017/09/18/node-study-knex-seed/","link":"","permalink":"http://yoursite.com/2017/09/18/node-study-knex-seed/","excerpt":"","text":"SEED기존의 seed.js로 데이터베이스의 값을 넣는 것이아닌 knex의 seed로 값을 넣어본다. 기존 seed.js12345678910111213141516171819const faker = require('faker')const randomstring = require('randomstring')const knex = require('./knex')knex('user') .insert(&#123; id: 'fast', password: 'campus' &#125;) .then(() =&gt; &#123; for(var i = 0; i &lt; 20; i++)&#123; knex('url_entry') .insert(&#123; id: randomstring.generate(8), long_url: faker.internet.url(), user_id: 'fast' &#125;).then(console.log) &#125; &#125;) seeds 생성방법seed 명령어12345// seed file을 만드는 명령어$ knex seed:make initial_data// seed 실행 명령어$ knex seed:run 변경된 seeds/initial_data.js 123456789101112131415161718192021222324252627282930const faker = require('faker')const randomstring = require('randomstring')// 값이 실행되어서 이 파일의 작업이 끝나는 것에 대해서 알려줘야한다.exports.seed = function(knex, Promise) &#123; // Deletes ALL existing entries return knex('user') .insert(&#123; id: 'kim', password: 'sejune' &#125;) .then(() =&gt; &#123; const arr = [] for(var i = 0; i &lt; 20; i++)&#123; arr.push( knex('url_entry') .insert(&#123; id: randomstring.generate(8), long_url: faker.internet.url(), user_id: 'kim' &#125;) ) &#125; return Promise.all(arr) // promise는 어떤값을 감싸고 있는데 그 값을 then을 사용해서 사용할 수 있다. // 단 return하는 것이 그냥 값이면 then에서는 그 값을 사용할 수 있다. // 여기서 다음에 등장하는 then에는 arr를 사용할 수 있다. &#125;)&#125;","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"knex","slug":"Node-js/knex","permalink":"http://yoursite.com/categories/Node-js/knex/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"kenx","slug":"kenx","permalink":"http://yoursite.com/tags/kenx/"}]},{"title":"Node-CSRF","slug":"node-study-socketio","date":"2017-09-18T03:54:00.000Z","updated":"2017-10-01T10:02:19.000Z","comments":true,"path":"2017/09/18/node-study-socketio/","link":"","permalink":"http://yoursite.com/2017/09/18/node-study-socketio/","excerpt":"","text":"SocketIO초기의 HTTP는 실시간 전송이 안되었어서 초기에는 실시간처럼 보이는 Long Polling와 comet이라는 응답을 서버가 결정을 하는 기술을 사용하였다.현재는 WebSocketIO를 표준으로 사용하고 있다. WebSocketIO HandShake WebSocketIO는 client가 server에게 websocket이라고 요청을 보낸다. server가 지원을 해주면 연결을 한다. HTTP의 요청응답을 넘어서 server, client가 서로가 필요할때 바로 정보를 요청 및 전달한다. websocket연결을 보기위해서는 검사tab의 Frames로 확인 할 수 있다. Socket.io SocketIO 예제Socket.io는 실시간 웹을 위한 JS 라이브러리입니다. 기존의 웹은 클라이언트(브라우저)가 요청을 해야만 서버로부터 데이터를 받을 수 있었던 데 반해, Socket.io와 같은 기술을 사용하면 클라이언트가 요청을 하지 않아도 필요할 때 서버로부터 데이터를 받을 수 있습니다. 이를 이용하면, 채팅이나 실시간 차트 혹은 실시간 알림을 지원하는 웹 어플리케이션을 작성할 수 있습니다. Socket.io는 실시간 통신을 위해 주로 WebSocket이라는 웹 표준 기술을 사용하지만, 구형 웹브라우저 등 WebSocket을 지원하지 않는 환경에서는 다른 기술을 사용할 수도 있습니다. (long polling, comet 등) 다른 일반적인 웹소켓 서버와는 호환이 되지 않으므로 주의하세요. 123456789101112131415161718192021222324//index.js// DOMContentLoaded html이 다 loading되었을 때 실행되게 한다.document.addEventListener('DOMContentLoaded', () =&gt; &#123; const socket = io() socket.on('response', data =&gt; &#123; console.log(`$&#123;data.message&#125; @ $&#123;new Date&#125;`) &#125;) // emit : 우리가 맺은 socketio에다가 message라는 이름의 event를 발생시켜라 거기에 이런 데이터를 포함시켜라 document.querySelector('#message').addEventListener('click', e =&gt; &#123; socket.emit('message', &#123;message: '간단한 메시지를 이렇게 보낼 수 있습니다.'&#125;) &#125;) document.querySelector('#message-and-ack').addEventListener('click', e =&gt; &#123; socket.emit('messageAndAck', &#123;message: '메시지를 보낸 후에 서버에서 응답을 받을 수도 있습니다'&#125;, data =&gt; &#123; console.log(data) &#125;) &#125;) document.querySelector('#broadcast').addEventListener('click', e =&gt; &#123; socket.emit('broadcast', &#123;message: '다른 클라이언트에게만 가는 메시지도 보낼 수 있습니다.'&#125;) &#125;)&#125;) index.js에 있는 message event가 발생하고 client에게 server.js에서 response event를 발생을 하면 index.js에서 response를 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// server.jsconst express = require('express')const http = require('http') // express를 사용하려면 http를 써야한다.const socketio = require('socket.io')const app = express()const server = http.Server(app)const io = socketio(server)app.set('view engine', 'pug')app.use(express.static('public'))app.get(\"/\", (req, res) =&gt; &#123; res.render('index.pug')&#125;)app.get('/namespace', (req, res) =&gt; &#123; res.render('namespace.pug')&#125;)app.get('/room/:id', (req, res) =&gt; &#123; res.render('room.pug', &#123;id: req.params.id&#125;)&#125;)/*# 서버 측 API## 사전 정의된 이벤트 목록- 'connect' 혹은 'connection': 클라이언트가 새 연결을 맺었을 때- 'disconnect': 클라이언트의 연결이 끊어졌을 때- 'error': 에러가 발생했을 때- 'disconnecting': 클라이언트가 연결을 끊기 직전에*/io.on('connection', socket =&gt; &#123; // Simple Message socket.on('message', data =&gt; &#123; // 현재 네임스페이스에 접속 중인 모든 클라이언트에게 메시지 보내기 io.emit('response', data) &#125;) // Acknowledgement socket.on('messageAndAck', (data, ack) =&gt; &#123; io.emit('response', data) // 메시지를 보낸 클라이언트에게만 회신하기 ack(&#123;ok: true&#125;) &#125;) // Broadcast socket.on('broadcast', data =&gt; &#123; // 메시지를 보낸 클라이언트를 제외한 모든 클라이언트에게 메시지 보내기 socket.broadcast.emit('response', data) &#125;)&#125;)// Custom Namespace 통신을 격리하기 위해서 사용한다. -&gt; namespace.jsconst someNsp = io.of('/some-namespace')someNsp.on('connection', socket =&gt; &#123; socket.on('message', data =&gt; &#123; someNsp.emit('response', data) &#125;)&#125;)// Roomconst roomNsp = io.of('/room')/*room은 동적으로 지정할 수 있는 통신의 분리 단위입니다.하나의 소켓은 여러 개의 room에 들어갈 수 있습니다.*/roomNsp.on('connection', socket =&gt; &#123; let id; socket.on('join', data =&gt; &#123; // `socket.join`을 호출해서 특정 room에 진입합니다. socket.join(data.id) id = data.id &#125;) socket.on('message', data =&gt; &#123; // `socket.to`는 이벤트 방출을 특정 room에 한정시킵니다. roomNsp.to(id).emit('response', data) &#125;)&#125;)const listener = server.listen(process.env.PORT, function () &#123; console.log('Your app is listening on port ' + listener.address().port)&#125;) 접속한 사람마다 각자의 socket객체를 생성 해준다. 사전 정의된 이벤트 목록SocketIo의 기본 이벤트 목록 &#39;connect&#39; 혹은 &#39;connection&#39;: 클라이언트가 새 연결을 맺었을 때 &#39;disconnect&#39;: 클라이언트의 연결이 끊어졌을 때 &#39;error&#39;: 에러가 발생했을 때 &#39;disconnecting&#39;: 클라이언트가 연결을 끊기 직전에 server.js에서 socket.emit는 자기자신에게만 보내진다. io.emit는 접속한 전부에게 보내진다. 1234567891011121314// namespace.jsdocument.addEventListener('DOMContentLoaded', () =&gt; &#123; // 특정 namespace에 대한 연결 수립 const socket = io('/some-namespace') socket.on('response', data =&gt; &#123; console.log(`$&#123;data.message&#125; @ $&#123;new Date&#125;`) &#125;) document.querySelector('#message').addEventListener('click', e =&gt; &#123; socket.emit('message', &#123;message: '특정한 이름공간에 접속할 수 있습니다. 통신은 다른 이름공간과 분리됩니다.'&#125;) &#125;)&#125;) namespace는 미리 만들어진 방에서 격리할 때 사용한다.roomspace는 동적으로 변경되는 방에서 격리할 때 사용한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"SocketIO","slug":"Node-js/SocketIO","permalink":"http://yoursite.com/categories/Node-js/SocketIO/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"SocketIO","slug":"SocketIO","permalink":"http://yoursite.com/tags/SocketIO/"}]},{"title":"Node-MongoDB","slug":"node-study-mongodb","date":"2017-09-17T03:54:00.000Z","updated":"2017-10-04T11:42:27.000Z","comments":true,"path":"2017/09/17/node-study-mongodb/","link":"","permalink":"http://yoursite.com/2017/09/17/node-study-mongodb/","excerpt":"","text":"Node mongoDBMEAN Stack = MongoDB + Express + Angular + Node IT (Information Technology) 저장 : 데이터 저장소 처리 : 프로그래밍 언어 (1) MongoDB 란?몽고DB(MongoDB) 크로스 플랫폼 : window, linux, mac 전부다 가능하다. 도큐먼트(JSON과 같은 동적 스키마형 문서) 지향 NoSQL 데이터베이스 시스템 : NonSQL SQL외에 다른것도 사용한다. Readys방식 =&gt; 키:값 MongoDB =&gt; 문서기반(JSON) : Java Script Object Notation BigData =&gt; 컬럼패밀리 Graph 오픈소스(Open Source) C++로 작성됨 높은 확장성 높은 성능 더 쉽고 더 빠르게 데이터 통합 가능 NoSQLNoSQL 데이터베이스는 전통적인 관계형 데이터베이스 보다 덜 제한적인 일관성 모델을 이용하는 데이터의 저장 및 검색을 위한 매커니즘을 제공한다.이러한 접근에 대한 동기에는 디자인의 단순화, 수평적 확장성, 세세한 통제를 포함한다.NoSQL 데이터베이스는 단순 검색 및 추가 작업을 위한 매우 최적화된 키 값 저장 공간으로, 레이턴시와 스루풋과 관련하여 상당한 성능 이익을 내는 것이 목적이다.NoSQL 데이터베이스는 빅데이터와 실시간 웹 애플리케이션의 상업적 이용에 널리 쓰인다.또, NoSQL 시스템은 SQL 계열 쿼리 언어를 사용할 수 있다는 사실을 강조한다는 면에서 “Not only SQL”로 불리기도 한다. (위키백과) 데이터 저장소에 대한 CAP 이론CAP 정리, 또는 브루어의 정리(Brewer -)는, 다음과 같은 세 가지 조건을 모두 만족하는 분산 컴퓨터 시스템이 존재하지 않음을 증명한 정리이다. 일관성(Consistency): 모든 노드가 같은 순간에 같은 데이터를 볼 수 있다. 가용성(Availability): 모든 요청이 성공 또는 실패 결과를 반환할 수 있다. 분할내성(Partition tolerance): 메시지 전달이 실패하거나 시스템 일부가 망가져도 시스템이 계속 동작할 수 있다. 위의 세 가지 조건의 첫 글자를 따서 CAP 정리라고 부른다.2000년 전산학자 에릭 브루어가 이 명제를 가설로서 제시하였고, 2002년 세스 길버트와 낸시 린치가 이를 증명하였다. CAP정리에 따르면 분산 시스템이 추구하는 데이터의 특성은 세 가지 중 두가지만 보장할 수 있다. CA 분류 (일관성 +가용성) : 전통적인 RDBMS. 트랜잭션.CP 분류 (가용성 + 분할용인) : 구글의 BigTable, HBase 등AP 분류 (가용성 + 분할용인) : Dynamo, Cassandra, MongoDB 등 (2) MongoDB 설치 mongoDB 설치 1&gt; brew install mongodb data/db 폴더 생성```sudo mkdir -p data/db data/db로 이동 후 sudo chown kimsejune /data/db mongoDB를 실행시키는 명령어 : 서버의 역할을 한다.mongod 클라이언트의 역할 실행 명령어 mongo showdbs // 서버, 클라이언트 정보 확인 db.member.insert({ “id”:”hong”, “email”:”tpwns1088@gmail.com”});// mongoDB에 값을 추가하는 명령어 db.member.find()// mongoDB의 member값을 찾는다.``` GUI Tool : RoboMongo (3) 관계형 데이터베이스와 몽고디비 비교 RDBMS MongoDB Database Database Table Collection Row Document Column Key Primary Key ObjectId(_id) RDBMS 명령과 MongoDB 함수 비교 &gt; InsertSQL : insert into members (“name”,”email”) values(“홍길동”,”hong@aaa.com”)Mongo DB : db.members.insert({name:”hong”, email:”hong@aaa.com”}) SelectSQL : select * from members where name=”홍길동”Mongo DB : db.members.find({name:”홍길동”}) UpdateSQL : update members set email=”hong@aaa.com” where name=”홍길동”Mongo DB : db.members.update( {name:”홍길동”}, {$set :{email:”hong@aaa.com”} } ) DeleteSQL : delete from members where name=”홍길동”Mongo DB : db.members.remove({name:”홍길동”}) (4) REST API와 몽고 디비 연동 이해 HTTP METHOD 역할 MongoDB 함수 POST 리소스를 생성 insert, save GET 리소스를 조회 find PUT 리소스를 수정 update DELETE 리소스를 삭제 delete (5) MEAN 스택 미니 프로젝트MongoDB : 문서 기반의 NoSQL 데이터베이스.ExpressJS : Node.js에서 가장 널리 쓰이는 웹 프레임워크.AngularJS : 구글에서 개발한 MVC 기반 클라이언트 측 자바스크립트 프레임워크.Node.js : 자바스크립트 엔진 기반의 웹 서버. Asyncawait version이 낮은 node에서 callback hell을 방지한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"mongoDB","slug":"Node-js/mongoDB","permalink":"http://yoursite.com/categories/Node-js/mongoDB/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"mongoDB","slug":"mongoDB","permalink":"http://yoursite.com/tags/mongoDB/"}]},{"title":"Node-Knex-Migration","slug":"node-study-knex-migration","date":"2017-09-15T03:54:00.000Z","updated":"2017-10-01T09:47:48.000Z","comments":true,"path":"2017/09/15/node-study-knex-migration/","link":"","permalink":"http://yoursite.com/2017/09/15/node-study-knex-migration/","excerpt":"","text":"Node knex MigrationSchema AlterMigration하는 방법 123$ npm install knex -g$ knex init knexfile.js가 생성된다 이것으로 앞으로 migration을 한다.(초기모습) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//knexfile.js// Update with your config settings.module.exports = &#123; // 개발단계 development: &#123; client: 'sqlite3', connection: &#123; filename: './dev.sqlite3' &#125; &#125;, staging: &#123; client: 'postgresql', connection: &#123; database: 'my_db', user: 'username', password: 'password' &#125;, pool: &#123; min: 2, max: 10 &#125;, migrations: &#123; tableName: 'knex_migrations' &#125; &#125;, production: &#123; client: 'postgresql', connection: &#123; database: 'my_db', user: 'username', password: 'password' &#125;, pool: &#123; min: 2, max: 10 &#125;, migrations: &#123; tableName: 'knex_migrations' &#125; &#125;&#125;; development, staging, production 3가지로 구성되어있다. NODE_ENV=production node src/index.js형식으로 실행을 한다 production값을 변경가능하며 default값은 development이다. debug는 devlopment에서는 사용하고 product에서는 사용하지 않는다. 각자의 환경에서 설치할 수 있는데 개발에서 사용되는 패키지를 운영에다가 넣을 필요가없으니 개발환경에서만 사용하는 것은 --save-dev로 설치해둔다. test, faker같은 것을 –save-dev로 설치해둔다. knexfile.js 적용모습 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Update with your config settings.require('dotenv').config()module.exports = &#123; development: &#123; client: 'mysql', connection: &#123; host: process.env.DATABASE_HOST, user: process.env.DATABASE_USER, password: process.env.DATABASE_PASSWORD, database: process.env.DATABASE_NAME &#125;, debug: true &#125;, staging: &#123; client: 'postgresql', connection: &#123; database: 'my_db', user: 'username', password: 'password' &#125;, pool: &#123; min: 2, max: 10 &#125;, migrations: &#123; tableName: 'knex_migrations' &#125; &#125;, production: &#123; client: 'postgresql', connection: &#123; database: 'my_db', user: 'username', password: 'password' &#125;, pool: &#123; min: 2, max: 10 &#125;, migrations: &#123; tableName: 'knex_migrations' &#125; &#125;&#125;; Knex Migration 생성법1$ knex migrate:make migration_name migrations라는 폴더에 migration_name 파일이 생긴다. up : 데이터베이스를 변경하는데 사용한다. down : 변경된 값을 되돌리는데 사용한다. migration을 사용하여서 table을 생성하는 방법 1&gt; knex migrate:latest 1번 더 같은 명령어를 실행하면 이미 저장되어있다고 알려준다. migration 취소방법 1&gt; knex migrate:rollback migration은 한번 할 때 한번씩 하는 것이 좋다.(작은 단위로 실행을 추천) 이제 schema.js는 필요가 없게 되었다. 123456789101112131415// schema.jsconst knex = require('./knex')knex.schema.createTable('user', t =&gt; &#123; t.string('id').primary() t.string('password').notNullable()&#125;).then(() =&gt; knex.schema.createTable('url_entry', t =&gt; &#123; t.string('id', 8).primary() t.string('long_url').notNullable() t.string('user_id') t.foreign('user_id').references('user.id') t.timestamp('created_at').defaultTo(knex.fn.now())&#125;)).then(process.exit)// 실행 node src/schema.js 하면 DB에 생성된다. 변경 후 migrationfile 123456789101112131415161718192021222324252627282930// add_user.js &lt;migration file&gt;exports.up = function(knex, Promise) &#123; // return은 promise가 끝난 여부를 판단하기 때문이다. return knex.schema.createTable('user', t =&gt; &#123; t.string('id').primary() t.string('password').notNullable() &#125;)&#125;;exports.down = function(knex, Promise) &#123; // usertable을 되돌리는 코드 작성 return knex.schema.dropTable('user')&#125;;// url_entry.js &lt;migration file&gt;exports.up = function(knex, Promise) &#123; return knex.schema.createTable('url_entry', t =&gt; &#123; t.string('id', 8).primary() t.string('long_url').notNullable() t.string('user_id') t.foreign('user_id').references('user.id') t.timestamp('created_at').defaultTo(knex.fn.now()) &#125;)&#125;;exports.down = function(knex, Promise) &#123; return knex.schema.dropTable('url_entry')&#125;; Database 동시성 문제접속한 링크에 count를 1씩 올릴때 동시에 1000번의 요청을 보낼 경우에 값을 제대로 반영을 못한다는 문제가 발생한다. 아래의 예를 보면 알 수 있다. 1234567891011121314151617181920212223// query.js saveClickCountById(id, click_count) &#123; return knex('url_entry') .where(&#123;id&#125;) .update(&#123;click_count&#125;) &#125;// index.jsapp.get('/:id', (req, res, next) =&gt; &#123; query.getUrlById(req.params.id) .then(urlEntry =&gt; &#123; if(urlEntry)&#123; query.saveClickCountById(urlEntry.id, urlEntry.click_count+1) .then(() =&gt; &#123; res.redirect(urlEntry.long_url) // 301 moved~~ 영원히 이동한다 (브라우저에 저장) , 302 브라우저에 저장안하고 다시보낸다. // res.redirect(301, entry.long_url)를 해야하지만 사람들이 얼마나 클릭했는지 확인하기 위해서 301을 뺐다. &#125;) &#125;else &#123; next() &#125; &#125;)&#125;) 값을 업데이트하기전에 계속 값이 덮어씌어지는 문제가 발생한다. 해결방법 잠금 =&gt; 성능이 느려진다. DeadLock이 발생할 확률이 생긴다. Atomic Update 원자적 갱신 명령을 내릴 때 자동으로 증가시킨다. knex의 .increment를 사용한다. 12345678910111213141516171819202122// query.js incrementClickCountById(id) &#123; return knex('url_entry') .where(&#123;id&#125;) .increment('click_count', 1) &#125;// index.jsapp.get('/:id', (req, res, next) =&gt; &#123; query.getUrlById(req.params.id) .then(urlEntry =&gt; &#123; if(urlEntry)&#123; query.incrementClickCountById(urlEntry.id) // Atomic Update를 적용한 상태이다. .then(() =&gt; &#123; res.redirect(urlEntry.long_url) // 301 moved~~ 영원히 이동한다 (브라우저에 저장) , 302 브라우저에 저장안하고 다시보낸다. // res.redirect(301, entry.long_url)를 해야하지만 사람들이 얼마나 클릭했는지 확인하기 위해서 301을 뺐다. &#125;) &#125;else &#123; next() &#125; &#125;)&#125;) Atomic Update를 하면 데이터베이스에 접속해서 가져오는 것이 아닌 바로 값을 올려버리기 때문에 제대로 값이 나타난다. bcrypt를 사용한 보안bcrypt 12345678910111213&gt; npm install --save bcrypt&gt; node&gt; bcrypt = require('bcrypt')&gt; bcrypt.hashSync('campus', 10) # 2의 10승이다.&gt; hash = bcrypt.hashSync('campus', 10) # hash에다가 값을 담아둔다# 비교방법&gt; bcrypt.compareSync('campus', hash) # 정확하게 일치해야지 true이다.true&gt; bcrypt.compareSync('campus1', hash)false To check a password123// Load hash from your password DB.bcrypt.compareSync(myPlaintextPassword, hash); // truebcrypt.compareSync(someOtherPlaintextPassword, hash); // false 동기의 방식을 사용하는 위에 script보다 아래의 방식이 좋다. 1234567// Load hash from your password DB.bcrypt.compare(myPlaintextPassword, hash).then(function(res) &#123; // res == true&#125;);bcrypt.compare(someOtherPlaintextPassword, hash).then(function(res) &#123; // res == false&#125;); npm validator많은 종류의 validation이 생성되어있으며 값이 맞는지 검증해주는 역할을 한다. 1&gt; npm install validator --save Error 처리방법Flash : error를 session 저장해두었다가 다음 요청이 왔을 때 error 메세지를 보여준다. 1&gt; npm install connect-flash --save session을 사용하면 여러 요청에 걸친 정보를 유지할 수 있다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"knex","slug":"Node-js/knex","permalink":"http://yoursite.com/categories/Node-js/knex/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"kenx","slug":"kenx","permalink":"http://yoursite.com/tags/kenx/"}]},{"title":"Node-Knex-Query-builder","slug":"node-study-knex-query-builder","date":"2017-09-14T03:54:00.000Z","updated":"2017-09-30T13:08:57.000Z","comments":true,"path":"2017/09/14/node-study-knex-query-builder/","link":"","permalink":"http://yoursite.com/2017/09/14/node-study-knex-query-builder/","excerpt":"","text":"Node KnexKnex - Query BuilderKnex 인스턴스 생성Knex를 이용해 MySQL 서버에 접속하기 위해서는 일단 아래와 같이 Knex 인스턴스를 만들어야 합니다. 123456789module.exports = require('knex')(&#123; client: 'mysql', connection: &#123; host: 'localhost', user: 'root', // 실제 서비스에서는 root 계정을 사용하지 않는 것이 좋습니다. password: 'rootpassword', database: 'employees' &#125;&#125;) 확인방법12$ node&gt; knex = require('./src/knex') Connection PoolKnex 인스턴스를 생성하면 connection pool이 만들어집니다. 한 번에 여러 커넥션을 맺어 놓는다는 의미. 그래서 해당 커넥션을 이용합니다. 인스턴스 생성 시 별도의 옵션을 주지 않는다면 커넥션 풀은 2개의 커넥션으로 시작하며, 필요에 의해 10개까지 늘어날 수 있습니다. 자세한 설정은 공식문서를 Knex를 이용한 쿼리 수행이제부터 Knex 인스턴스를 이용해 쿼리를 날릴 수 있습니다. 주의! 레코드가 수 십만 개 이상인 경우에는 결과를 받아오는 데 시간이 오래 걸리니 꼭 limit 메소드를 사용해주세요. 123456789101112131415knex('salaries').limit(3).then(console.log)// 결과[ &#123; emp_no: 10001, salary: 60117, from_date: 1986-06-25T15:00:00.000Z, to_date: 1987-06-25T14:00:00.000Z &#125;, &#123; emp_no: 10001, salary: 62102, from_date: 1987-06-25T14:00:00.000Z, to_date: 1988-06-24T14:00:00.000Z &#125;, &#123; emp_no: 10001, salary: 66074, from_date: 1988-06-24T14:00:00.000Z, to_date: 1989-06-24T15:00:00.000Z &#125; ] Knex 인스턴스는 메소드 체이닝 방식으로 사용하도록 만들어져 있습니다. 아래와 같이 메소드를 계속 이어붙이는 방식으로 쿼리를 빌드합니다. 123456789// 1위부터 10위까지의 최고 연봉자의 연봉과 first_name을 출력합니다.knex('employees') .select('first_name') .max('salary as max_salary') .join('salaries', 'employees.emp_no', 'salaries.emp_no') .groupBy('salaries.emp_no') .orderBy('max_salary', 'desc') .limit(10) .then(...) Knex 인스턴스는 표준 Promise가 아니라 자체 Promise 구현을 사용합니다. 이 구현의 특이한 점은 then 메소드를 호출하기 전까지는 SQL을 실행시키지 않는다는 것입니다. 위 성질을 이용해 then 메소드를 호출하지 않은 채로 toString 메소드를 호출하면, 쿼리를 실행시키기 전에 쿼리 빌더가 어떤 쿼리를 생성하는지 알 수 있습니다. 12knex('salaries').limit(3).toString()// select * from `salaries` limit 3 없는 테이블을 써도 생성은 된다. 그러나 실행은 안된다 꼭 실행시에 뒤에 .then을 해줘야한다. SELECTselect 메소드를 사용하면 원하는 컬럼만을 불러올 수 있습니다. 12345knex('salaries') .select('emp_no', 'salary') .limit(3) .toString()// select `emp_no`, `salary` from `salaries` limit 3 실제로 쿼리를 실행하면 아래와 같은 결과를 반환합니다. 123456789knex('salaries') .select('emp_no', 'salary') .limit(3) .then(console.log)// 결과[ &#123; emp_no: 10001, salary: 60117 &#125;, &#123; emp_no: 10001, salary: 62102 &#125;, &#123; emp_no: 10001, salary: 66074 &#125; ] select 메소드의 인자로 넘기는 문자열 뒤에 as를 붙여서, 반환되는 객체들의 속성 이름을 바꿀 수 있습니다. 123456789knex('salaries') .select('emp_no as e', 'salary as s') .limit(3) .then(console.log)// 결과[ &#123; e: 10001, s: 60117 &#125;, &#123; e: 10001, s: 62102 &#125;, &#123; e: 10001, s: 66074 &#125; ] distinct 메소드를 사용해 중복 제거를 할 수 있습니다. 123456789knex('employees') .distinct('first_name') .limit(3) .toString()/*select distinct `first_name` from `employees`limit 3*/ WHEREwhere 메소드를 이용해 WHERE 구문을 빌드할 수 있습니다. 12345678910knex('salaries') .where('emp_no', 20000) .limit(3) .toString()/*select * from `salaries`where `emp_no` = 20000limit 3*/ 아래와 같이 연산자를 사용할 수도 있습니다. 12345678910knex('salaries') .where('emp_no', '&gt;', 20000) .limit(3) .toString()/*select * from `salaries`where `emp_no` &gt; 20000limit 3*/ AND 연산자를 사용하기 위해 where 메소드를 여러 번 사용하거나, andWhere 메소드를 사용할 수 있습니다. 1234567891011121314knex('salaries') .where('emp_no', '&gt;', 20000) .where('salary', '&gt;', 150000) .andWhere('from_date', '&lt;', '1999-01-01') .limit(3) .toString()/*select * from `salaries`where `emp_no` &gt; 20000 and `salary` &gt; 150000 and `from_date` &lt; '1999-01-01'limit 3*/ 또는 where 메소드에 객체를 넘길 수도 있습니다. 1234567891011knex('employees') .where(&#123; first_name: 'Georgi', last_name: 'Facello' &#125;) .toString()/*select * from `employees`where `first_name` = 'Georgi' and `last_name` = 'Facello'*/ NOT 연산자를 사용하기 위해서 whereNot 메소드를 사용합니다. 12345678910knex('salaries') .whereNot('emp_no', '&gt;', 20000) .limit(3) .toString()/*select * from `salaries`where not `emp_no` &gt; 20000limit 3*/ OR 연산자를 사용하기 위해 orWhere 메소드를 사용할 수 있습니다. 또한 연산이 복잡한 경우에는 함수를 인자로 넘겨서 여러 where의 결합을 나타낼 수 있습니다. orWhere은 where와 같지만 or로 연결해주는 역할을 한다. 123456789101112131415161718192021knex('salaries') .where(function() &#123; // arrow function을 사용하면 안 됩니다! this .where('emp_no', '&gt;', 20000) .andWhere('salary', '&gt;', 150000) &#125;) .orWhere(function() &#123; this .where('emp_no', '&lt;', 11000) .andWhere('salary', '&lt;', 60000) &#125;) .limit(3) .toString()/*select * from `salaries`where (`emp_no` &gt; 20000 and `salary` &gt; 150000) or (`emp_no` &lt; 11000 and `salary` &lt; 60000)limit 3*/ 이 안에서는 errow function을 사용할 수 없다 why? this의 성격때문이다. error function에서 this는 한번 정해지면 바꿀수 없기 때문이다. 그 밖에 아래와 같은 메소드들이 있습니다. whereIn whereNotIn whereNull whereNotNull whereExists whereNotExists whereBetween whereNotBetween andWhereNot orWhereNot 자세한 사용법은 공식 문서를 참고해주세요. INSERT123456789101112131415161718192021knex('employees') .insert(&#123; emp_no: 876543, first_name: 'fast', last_name: 'campus', birth_date: '1960-01-01', hire_date: '1980-01-01', gender: 'M' &#125;) .toString()// 찾는 방법knex('employees').where('emp_no', 876543).then(console.log)// 방법2knex('employees').where(&#123;emp_no: 876543&#125;).then(console.log)/*insert into `employees` (`birth_date`, `emp_no`, `first_name`, `gender`, `hire_date`, `last_name`)values ('1960-01-01', 876543, 'fast', 'M', '1980-01-01', 'campus')*/ UPDATE12345678910knex('employees') .where(&#123;emp_no: 876543&#125;) .update(&#123;last_name: 'five'&#125;) .toString()/*update `employees`set `last_name` = \\'five\\'where `emp_no` = 876543*/ DELETE123456789knex('employees') .where(&#123;emp_no: 876543&#125;) .delete() .toString()/*delete from `employees`where `emp_no` = 876543*/ DELETE, UPDATE는 where절을 사용하지 않는다면 전체가 업데이트 or 삭제가 되니 꼭 where절을 사용해야한다. ORDER BYorderBy 메소드를 사용해서 ORDER BY 구문을 빌드할 수 있습니다. 1234567891011knex('employees') .orderBy('first_name', 'desc') .orderBy('last_name') .limit(3) .toString()/*select * from `employees`order by `first_name` desc, `last_name` asclimit 3*/ LIMIT, OFFSETlimit, offset 메소드를 사용해서 각각 LIMIT, OFFSET 구문을 빌드할 수 있습니다. limit : 위에서부터 개수만큼 offset : 100개를 건너뛰고나서부터 123456789knex('employees') .limit(3) .offset(100) .toString()/*select * from `employees`limit 3 offset 100*/ 집계함수Knex 인스턴스의 count, max, min, sum, avg 등의 메소드를 통해 집계함수를 빌드할 수 있습니다.1234567891011121314knex('salaries') .count('*') .toString()/*select count(*) as `c` from `salaries`*/knex('salaries') .max('salary') .toString()/*select max(*) as `m` from `salaries`*/ 집계함수의 인자로 넘기는 문자열 뒤에 as를 붙여서, 반환되는 객체들의 속성 이름을 바꿀 수 있습니다. 123456789101112knex('salaries') .max('salary') .then(console.log)// 결과[ &#123; 'max(`salary`)': 158220 &#125; ]knex('salaries') .max('salary as s') .then(console.log)// 결과[ &#123; s: 158220 &#125; ] GROUP BY &amp; HAVINGgroupBy 메소드를 통해 GROUP BY 구문을 빌드할 수 있습니다. 보통 위에서 다뤘던 집계함수와 함께 사용합니다. 12345678910111213knex('salaries') .select('emp_no') .max('salary as max_salary') .groupBy('emp_no') .limit(10) .toString()/*select `emp_no`, max(`salary`) as `max_salary`from `salaries`group by `emp_no`limit 10*/ having 메소드를 통해 HAVING 구문을 빌드할 수 있습니다. 사용법은 where 메소드와 비슷합니다. 12345678910111213knex('salaries') .select('emp_no') .max('salary as max_salary') .groupBy('emp_no') .having('max_salary', '&gt;', 150000) .toString()/*select `emp_no`, max(`salary`) as `max_salary`from `salaries`group by `emp_no`having `max_salary` &gt; 150000*/ JOINjoin 메소드를 이용해 INNER JOIN 구문을 빌드할 수 있습니다. 1234567891011knex('employees') .select('first_name', 'salary') .join('salaries', 'employees.emp_no', 'salaries.emp_no') .limit(10) .toString()/*select `first_name`, `salary` from `employees`inner join `salaries` on `employees`.`emp_no` = `salaries`.`emp_no`limit 10*/ 이 밖에 조인과 관련된 여러 메소드를 지원합니다. leftOuterJoin rightOuterJoin fullOuterJoin 자세한 사용법은 공식 문서를 참고해주세요. 서브쿼리단일 행 서브쿼리, 다중 행 서브쿼리 모두 자연스러운 방식으로 사용할 수 있습니다. Knex 인스턴스를 통해 작성한 쿼리 객체를, where 혹은 whereIn 메소드의 인자로 사용할 수 있습니다. 1234567891011121314151617// 1999년도 이전의 최고연봉보다 더 많은 연봉을 받은 사람들의 사원 번호를 출력합니다.const subquery = knex('salaries') .max('salary') .where('from_date', '&lt;', '1999-01-01')knex('salaries') .distinct('emp_no') .where('salary', '&gt;', subquery) .toString()/*select distinct `emp_no` from `salaries`where `salary` &gt; ( select max(`salary`) from `salaries` where `from_date` &lt; '1999-01-01')*/ 1234567891011121314151617// first_name = 'Georgi' 를 만족하는 사람들의 last_name을 출력합니다.const subquery = knex('employees') .select('emp_no') .where('first_name', 'Georgi')knex('employees') .select('last_name') .whereIn('emp_no', subquery) .toString()/*select `last_name` from `employees`where `emp_no` in ( select `emp_no` from `employees` where `first_name` = 'Georgi')*/ Utility Functions.first()Knex를 통해 쿼리를 실행하면 보통 배열이 반환됩니다. 이것은 limit(1) 처럼 하나의 행이 반환될 것이 확실한 경우에도 마찬가지입니다. 1234567knex('employees') .select('emp_no') .limit(1) .then(console.log)// 결과[ &#123; emp_no: 10001 &#125; ] 매 번 하나의 행이 들어있는 배열을 다루는 것은 불편하므로, 아래와 같이 Knex 인스턴스의 first 메소드를 이용해서 배열이 아닌 객체가 반환되도록 동작을 바꿀 수 있습니다. 1234567knex('employees') .select('emp_no') .first() .then(console.log)// 결과&#123; emp_no: 10001 &#125; 만약 반환된 행이 없다면 first의 결과는 undefined가 됩니다. .raw()MySQL과 같은 DBMS에는 기능이 굉장히 많고, 또 버전이 올라가면서 추가되는 기능들도 많습니다. Knex에는 많은 기능들이 내장되어 있지만, DBMS의 모든 기능을 지원하는 것은 아닙니다. Knex가 지원하지 않는 기능(내장함수 등)을 Knex를 통해 사용하기 위해서는 직접 쿼리를 작성하는 작업이 필요한데, 이를 위해 Knex는 아래와 같은 메소드들을 가지고 있습니다. raw whereRaw joinRaw havingRaw groupByRaw orderByRaw 이 중 raw 메소드를 이용하면 직접 작성한 쿼리를 여러 메소드에서 사용할 수 있습니다. 아래의 예제를 참고해주세요. 12345knex('users') .select(knex.raw('count(*) as user_count, status')) .where(knex.raw(1)) .orWhere(knex.raw('status &lt;&gt; ?', [1])) // &lt;&gt; 는 다르다는 의미이다. .groupBy('status') 주의! 위 예제와 같이 raw 관련 메소드들 특별한 방식으로 쿼리에 변수를 삽입하게 만들어져 있습니다. 쿼리 내에 변수를 삽입하고 싶은 경우에는 반드시 raw 메소드가 제공하는 방법을 통해서 해야 합니다. 예를 들어, 위 예제의 orWhere 안에 있는 raw 메소드를 아래와 같이 작성할 수도 있을 것입니다. knex.raw(‘status &lt;&gt; ?’, [1]) 1부분에 원하는 변수를 꼭 넣어야한다! 안의 값으로는 req.body, req.params 등과 같은 값들을 넣을 수 있다. 1234// 주의!const status = [1]knex.raw(`status &lt;&gt; $&#123;status&#125;`)// 이렇게 하면 절.대.로 안됩니다. 위와 같이 작성된 코드는 SQL injection 공격에 무방비로 노출되게 됩니다. 따라서, 쿼리 문자열 내에 변수를 삽입할 때는 절대로 ES2015의 template literal을 사용하지 마시고, raw 메소드가 제공하는 방식을 사용하세요. raw 메소드의 자세한 사용법은 공식 문서를 참고해주세요.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"knex","slug":"Node-js/knex","permalink":"http://yoursite.com/categories/Node-js/knex/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"kenx","slug":"kenx","permalink":"http://yoursite.com/tags/kenx/"}]},{"title":"Node-Knex-Schema","slug":"node-study-knex-schema","date":"2017-09-14T03:54:00.000Z","updated":"2017-09-30T13:08:52.000Z","comments":true,"path":"2017/09/14/node-study-knex-schema/","link":"","permalink":"http://yoursite.com/2017/09/14/node-study-knex-schema/","excerpt":"","text":"Node knex SchemaKnex - Schema BuilderKnex는 데이터를 읽어오고 조작하는 쿼리(DML, Data Manipulation Language) 뿐만 아니라 테이블을 생성하고 조작하는 쿼리(DDL, Data Definition Language)도 지원합니다. knex.schema로 반환되는 객체를 이용해 테이블을 만들고, 수정하고, 삭제하는 등의 작업을 할 수 있습니다. 여기서 schema는 getter function으로, 반환된 객체는 재사용이 불가능하다는 점에 주의하세요. CREATE TABLE다양한 타입의 컬럼을 만들 수 있습니다. 1234567891011121314151617181920212223242526272829knex.schema.createTable('table_name', function(table) &#123; // INTEGER table.integer('column_name') // TEXT table.text('column_name') // VARCHAR(255) (255 생략 가능) table.string('column_name', 255) // FLOAT(8, 2) (8, 2 생략 가능) table.float('column_name', 8, 2) // DECIMAL(8, 2) (8, 2 생략 가능) table.decimal('column_name', 8, 2) // 저장은 TINYINT 타입으로 되나 JS 측에서 boolean으로 사용 table.boolean('column_name') // DATETIME table.datetime('column_name') // TIMESTAMP (시각과 시간대를 같이 저장하는 타입) table.timestamp('column_name') // ENUM table.enum('column_name', ['M', 'F'])&#125;) 아래와 같이 제약 조건을 걸 수 있습니다. 12345678910111213141516171819202122232425262728293031323334knex.schema.createTable('table_name', function(table) &#123; // `id` 라는 이름의 INTEGER UNSIGNED 컬럼을 만들고, PRIMARY KEY 및 AUTO_INCREMENT 제약조건을 지정합니다. table.increments(); // `col1` 이라는 이름의 INTEGER 컬럼을 만들고, PRIMARY KEY 제약조건을 지정합니다. table.integer('col1').primary() // `col1`, `col2` 컬럼을 묶어서 PRIMARY KEY 제약조건을 지정합니다. table.primary(['col1', 'col2']) // `col2` 이라는 이름의 INTEGER UNSSIGNED 컬럼을 만듭니다. table.integer('col2').unssigned() // `col3` 이라는 이름의 INTEGER 컬럼을 만들고 기본값을 0으로 설정합니다. table.integer('col3').defaultTo(0) // `created_at` 컬럼을 만들고 기본값을 현재 시각으로 설정합니다. table.timestamp('creatd_at').defaultTo(knex.fn.now()) // `col4` 이라는 이름의 INTEGER 컬럼을 만들고 NOT NULL 제약조건을 지정합니다. table.integer('col4').notNullable() // `other_table_id` 컬럼을 `other_table` 테이블의 `id`에 대한 FOREIGN KEY로 지정합니다. table.foreign('other_table_id').references('other_table.id') // 참조하고 있는 `other_table`의 레코드가 삭제되었을 때 어떻게 동작할 것인지를 지정할 수도 있습니다. table.foreign('other_table_id').references('other_table.id').onDelete('RESTRICT') // `col1` 컬럼에 UNIQUE 제약조건을 지정합니다. table.unique('col1') // `col1`, `col2` 컬럼을 묶어서 UNIQUE 제약조건을 지정합니다. table.unique(['col1', 'col2'])&#125;) ALTER TABLE이미 만들어진 테이블을 수정할 수도 있습니다. 1234567891011knex.schema.alterTable('table_name', function(table) &#123; // 컬럼의 이름을 변경합니다. table.renameColumn('old_column_name', 'new_column_name') // 새 컬럼을 추가합니다. table.integer('new_int_column') // 컬럼을 새로 생성하는 것이 아니라 이미 존재하는 컬럼을 수정하는 것임을 명시하기 위해 // `alter` 메소드를 사용합니다. table.integer('old_int_column').notNullable().alter()&#125;) Knex는 이 외에도 많은 DDL 관련 기능을 지원합니다. 자세한 사용법은 공식 문서를 참고해주세요. 실습123456789101112131415// schema.jsconst knex = require('./knex')knex.schema.createTable('user', t =&gt; &#123; t.string('id').primary() t.string('password').notNullable()&#125;).then(() =&gt; knex.schema.createTable('url_entry', t =&gt; &#123; t.string('id', 8).primary() t.string('long_url').notNullable() t.string('user_id') t.foreign('user_id').references('user.id') t.timestamp('created_at').defaultTo(knex.fn.now())&#125;)).then(process.exit)// 실행 node src/schema.js 하면 DB에 생성된다. 123456789101112131415// knex.jsrequire('dotenv').config()module.exports = require('knex')(&#123; client: 'mysql', connection: &#123; host: 'localhost', user: 'root', password: '****', database: 'url_shortner' &#125;, debug: true&#125;)// node안에서 작성하는 구문 : knew = require('./src/knex) database의 이름을 맞춰야한다. 123456789101112131415// schema.jsconst knex = require('./knex')knex.schema.createTable('user', t =&gt; &#123; t.string('id').primary() t.string('password').notNullable()&#125;).then(() =&gt; knex.schema.createTable('url_entry', t =&gt; &#123; t.string('id', 8).primary() t.string('long_url').notNullable() t.string('user_id') t.foreign('user_id').references('user.id') t.timestamp('created_at').defaultTo(knex.fn.now())&#125;)).then(process.exit)// 실행 node src/schema.js 하면 DB에 생성된다. local환경이라면 session의 name은 각각 다르게 해줘야한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"knex","slug":"Node-js/knex","permalink":"http://yoursite.com/categories/Node-js/knex/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"kenx","slug":"kenx","permalink":"http://yoursite.com/tags/kenx/"}]},{"title":"Node-Knex","slug":"node-study-knex","date":"2017-09-14T03:54:00.000Z","updated":"2017-09-30T13:08:48.000Z","comments":true,"path":"2017/09/14/node-study-knex/","link":"","permalink":"http://yoursite.com/2017/09/14/node-study-knex/","excerpt":"","text":"Node KnexWPSN Knex 튜토리얼Node.js를 통해 MySQL을 이용하는 방법에는 아래와 같이 여러 가지가 있습니다. 쿼리를 직접 작성한 후 실행 (mysql …) 쿼리 빌더를 통해서 쿼리 실행 (Knex.js, Squel.js, …) ORM(Object Relational Mapping)을 통해서 쿼리 실행 (Sequelize, Bookshelf.js, Objection.js, …) 자주쓰이는 Sequelize의 예시이다.123456789101112131415161718const Sequelize = require('sequelize');const sequelize = new Sequelize('database', 'username', 'password');const User = sequelize.define('user', &#123; username: Sequelize.STRING, birthday: Sequelize.DATE&#125;);sequelize.sync() .then(() =&gt; User.create(&#123; username: 'janedoe', birthday: new Date(1980, 6, 20) &#125;)) .then(jane =&gt; &#123; console.log(jane.get(&#123; plain: true &#125;)); &#125;); 실무에서는 1번 방식을 사용하는 경우는 거의 없고, 주로 2번 방식과 3번 방식을 사용합니다. 쿼리 빌더는 쿼리를 직접 작성하는 대신 프로그래밍 언어로 작성된 API를 이용해 간접적으로 쿼리를 작성하는 방식을 말합니다. 쿼리 빌더를 사용하면 쿼리의 조합과 재사용을 유연하고 편리하게 할 수 있습니다. ORM(Object Relational Mapping)은 데이터베이스를 객체 지향 프로그래밍을 통해 다룰 수 있게 만들어주는 도구입니다. Validation 등의 부가 기능을 내장하고 있는 경우가 많으며 테이블 간의 관계도 편하게 다룰 수 있으나, 잘 사용하게 되기까지 필요한 학습 비용이 높다는 단점이 있습니다. 이 강의에서 사용할 Knex.js는 Node.js와 브라우저 위에서 사용가능한 쿼리 빌더입니다. SQL과 비슷한 형태의 문법을 가지고 있고, 또 마이그레이션 기능을 내장하고 있어 널리 사용되고 있습니다. 또한 MySQL, Postgres, MSSQL, Oracle과 같은 유명한 DBMS를 지원합니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"knex","slug":"Node-js/knex","permalink":"http://yoursite.com/categories/Node-js/knex/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"kenx","slug":"kenx","permalink":"http://yoursite.com/tags/kenx/"}]},{"title":"Node-DataModeling","slug":"node-study-datamodeling","date":"2017-09-13T03:54:00.000Z","updated":"2017-10-04T11:41:10.000Z","comments":true,"path":"2017/09/13/node-study-datamodeling/","link":"","permalink":"http://yoursite.com/2017/09/13/node-study-datamodeling/","excerpt":"","text":"DataBase Modeling 회원 =&gt; 회원번호, 아이디, 패스워드, 이름, 전화번호, 성별, 생년월일, 가입일자, 탈퇴일자, 주소, 연령대 로그인 =&gt; 로그인 일시, IP, 회원번호 장바구니 =&gt; 장바구니 번호, 상품번호, 담은시간, 회원번호 상품 =&gt; 상품번호, 상품명, 가격, 사이즈 구매 =&gt; 회원번호, 구매시간, 상품번호 생일쿠폰 =&gt; 쿠폰번호, 회원번호 시나리오 회원가입을 통하여 이 쇼핑몰 사이트를 이용할 수 있다. 회원은 로그인을 할 때마다 로그인정보(로그인 일시, 아이디, IP, 회원번호)가 기록된다. 회원가입시 필요한 정보는 (회원번호, 아이디, 패스워드, 가입일자, 탈퇴일자, 주소, 전화번호, 연령대, 성별)이다. 회원은 물품을 검색할 수 있다. 검색된 물품은 (상품명, 가격, 사이즈)가 보여진다. 회원은 물품을 장바구니에 담을 수 있다. 회원은 물건을 구매할 경우 (구매시간, 회원번호, 상품번호) pk로 가지게 된다. 회원은 생일이면 생일 쿠폰을 받는다. ￼ ERD SQL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138-- MySQL Workbench Synchronization-- Generated: 2017-09-13 19:19-- Model: New Model-- Version: 1.0-- Project: Name of the project-- Author: 김세준SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='TRADITIONAL,ALLOW_INVALID_DATES';CREATE SCHEMA IF NOT EXISTS `mydb` DEFAULT CHARACTER SET utf8 ;CREATE TABLE IF NOT EXISTS `mydb`.`User` ( `u-number` INT(11) NOT NULL COMMENT ' \\n', `id` VARCHAR(45) NOT NULL COMMENT ' ', `pwd` VARCHAR(45) NOT NULL, `name` VARCHAR(45) NOT NULL, `call` INT(11) NOT NULL, `gender` VARCHAR(45) NULL DEFAULT NULL, `birth` INT(11) NOT NULL, `join-date` DATETIME NOT NULL, `session-date` DATETIME NULL DEFAULT NULL, `address` VARCHAR(45) NOT NULL, `ages` VARCHAR(45) NULL DEFAULT NULL, PRIMARY KEY (`u-number`))ENGINE = InnoDBDEFAULT CHARACTER SET = utf8;CREATE TABLE IF NOT EXISTS `mydb`.`Login` ( `login-date` DATETIME NOT NULL, `IP` VARCHAR(45) NULL DEFAULT NULL, `User_u-number` INT(11) NOT NULL, PRIMARY KEY (`login-date`, `User_u-number`), INDEX `fk_Login_User1_idx` (`User_u-number` ASC), CONSTRAINT `fk_Login_User1` FOREIGN KEY (`User_u-number`) REFERENCES `mydb`.`User` (`u-number`) ON DELETE NO ACTION ON UPDATE NO ACTION)ENGINE = InnoDBDEFAULT CHARACTER SET = utf8;CREATE TABLE IF NOT EXISTS `mydb`.`Basket` ( `basket-number` INT(11) NOT NULL, `select-date` DATETIME NULL DEFAULT NULL, `User_u-number` INT(11) NOT NULL, `Product_product-number` INT(11) NOT NULL, PRIMARY KEY (`basket-number`, `User_u-number`, `Product_product-number`), INDEX `fk_Basket_User1_idx` (`User_u-number` ASC), INDEX `fk_Basket_Product1_idx` (`Product_product-number` ASC), CONSTRAINT `fk_Basket_User1` FOREIGN KEY (`User_u-number`) REFERENCES `mydb`.`User` (`u-number`) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT `fk_Basket_Product1` FOREIGN KEY (`Product_product-number`) REFERENCES `mydb`.`Product` (`product-number`) ON DELETE NO ACTION ON UPDATE NO ACTION)ENGINE = InnoDBDEFAULT CHARACTER SET = utf8;CREATE TABLE IF NOT EXISTS `mydb`.`Product` ( `product-number` INT(11) NOT NULL, `product-name` VARCHAR(45) NULL DEFAULT NULL, `price` VARCHAR(45) NULL DEFAULT NULL, `size` VARCHAR(45) NULL DEFAULT NULL, PRIMARY KEY (`product-number`))ENGINE = InnoDBDEFAULT CHARACTER SET = utf8;CREATE TABLE IF NOT EXISTS `mydb`.`Buy` ( `buy-date` DATETIME NOT NULL, `Product_product-number` INT(11) NOT NULL, `User_u-number` INT(11) NOT NULL, PRIMARY KEY (`buy-date`, `Product_product-number`, `User_u-number`), INDEX `fk_Buy_Product1_idx` (`Product_product-number` ASC), INDEX `fk_Buy_User1_idx` (`User_u-number` ASC), CONSTRAINT `fk_Buy_Product1` FOREIGN KEY (`Product_product-number`) REFERENCES `mydb`.`Product` (`product-number`) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT `fk_Buy_User1` FOREIGN KEY (`User_u-number`) REFERENCES `mydb`.`User` (`u-number`) ON DELETE NO ACTION ON UPDATE NO ACTION)ENGINE = InnoDBDEFAULT CHARACTER SET = utf8;CREATE TABLE IF NOT EXISTS `mydb`.`Coupon` ( `coupon-number` INT(11) NOT NULL, `User_u-number` INT(11) NOT NULL, PRIMARY KEY (`coupon-number`, `User_u-number`), INDEX `fk_생일쿠폰_User_idx` (`User_u-number` ASC), CONSTRAINT `fk_생일쿠폰_User` FOREIGN KEY (`User_u-number`) REFERENCES `mydb`.`User` (`u-number`) ON DELETE NO ACTION ON UPDATE NO ACTION)ENGINE = InnoDBDEFAULT CHARACTER SET = utf8;SET SQL_MODE=@OLD_SQL_MODE;SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;use mydb;SELECT * FROM user;INSERT INTO user VALUES (1,'sejune','kim','kimsejune','01045401088','men','930907','170913', null, '경기도 시흥시 정왕동', '25');SELECT*FROM login;INSERT INTO login VALUES(now(), '192.168.0.1', 1);SELECT*FROM coupon;INSERT INTO coupon VALUES(1, 1);SELECT * FROM Product;INSERT INTO product VALUES(1, '슬렉스(검정)', '200000', '29');SELECT * FROM buy;INSERT INTO buy VALUES (now(), 1, 1);SELECT * FROM Basket;INSERT INTO basket VALUES(1, now(), 1, 1);","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"DataModeling","slug":"Node-js/DataModeling","permalink":"http://yoursite.com/categories/Node-js/DataModeling/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"DataModeling","slug":"DataModeling","permalink":"http://yoursite.com/tags/DataModeling/"}]},{"title":"Node-Database","slug":"node-study-database","date":"2017-09-11T03:54:00.000Z","updated":"2017-09-22T13:03:45.000Z","comments":true,"path":"2017/09/11/node-study-database/","link":"","permalink":"http://yoursite.com/2017/09/11/node-study-database/","excerpt":"","text":"DataBase데이터베이스와 테이블의 생성CREATE DATABASE는 데이터베이스를 만드는 명령어입니다. 워크벤치에서 root 계정으로 로그인한 후, 아래의 SQL을 실행해보세요.12345-- 데이터베이스 생성CREATE DATABASE my_db;-- 모든 데이터베이스의 목록SHOW DATABASES; CREATE TABLE은 테이블을 만드는 명령입니다. 아래 명령을 차례로 실행해보세요.123456789101112131415161718-- 테이블 생성CREATE TABLE my_db.users ( -- `name`이라는 이름의 문자열 컬럼을 생성합니다. NULL을 허용하지 않습니다. name VARCHAR(30) NOT NULL, -- `job`이라는 이름의 문자열 컬럼을 생성합니다. NULL을 허용합니다. job VARCHAR(30), -- `age`라는 이름의 양수 컬럼을 생성합니다. NULL을 허용합니다. age INTEGER UNSIGNED, -- `name` 컬럼을 기본 키로 지정합니다. PRIMARY KEY (name));-- my_db 데이터베이스에 있는 모든 테이블의 목록SHOW TABLES FROM my_db;-- my_db.users 테이블에 대한 자세한 정보DESCRIBE my_db.users;SHOW CREATE TABLE post; USE [database]는 기본 데이터베이스를 설정하는 명령입니다. 즉, SQL을 작성할 때 데이터베이스 이름을 생략할 수 있게 만들어줍니다. 워크벤치에서는 사이드바의 데이터베이스 이름을 더블 클릭해도 같은 동작을 합니다. 기본 데이터베이스를 선택한 후 아래 명령을 실행해보세요.1DESCRIBE my_table; 데이터 추가하기12345678910-- 하나의 레코드 추가하기INSERT INTO users (name, job, age)VALUES ('윤민지', '프론트엔드 개발자', 32);-- 여러 개의 레코드 추가하기INSERT INTO users (name, job, age)VALUES ('한주원', '프론트엔드 개발자', 39),('박현숙', '백엔드 개발자', 48),('정병언', NULL, 25),('임동면', '디자이너', NULL); 데이터 불러오기1234-- 모든 컬럼을 포함시켜 불러오기SELECT * FROM users;-- 특정 컬럼만 포함시켜 불러오기SELECT name, job FROM users; 데이터 수정하기123UPDATE usersSET job = '프로그래머'WHERE name = '정병언'; 데이터 삭제하기12DELETE FROM usersWHERE name = '정병언'; 데이터베이스와 테이블의 삭제1234567DROP DATABASE, DROP TABLE 명령은 각각 데이터베이스와 테이블을 삭제하는 명령입니다. 아래의 명령을 차례대로 실행해보세요.-- users 테이블 삭제DROP TABLE users;-- my_db 데이터베이스 삭제DROP DATABASE my_db; 관계형 데이터베이스의 구성요소Database (데이터베이스) 테이블 및 다른 구성요소들을 모아놓은 집합입니다. 스키마라고도 불리는데, 스키마라는 용어는 ‘데이터베이스’를 의미하기도 하고 ‘데이터베이스의 구조’를 의미하기도 합니다. 하나의 DBMS는 여러 개의 데이터베이스를 가질 수 있으며, 데이터베이스 단위로 권한 설정이 이루어집니다. User &amp; Privilege (사용자 &amp; 권한) 하나의 DBMS는 여러 개의 사용자 계정을 가질 수 있습니다. DBMS를 사용하려면 사용자 계정을 이용해 DBMS에 접속해야 합니다. 사용자 계정은 데이터베이스 별로 다른 권한을 가집니다. root 유저는 DBMS 초기 설치 시에 만들어지는 계정이며, DBMS에 대한 모든 권한을 부여받습니다. Connection 사용자 계정을 이용해 데이터베이스에 접속하면, 새 커넥션이 만들어집니다. 세션과 유사한 개념입니다. 커넥션 별로 여러가지 옵션을 설정할 수 있고, 트랜잭션도 커넥션 단위로 수행됩니다. 하나의 클라이언트에서 여러 개의 트랜잭션을 수행하기 위해 여러 커넥션을 이용할 수 있습니다. Table (테이블) 하나의 데이터베이스는 여러 개의 테이블을 가질 수 있습니다. 표 형태로 구조화된 데이터가 테이블에 저장됩니다. 테이블의 행(row)은 개별적인 레코드를 나타내며, 테이블의 열(column)은 레코드의 속성을 나타냅니다. 각각의 열에는 미리 정의된 자료형에 해당하는 데이터만 저장될 수 있습니다. 테이블의 각 행은 기본 키(primary key)를 이용해 식별하고, 테이블 내에서 유일한 값이어야 합니다. 기본 키는 다른 테이블과의 관계를 나타낼 때 사용됩니다. Constraint (제약 조건)제약 조건을 지정하면 테이블에 특정한 방식으로만 데이터가 저장될 수 있도록 할 수 있습니다. 아래 제약 조건들이 자주 사용됩니다. NOT NULL : 컬럼에 NULL 값이 저장되지 못하도록 막습니다. UNIQUE : 한 테이블 내에서 컬럼에 저장된 모든 값이 유일하도록 강제합니다. PRIMARY KEY : NOT NULL과 UNIQUE가 동시에 적용됩니다. PRIMARY KEY 제약 조건이 걸린 컬럼은 각 행의 식별자로 사용됩니다. FOREIGN KEY : 다른 테이블의 primary key를 참조합니다. 해당 primary key를 가진 레코드가 변경되었을 때 특정 동작을 강제할 수 있습니다. DEFAULT : INSERT 구문을 사용해서 레코드를 추가할 때, 컬럼에 아무런 값도 지정하지 않으면 DEFAULT 제약 조건으로 지정한 기본값이 저장되도록 합니다. CHECK : 레코드가 주어진 계산식을 만족해야만 하도록 CHECK 제약 조건을 지정할 수 있습니다. 123456CREATE TABLE adult ( name varchar(255) NOT NULL, nationality varchar(255) DEFAULT '대한민국', age int, CHECK (age &gt;= 18)); Primary Key, Foreign KeyPrimary Key(기본 키)로 지정된 컬럼에 저장되어 있는 값은 테이블에 저장되어 있는 레코드의 식별자 역할을 합니다. Foreign Key(외래 키)로 지정된 컬럼에는 다른 테이블의 기본 키 값이 저장되며, 다른 테이블의 레코드를 참조함으로써 해당 테이블과의 관계를 나타냅니다. 여러 컬럼이 한꺼번에 기본 키로 지정될 수도 있습니다. 이를 Composite primary key(한국어로는 합성키, 혹은 슈퍼키라고 부름)라고 합니다. 테이블 생성테이블을 생성할 때는 CREATE TABLE 구문을 사용합니다. 123456789101112131415161718192021222324252627CREATE TABLE my_table ( -- 일반적인 컬럼은 아래와 같의 정의합니다. 이 컬럼에는 NULL 값이 저장될 수 있습니다. my_col1 INTEGER, -- 컬럼의 기본값을 지정합니다. my_col2 INTEGER DEFAULT 0, -- 컬럼에 NULL 값이 저장될 수 없도록 제한을 둡니다. my_col3 INTEGER NOT NULL, -- UNIQUE 제약조건: 컬럼의 값은 테이블 내에서 유일해야 합니다. my_col4 INTEGER UNIQUE, -- 다양한 옵션을 한 번에 지정할 수 있습니다. my_col5 INTEGER NOT NULL DEFAULT 1, my_col6 INTEGER NOT NULL UNIQUE, -- 1부터 시작하는 식별자를 아래와 같이 정의합니다. -- PRIMARY KEY는 기본적으로 NOT NULL, UNIQUE 규칙이 적용됩니다. my_id INTEGER UNSIGNED AUTO_INCREMENT PRIMARY KEY, -- 컬럼 정의와 별도로, 여러가지 제약 조건과 인덱스를 아래에 지정할 수 있습니다. -- 제약 조건과 인덱스에 대해서는 추후 배울 것입니다. FOREIGN KEY (my_id) REFERENCES your_table(your_id) ON DELETE CASCADE, INDEX my_idx (my_col1, my_col2), ...) 테이블이 이미 존재하는 경우에도 구문이 에러 없이 실행되도록 IF NOT EXISTS 구문을 사용할 수 있습니다. 123CREATE TABLE IF NOT EXISTS table_name ( ...) 테이블 수정1234567ALTER TABLE table_nameRENAME new_table_name, -- 테이블 이름 변경ADD COLUMN column_name INTEGER NOT NULL, -- 컬럼 추가ADD CONSTRAINT UNIQUE, -- 제약 조건 추가CHANGE old_column_name new_column_name INTEGER, -- 컬럼 이름 변경MODIFY column_name NEW_TYPE -- 컬럼 타입 변경DROP COLUMN column_name; -- 컬럼 제거 자세한 사용법은 공식 문서를 참고해주세요. MySQL 데이터 타입문자열VARCHAR짧은 문자열을 저장하기 위해 가장 널리 사용되는 타입입니다. 컬럼 타입으로 지정할 때는 아래와 같이 문자열의 길이(바이트)를 명시해야 합니다. 1VARCHAR(255) -- 255는 가장 널리 사용되는 길이입니다. TEXT긴 문자열을 저장하기 위해 사용되는 타입입니다. TEXT 타입의 컬럼에는 64MB까지 저장할 수 있습니다. 요구사항에 따라 크기가 다른 다양한 종류의 TEXT 타입(TINYTEXT, TEXT, MEDIUMTEXT, LONGTEXT)을 사용할 수 있습니다. 수정수, 고정 소수점, 부동 소수점을 위한 타입이 있습니다. 모든 수 타입은 양수만을 저장하기 위해 타입 뒤에 UNSIGNED 지시자를 사용할 수 있습니다. INTEGER정수를 위한 타입입니다. INT로 줄여 쓸 수도 있습니다. 요구사항에 따라 크기가 다른 다양한 종류의 INT 타입(TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT)을 사용할 수 있습니다. 1INTEGER UNSIGNED -- INTEGER 타입의 양수를 저장할 수 있습니다. MySQL에는 참, 거짓을 나타내는 boolean 관련 타입이 없습니다. 대신 TINYINT를 사용합니다. DECIMAL고정 소수점 수를 위한 타입입니다. 십진수의 정확한 계산이 필요할 때 사용합니다. 정수부(최대 65), 소수부(최대 30, 정수부보다 짧거나 같아야 함)의 최대 길이를 각각 지정할 수 있습니다. 1DECIMAL(5, 2) -- 12345.67과 같은 수를 저장할 수 있습니다. DOUBLE부동 소수점 수를 위한 타입입니다. 소수의 빠른 계산과 효율적 저장이 필요할 때 사용합니다. 시각MySQL에는 시각의 저장을 위한 타입들이 준비되어 있습니다. 주로 사용되는 아래의 두 타입은 시간대 정보를 저장하지 않기 때문에, 사용에 주의를 요합니다. DATEDATE 타입은 날짜를 위한 타입입니다. DATETIMEDATETIME 타입은 날짜와 시각을 같이 저장해야 할 때 사용합니다. 기타ENUM: 열거형을 위한 타입입니다.JSON: MySQL 5.7에 JSON 지원이 추가되었으나, 널리 사용되지는 않습니다.POINT, GEOMETRY : 공간 정보를 위한 타입입니다. 계정 만들기실습하기에 앞서, employees 데이터베이스에만 접속할 수 있는 emplyees_user 계정을 만든 후 그 계정을 이용해 MySQL에 접속해봅시다. SELECT가장 단순한 SELECT 구문을 실행해보겠습니다. 1SELECT * FROM employees; 실행 후, 아래와 같이 결과가 나오면 성공입니다. employees 테이블에는 어떤 컬럼들이 있는지, 각 컬럼에는 어떤 형태의 데이터가 저장되고 있는지 파악해두도록 합시다. MySQL Workbench는 레코드의 갯수가 많을 경우에 1000개 단위로 페이지를 끊어서 보여주는 기능을 가지고 있습니다. 이미지의 우측 상단에 빨갛게 표시된 버튼들을 눌러서 페이지를 이동할 수 있습니다. 이제 테이블의 일부 컬럼만 불러오는 구문을 실행해보겠습니다. 1SELECT first_name FROM employees; 위 명령은 employees 테이블에서 first_name 컬럼만을 불러옵니다. 아래와 같이 여러 개의 컬럼을 선택적으로 불러올 수 있습니다. 1SELECT first_name, last_name FROM employees; 또는 SQL 실행 결과로 출력되는 테이블의 컬럼의 이름을 바꾸어 출력할 수도 있습니다. 아래와 같이 각 컬럼의 이름 뒤에 AS 구문을 사용하면 됩니다. backtick(`) 문자를 사용해 컬럼의 이름에 MySQL 예약어나 공백 문자를 넣을 수 있습니다. (권장되지는 않습니다.) 1SELECT first_name AS `family name`, last_name AS `given name` FROM employees; AS를 생략하고 써도 같은 의미입니다. 1SELECT first_name `family name`, last_name `given name` FROM employees; 정렬하기ORDER BY 구문을 사용하면 특정 컬럼에 대한 정렬 기준을 세워 테이블을 출력할 수 있습니다. 아래와 같이 hire_date 컬럼을 기준으로 오름차순 정렬을 시킬 수 있습니다. 12SELECT emp_no, hire_date, birth_date FROM employeesORDER BY hire_date; ORDER BY 구문에 포함된 컬럼이 꼭 SELECT 구문에 포함될 필요는 없습니다. 아래와 같이 SELECT 구문에서 hire_date를 생략해도 문제 없습니다. 12SELECT emp_no FROM employeesORDER BY hire_date; ORDER BY 구문은 여러 개의 컬럼에 대해서 정렬하는 기능도 지원합니다. 아래와 같이 여러 개의 컬럼을 쉼표로 구분해서 ORDER BY 구문에 넣어 주면 됩니다. 이 때, hire_date로 먼저 오름차순 정렬 되고 난 후, 같은 hire_date를 가진 레코드끼리 birth_date를 기준으로 오름차순 정렬이 이루어집니다. 12SELECT emp_no, hire_date, birth_date FROM employeesORDER BY hire_date, birth_date; ORDER BY 구문은 기본적으로 오름차순 정렬을 하게끔 되어 있습니다. 아래와 같이 DESC 구문을 사용하면 특정 컬럼에 대해서 내림차순 정렬을 하도록 명령할 수 있습니다. DESC와 ASC는 각각 ‘descending’과 ‘ascending’의 약자입니다. 12SELECT first_name, hire_date, birth_date FROM employeesORDER BY hire_date DESC, birth_date ASC; -- ASC는 생략 가능 Character Set &amp; CollationMySQL은 날짜, 숫자 뿐 아니라 문자열에 대한 정렬도 지원합니다. 아래와 같이 이름을 이용해 정렬을 할 수도 있습니다. 12SELECT first_name, last_name FROM employeesORDER BY last_name, first_name; MySQL은 다양한 언어와 문자셋을 지원합니다. 그런데 언어나 문자셋별로 문자열의 정렬 기준이 달라야 할 필요가 있습니다. 이러한 정렬 기준을 MySQL에서는 collation이라고 부릅니다. 한글의 경우, 문자셋은 utf8, collation은 utf8mb4_general_ci를 사용하면 됩니다. MySQL 사용 중에 불러온 문자열이 깨져 보인다거나 정렬이 제대로 되지 않는다면, 문자셋과 collation의 설정이 잘못되었을 확률이 높습니다. 현재 데이터베이스의 기본 문자셋과 collation을 확인하려면, 아래와 같이 워크벤치 좌측 데이터베이스 목록의 ‘i’ 모양 아이콘을 클릭하세요. 일부만 가져오기LIMIT 구문을 사용하면 레코드의 일부분만 불러올 수 있습니다. 12SELECT * FROM employeesLIMIT 5; LIMIT 구문은 정렬 순서에 영향을 받습니다. 예를 들어, 생일이 가장 빠른 1명의 기록을 불러오고 싶다면 아래와 같이 하면 됩니다. 123SELECT first_name, birth_date FROM employeesORDER BY birth_dateLIMIT 1; OFFSET 구문을 사용하면 앞쪽 기록의 일부분을 생략하고 나머지 기록들을 불러올 수 있습니다. 예를 들어, 생일이 열 번째로 빠른 1명의 기록을 불러오고 싶다면 아래와 같이 하면 됩니다. 123SELECT first_name, birth_date FROM employeesORDER BY birth_dateLIMIT 1 OFFSET 9; 중복되는 값 제거하기DISTINCT 구문을 사용하면 컬럼 내에 중복되는 값을 하나로 합쳐서 보여줍니다. 아래 두 쿼리의 결과를 비교해보세요. 12345SELECT first_name FROM employeesORDER BY first_name;SELECT DISTINCT first_name FROM employeesORDER BY first_name; 필터링과 연산자WHERE 구문을 사용하면 특정 조건을 만족하는 기록만을 선택적으로 불러올 수 있습니다. 12SELECT * FROM employeesWHERE first_name = 'Shahid' AND hire_date &gt; '1997-09-12'; 위와 같이 WHERE 구문에서는 조건을 나타내기 위해 연산자를 사용합니다. WHERE 구문 내에서 자주 사용되는 연산자와 그 뜻을 아래 표에서 확인할 수 있습니다. 연산자 우선순위여느 프로그래밍 언어가 그렇듯이 SQL에도 연산자 우선순위가 존재합니다. 예를 들어, OR보다 AND가 먼저 연산되기 때문에 아래와 같이 사용할 때는 주의해야 합니다. 1234-- first_name이 'Jeong' 혹은 'Shahid'인 사람들 중, 입사일이 '1997-09-12' 이후인 사람들을 불러오기 (틀림)SELECT * FROM employeesWHERE first_name = 'Jeong' OR first_name = 'Shahid' AND hire_date &gt; '1997-09-12';-- 뒤쪽의 AND가 먼저 연산되어, 원래 의도와는 다르게 first_name이 'Jeong'인 모든 사람들이 포함된 결과가 나옵니다. 아래와 같이 괄호를 사용해서 특정 연산이 먼저 실행되도록 할 수 있습니다. 123-- first_name이 'Jeong' 혹은 'Shahid'인 사람들 중, 입사일이 '1997-09-12' 이후인 사람들을 불러오기SELECT * FROM employeesWHERE (first_name = 'Jeong' OR first_name = 'Shahid') AND hire_date &gt; '1997-09-12'; 연산자 우선순위의 전체 목록을 확인하려면 공식 문서를 참고하세요. DATE, DATETIME 리터럴DATE 타입과 DATETIME 타입을 요구하는 문맥에서 아래와 같은 형태의 문자열을 사용하면, 자동으로 DATE와 DATETIME 형태로 해석됩니다. 12'YYYY-MM-DD HH:MM:SS' -- DATETIME을 나타내는 문자열 형식'YYYY-MM-DD' -- DATE를 나타내는 문자열 형식 문자열을 사용해서 아래와 같이 hire_date와 같은 DATE 형태의 컬럼에 대해 필터링을 할 수 있습니다. 12SELECT * FROM employeesWHERE hire_date &gt; '1997-09-12'; NULLNULL 값은 ‘데이터가 없음’을 나타내기 위한 목적으로 다루어지는 값입니다. 그런데 이 값은 연산 과정에서 특별하게 취급됩니다. 대부분의 연산자에 대해, 어떤 연산의 피연산자가 NULL이면 해당 연산의 결과는 무조건 NULL이 되게 됩니다. 1231 &gt; NULL -- 결과는 NULL이 됩니다.1 = NULL -- 결과는 NULL이 됩니다.NULL = NULL -- 심지어 이것도 NULL이 됩니다! 따라서, NULL 값을 허용하는 컬럼에 대해 연산을 할 때는 주의해야 합니다. 특히, 어떤 컬럼의 값이 NULL인지 아닌지 확인하기 위해서는 = 연산자 대신에 IS 혹은 IS NOT 연산자를 사용해야 합니다. 이를 테스트해보기 위해 NULL 값이 포함된 컬럼을 하나 추가합시다. 12INSERT INTO titles (emp_no, title, from_date, to_date)VALUES (10001, 'new title', '2017-09-11', NULL); TRUE 혹은 FALSE를 써야하는 문맥에 NULL을 쓰면, FALSE로 취급됩니다. 아래 SQL 명령의 결과를 비교해보시기 바랍니다. 123456789101112-- 이렇게 하면 안 됩니다!SELECT * FROM titlesWHERE to_date = NULL; -- 무조건 FALSE로 취급됨-- 반드시 이렇게 해야 합니다.SELECT * FROM titlesWHERE to_date IS NULL;-- 이렇게 하면 안 됩니다!SELECT * FROM titlesWHERE to_date != NULL; -- 무조건 FALSE로 취급됨-- 반드시 이렇게 해야 합니다.SELECT * FROM titlesWHERE to_date IS NOT NULL; salaries 테이블실습용 employees 데이터베이스의 salaries 테이블에는 각 사원의 연봉 변동 내역이 저장되어 있습니다. 본 문서에서는 salaries 테이블을 이용해 실습합니다. 집계 함수 (Aggregate Function)MySQL은 여러가지 집계 함수를 지원합니다. 집계 함수 의미MAX(col_name) 최대값MIN(col_name) 최소값SUM(col_name) 합계AVG(col_name) 평균COUNT(col_name) 컬림에 NULL이 아닌 값이 저장되어 있는 행의 갯수COUNT(*) 행의 갯수 123456SELECT MAX(salary) FROM salaries;SELECT MIN(salary) FROM salaries;SELECT SUM(salary) FROM salaries;SELECT AVG(salary) FROM salaries;SELECT COUNT(*) FROM employees; GROUP BY그룹이란 특정 컬럼에 같은 값을 갖고 있는 행들의 집합입니다. GROUP BY 구문을 사용해서, 위에서 했던 집계 작업을 그룹 단위로 수행할 수 있습니다. 123-- 각 사원이 연봉을 가장 많이 받을 때 얼마를 받았는지를 가져옵니다.SELECT emp_no, max(salary) FROM salariesGROUP BY emp_no; 12345-- 각 사원의 연봉이 총 몇 번 변경되었는지를 가져옵니다.-- AS 구문을 이용해 집계 컬럼의 이름을 변경할 수 있습니다.SELECT emp_no, count(*) AS salary_count FROM salariesGROUP BY emp_no;ORDER BY 구문을 사용해 그룹 집계의 결과를 정렬할 수도 있습니다. 12345-- 각 사원의 연봉이 총 몇 번 변경되었는지를 가져오고, 많이 변경된 순서대로 출력합니다.SELECT emp_no, count(*) AS salary_count FROM salariesGROUP BY emp_noORDER BY salary_count DESC;WHERE 구문을 사용해 집계에 포함될 레코드를 한정시킬 수도 있습니다. 12345-- 각 사원의 연봉이 1996년부터 2000년까지 총 몇 번 변경되었는지를 가져오고, 많이 변경된 순서대로 출력합니다.SELECT emp_no, count(*) AS salary_count FROM salariesWHERE from_date BETWEEN '1996-01-01' AND '2000-12-31'GROUP BY emp_noORDER BY salary_count DESC; HAVING그룹 집계의 결과에서 특정 그룹을 필터링한 결과를 출력할 수도 있습니다. HAVING 구문을 사용하면 되고, 문법은 WHERE 구문과 비슷합니다. 12345-- 최고 연봉이 15만 달러 이상인 사원의 사원 번호와 최고 연봉을 출력합니다. SELECT emp_no, max(salary) AS max_salary FROM salariesGROUP BY emp_noHAVING max_salary &gt; 150000ORDER BY max_salary DESC; WHERE, GROUP BY, HAVING, ORDER BY을 모두 사용한 쿼리입니다. 각 구문은 아래와 같은 순서대로 사용되어야 합니다. 123456-- 1996년과 2000년 사이에 받았던 최고 연봉이 15만 달러보다 높았던 사원의 사원 번호와 최고 연봉을 출력합니다.SELECT emp_no, max(salary) as max_salary FROM salariesWHERE from_date BETWEEN '1996-01-01' AND '2000-12-31'GROUP BY emp_noHAVING max_salary &gt; 150000ORDER BY max_salary DESC; 문자열 연산CONCAT 함수를 이용해 문자열을 이어붙일 수 있습니다. 1SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM employees; LOWER 함수와 UPPER 함수는 각각 문자열을 소문자/대문자로 바꾸어줍니다. 12SELECT UPPER(first_name) FROM employees;SELECT LOWER(first_name) FROM employees; LENGTH 함수는 문자열의 길이를 반환합니다. 12SELECT first_name, LENGTH(first_name) AS length_first_name FROM employeesORDER BY length_first_name DESC; SUBSTRING 함수는 문자열의 일부분을 반환합니다. SUBSTRING(문자열, 자를 인덱스, 자를 길이)와 같이 사용합니다. 자를 인덱스는 1부터 시작합니다. 1SELECT SUBSTRING(first_name, 1, 3) FROM employees; -- 앞의 세 글자를 반환 수 연산ABS 함수는 절대값을 반환합니다. 1SELECT ABS(-1); ROUND 함수는 반올림한 결과를 반환합니다. 1SELECT ROUND(1.5); 기타CURRENT_DATE 함수는 오늘 날짜를 DATE 형식을 반환합니다. NOW 함수는 현재 시각을 DATETIME 형식으로 반환합니다. 12SELECT CURRENT_DATE();SELECT NOW(); COALESCE 함수는 인자들 중 처음으로 NULL이 아닌 값을 반환합니다. 이 함수는 NULL 값과 NULL이 아닌 값이 모두 저장되어있는 컬럼을 불러올 때, NULL 값을 대체하기 위해 사용됩니다. 12345678-- 1이 출력됨SELECT COALESCE(NULL, 1);-- 2가 출력됨SELECT COALESCE(2, 1);-- 만약 nullable_column에 NULL이 저장되어 있으면 'DEFAULT_VALUE`를 반환하고, 아니면 컬럼에 저장되어있는 값을 그대로 반환SELECT COALESCE(nullable_column, 'DEFAULT_VALUE') FROM some_table; FROM, WHERE 구문을 통한 조인FROM 뒤에 여러 개의 테이블 이름을 적어서, 테이블을 합칠 수 있습니다. 12SELECT salaries.salary, salaries.from_date, employees.first_nameFROM salaries, employees; 이렇게 테이블을 합칠 수 있지만, 뭔가 이상합니다. 모든 사원의 연봉 변동 기록이 같은 것으로 나옵니다. 사실 위 코드는 틀린 코드입니다. 테이블을 어떻게 합칠 것인지 지정해주지 않았기 때문에, 결과는 두 테이블의 단순한 Cartesian product(곱집합)으로 나오게 됩니다. 그러면 테이블을 어떻게 합칠 것인지 지정해보겠습니다. 123SELECT salaries.salary, salaries.from_date, employees.first_nameFROM salaries, employeesWHERE salaries.emp_no = employees.emp_no; 이제야 잘 나오는 것 같습니다. 이렇게 테이블을 합칠 때에는 어떻게 합칠 지를 직접 명시해주어야 합니다. 이렇게 JOIN 구문을 사용하지 않고 FROM과 WHERE만을 사용해 조인하는 것을 암시적 조인(implicit join)이라고 합니다. JOIN 구문위의 예제처럼 테이블을 합칠 수도 있지만, 보통의 경우 JOIN 구문을 이용해서 조인을 하는 것이 관례입니다. (조인을 하고 있다는 것을 명확히 알 수 있고, 읽기도 쉽기 때문입니다.) 이렇게 직접 JOIN 구문을 사용해서 조인을 하는 것을 명시적 조인(explicit join)이라고 합니다. 아래의 예제는 바로 위의 암시적 조인과 완전히 같은 동작을 합니다. 123SELECT salaries.salary, salaries.from_date, employees.emp_no, employees.first_nameFROM salariesJOIN employees ON employees.emp_no = salaries.emp_no; FROM에 적었던 두 번째 테이블의 이름을 JOIN 바로 뒤에 적어주었습니다. 이렇게 FROM 구문으로 지정한 하나의 테이블에 JOIN 구문을 사용해서 다른 테이블을 합칠 수 있습니다. 이전에 WHERE를 이용해 적어주었던 기준은 ON 구문을 이용해 지정해줍니다. SELECT 구문 뒤에 오는 컬럼 이름 앞에는 테이블 이름을 table_name.column_name과 같은 형식으로 붙여줍니다. 만약 컬럼 이름이 여러 테이블에 걸쳐서 유일하다면 테이블 이름을 아래와 같이 생략할 수 있습니다. 1234-- `emp_no`는 두 테이블 모두 가지고 있기 때문에, 앞에 붙이는 테이블 이름을 생략할 수 없습니다.SELECT first_name, salary, from_date, employees.emp_noFROM salariesJOIN employees ON employees.emp_no = salaries.emp_no; AS 구문을 이용해서 테이블 이름에도 별칭을 붙일 수 있습니다. 1234SELECT first_name, salary, from_date, emp.emp_noFROM salaries AS salJOIN employees AS emp ON emp.emp_no = sal.emp_no;INNER JOIN &amp; OUTER JOIN 위의 예제에서 ‘사원 테이블’과 ‘연봉 변동 내역 테이블’은 우리의 의도대로 잘 합쳐졌습니다. 그런데 조인의 기준을 충족시키지 못하는 레코드들, 다시 말해서 일치하는 emp_no가 없거나, 어느 한 쪽의 emp_no 컬럼에 NULL이 저장되어 있는 경우는 어떻게 될까요? 위에서 사용한 SQL 명령을 그대로 쓰면, 조인의 기준을 충족시키지 못하는 레코드들은 아예 출력 결과에 포함이 되지 않습니다. 이와 같은 조인 방식을 INNER JOIN이라고 합니다. 사실 위 SQL 명령은 다음과 완전히 같은 의미입니다. 1234SELECT first_name, salary, from_date, emp.emp_noFROM salaries AS salINNER JOIN employees AS emp ON emp.emp_no = sal.emp_no;-- `INNER JOIN`과 `JOIN`은 같은 의미입니다. 그런데 가끔, 조인의 기준을 충족시키지 못하는 레코드들도 결과에 포함시켜야 하는 경우가 있습니다. 이러한 조인 방식을 OUTER JOIN이라고 합니다. 이 문서에서는 OUTER JOIN을 다루지 않으나, 가끔 필요한 경우가 있으니 아래의 문서를 참고해주세요. LEFT OUTER JOINRIGHT OUTER JOINFULL OUTER JOIN 세 개 이상의 테이블 조인하기아래와 같이 JOIN 구문을 여러 번 써서, 세 개 이상의 테이블을 합치는 것도 가능합니다. 123456-- departments 테이블에는 부서 번호와 부서 이름이 저장되어 있습니다.-- dept_emp 테이블에는 사원의 전보 내역이 기록되어 있습니다.SELECT employees.first_name, dept_emp.from_date, departments.dept_nameFROM employeesJOIN dept_emp ON employees.emp_no = dept_emp.emp_noJOIN departments ON departments.dept_no = dept_emp.dept_no; SQL에는 쿼리 안에 쿼리를 중첩시켜서 중첩된 쿼리의 결과를 바깥쪽 쿼리에서 활용할 수 있는 기능이 있는데, 이렇게 내부에 중첩된 쿼리를 서브쿼리라고 부릅니다. 단일 행 서브쿼리단일 행 서브쿼리는 하나의 행을 반환하는 서브쿼리입니다. 단일 행 서브쿼리는 바깥쪽 쿼리의 WHERE 구문에서 비교를 위해 사용될 수 있습니다. 아래는 ‘1997년도 이전에 최고 연봉을 받은 사람의 이름’을 구하기 위한 쿼리입니다.1234567891011121314151617SELECT emp_no, first_name FROM employeesWHERE emp_no = ( SELECT emp_no FROM salaries WHERE YEAR(from_date) &lt;= '1997' ORDER BY salary DESC LIMIT 1);``` 아래와 같이 `튜플`을 사용해서 여러 컬럼을 동시에 비교할 수도 있습니다. ```sql-- 튜플을 사용하는 서브쿼리의 예를 보여드리기 위한 쿼리이며, 별 의미는 없습니다.SELECT emp_no, first_name FROM employeesWHERE (emp_no, first_name) = ( SELECT emp_no, first_name FROM employees LIMIT 1); 다중 행 서브쿼리다중 행 서브쿼리는 여러 개의 행을 반환하는 서브쿼리입니다. 다중 행 서브쿼리는 바깥쪽 쿼리의 WHERE 구문에서 IN 연산자와 함께 사용됩니다. 아래는 최고 연봉 15만 달러를 달성한 적이 있는 사람들의 이름을 가져오기 위한 쿼리입니다. 12345SELECT first_name FROM employeesWHERE emp_no IN ( SELECT emp_no FROM salaries WHERE salary &gt;= 150000); 서브쿼리와 조인서브쿼리로 짠 쿼리를 조인을 이용해서 짤 수 있는 경우도 있습니다. 위의 첫 번째 예제를 조인을 이용해 다시 작성하면 다음과 같이 됩니다. 123456-- '1997년도 이전에 최고 연봉을 받은 사람의 이름'을 구하기 위한 쿼리SELECT first_name FROM employeesJOIN salaries ON salaries.emp_no = employees.emp_noWHERE YEAR(salaries.from_date) &lt;= '1997'ORDER BY salary DESCLIMIT 1; 다만 모든 서브쿼리를 조인으로 대체할 수 있는 것은 아닙니다. 다음과 같이 서브쿼리를 써야만 가능한 쿼리도 있습니다. 123456789-- '1997년도 이전의 최고 연봉보다 더 많은 연봉을 받은 사람들의 이름'을 구하기 위한 쿼리SELECT DISTINCT first_name FROM employeesJOIN salaries ON salaries.emp_no = employees.emp_noWHERE salary &gt; ( SELECT salary FROM salaries WHERE YEAR(salaries.from_date) &lt;= '1997' ORDER BY salary DESC LIMIT 1); 같은 작업을 하는 쿼리를 조인으로 짤 수도 있고, 서브쿼리로도 짤 수 있다면 둘 중에 어떤 것을 써야 할까요? IN 연산자에 들어가는 서브쿼리의 결과가 크면 연산 속도가 조인에 비해 느려집니다. 123456-- 0.0021 secSELECT first_name FROM employeesWHERE emp_no IN ( SELECT emp_no FROM salaries)LIMIT 1000; 1234-- 0.00075 secSELECT first_name FROM employeesJOIN salaries ON salaries.emp_no = employees.emp_noLIMIT 1000; 대개의 경우, IN 연산자에 들어가는 서브쿼리의 길이가 굉장히 긴 (수십 만 행 이상) 경우에는 조인을, 짧은 경우에는 서브쿼리를 사용하는 것이 빠릅니다. 이것을 외우기 귀찮다면, 조인을 쓸 수 있는 상황에서는 조인을 쓰고, 아니라면 서브쿼리를 쓴다고 외워 두어도 무방합니다. 인덱스 생성하기CREATE INDEX구문을 사용해서 인덱스를 생성할 수 있습니다. 1CREATE INDEX ix_from_date ON salaries(from_date); 다중 컬럼 인덱스를 생성할 수도 있습니다.1CREATE INDEX ix_from_date_to_date ON salaries(from_date, to_date); 인덱스 확인하기앞에서 생성된 인덱스를 SHOW INDEX 구문으로 확인할 수 있습니다. 1SHOW INDEX FROM salaries; Primary Key, Foreign Key기본 키와 외래 키에 대해서는 자동으로 인덱스가 생성되기 때문에, 별도의 인덱스를 만들어줄 필요가 없습니다. Unique 인덱스특정 컬럼(혹은 다중 컬럼)의 값을 유일하게 만드는 제약 조건을 걸고 싶을 때 UNIQUE INDEX를 사용합니다. 1CREATE UNIQUE INDEX ix_uniq_column ON table_name(col_name); 인덱스 제거하기DROP INDEX 구문을 이용해 인덱스를 제거할 수 있습니다. 1DROP INDEX index_name ON table_name; 인덱스의 설계인덱스는 테이블과는 별도로 저장됩니다. 즉, 인덱스도 디스크의 용량을 차지합니다. 또한 미리 정렬을 시켜둬야 하는 인덱스의 성질때문에, 인덱스를 생성한 뒤에는 데이터의 추가나 수정이 느려집니다. 다시 말해서, 인덱스는 읽기 효율을 높이는 대신 쓰기 효율을 희생시킵니다. 테이블에 쓰기가 극단적으로 많이 일어나는 경우에는 인덱스 사용을 재고해보는 것이 좋습니다. 그렇지 않은 경우라면, WHERE 혹은 ORDER BY 구문에서 자주 사용되는 컬럼에 대해서는 인덱스를 걸어두는 것이 좋습니다. 또한 AND 연산으로 엮여서 자주 검색되는 컬럼들에 대해서는 다중 컬럼 인덱스를 생성하는 것이 좋습니다. 실행 계획작성한 쿼리가 인덱스를 잘 활용하고 있는지 확인하려면 EXPLAIN 구문을 사용해서 실행 계획을 확인할 수 있습니다. employees 데이터베이스에 대해 여러 쿼리를 작성해 보고, 해당 쿼리의 실행계획을 확인해보세요. 트랜잭션의 필요성데이터베이스에서는 여러 쿼리에 걸쳐서 데이터를 안전하게 다루기 위해 트랜잭션이라는 기능을 사용합니다. 트랜잭션의 필요성을 말씀드리기 위해 간단히 예를 들어보겠습니다. 한 은행에서 계좌 정보를 관리하기 위해 데이터베이스를 사용하고 있습니다. 한 계좌에서 다른 계좌로 1000원을 옮기기 위해서는, 아래와 같이 데이터베이스에 두 개의 쿼리를 날려야 합니다. 1234-- 첫 번째 쿼리는 'from_account' 계좌에서 1000원을 인출합니다.UPDATE accountSET balance = balance - 1000WHERE account_id = 'from_account'; 1234-- 두 번째 쿼리는 'to_account' 계좌에 1000원을 입금합니다.UPDATE accountSET balance = balance + 1000WHERE account_id = 'to_account' 두 쿼리가 모두 성공적으로 수행된다면, 우리가 처음에 의도했던 작업이 잘 완료됐다고 볼 수 있습니다. 하지만 계좌에 잔액이 부족하거나, 네트워크 오류 혹은 정전 등의 이유로 하나의 쿼리만 실행되고 나머지 하나는 실행이 되지 않는 상황이 발생할 수 있습니다. 즉, 인출은 됐는데 입금이 되지 않은 (혹은 그 반대의) 결과가 나옵니다. 언제 생길 지 알 수 없는 오류 때문에 데이터를 신뢰할 수 없다면, 은행과 같은 기업의 입장에서는 데이터베이스를 사용할 수 없을 것입니다. 이렇게 데이터베이스를 다루다 보면 “여러 쿼리에 걸친 데이터 조작의 신뢰성”을 확보할 필요성이 있습니다. 이를 위해 트랜잭션이라는 기능을 사용합니다. 트랜잭션을 사용하면, 여러 개의 쿼리 중 하나라도 실패했을 때 데이터베이스의 상태를 원상복귀 시킬 수 있습니다. 트랜잭션의 사용START TRANSACTION 구문을 사용하면 현재 커넥션에 대해 트랜잭션이 시작됩니다. 1START TRANSACTION; 트랜잭션을 시작한 다음에는 평소처럼 쿼리를 실행할 수 있습니다. 12INSERT INTO employees (emp_no, birth_date, first_name, last_name, gender, hire_date)VALUES (876543, '1980-03-05', 'Georgi', 'Jackson', 'M', '2017-09-11'); 여러 번의 쿼리를 통해 필요한 작업을 완료한 뒤에는, COMMIT 구문으로 현재까지의 변경사항을 데이터베이스에 반영해주어야 합니다.1COMMIT; 만약, 쿼리를 하는 도중에 이제까지 트랜잭션 안에서 했던 모든 작업을 취소하고 싶은 경우에는 ROLLBACK 구문을 사용하면 됩니다.1ROLLBACK; 트랜잭션의 격리커밋하기 전에는 트랜잭션 내에서 변경된 사항을 다른 커넥션에서 볼 수 없습니다. (단, READ COMMITTED 이상의 격리 수준인 경우에 한정) 이런 성질을 트랜잭션의 격리(isolation) 라고 부릅니다. MySQL은 다양한 격리 수준(isolation level)을 지원합니다. 자세한 사항은 공식문서 및 이 글을 참고해주세요. 123-- 위의 INSERT 쿼리를 실행하고 COMMIT을 하지 않은 경우에, 아무 결과도 안 뜹니다.SELECT * FROM emplyeesWHERE emp_no = 876543; ACID의 성격에 대해서 알아둬야한다. 데이터 모델링데이터 모델링은 현실 세계의 개념을 데이터베이스의 세계에서 다룰 수 있도록 재해석하는 작업을 말합니다. 데이터 모델링을 하기 위해서는 먼저 모델링의 대상이 되는 현실 세계를 잘 이해할 필요가 있습니다. 이를 위해 데이터 요구사항을 정리하고, 관계자와 인터뷰를 하는 등의 활동을 통해 현실 세계에서의 작업이 어떤 절차를 통해 이루어지는지를 자세히 파악해야 합니다. 이 문서에서는 널리 사용되는 모델링 방법인 개체-관계 모델을 다룰 것입니다. 개체-관계 모델을 통해 모델링을 할 때에는, 위에서 파악한 절차로부터 아래의 요소들을 이끌어 내게 됩니다. 개체 (entity) : 절차에 관여하는 어떤 것(thing). 식별 가능한 사람, 장소, 사물, 사건 등속성 (attribute) : 개체가 가지는 성질관계 (relationship) : 개체 간에 가지는 관계데이터베이스에는 각각 아래와 같은 형태로 저장될 수 있습니다. 개체 - 테이블속성 - 개체를 나타내는 테이블의 컬럼관계 - 외래 키, 혹은 관계 테이블 관계의 차수(Cardinality)두 개체 간 관계에서 각 개체의 참여자 수를 차수(cardinality)라고 부릅니다. 차수는 일반적으로 1:1, 1:N, M:N의 세 가지 형태로 분류합니다. 1:1 관계데이터베이스에서는 1:1 관계에 있는 두 엔티티를 하나의 테이블에 저장하거나, 두 엔티티를 각각 다른 테이블에 저장하고 한 테이블의 기본 키를 다른 테이블에 대한 외래 키로 지정하는 등의 방법을 사용해서 1:1 관계를 표현합니다. 1:N 관계데이터베이스에서는 1:N 관계에 있는 두 엔티티를 각각 다른 테이블에 저장하고, N 측의 테이블에 다른 테이블에 대한 외래 키를 둬서 1:N 관계를 표현합니다. M:N 관계데이터베이스에서는 외래 키 하나만 가지고는 M:N 관계를 표현할 수 없으므로, 별도의 관계 테이블을 두고 관계 테이블에 두 개의 외래 키를 두는 방법으로 M:N 관계를 표현합니다. 정규화 (Normalization)정규화란 데이터의 중복을 최소화할 수 있도록 데이터를 구조화하는 작업을 말합니다. 일반적으로, 정규화가 잘 된 데이터베이스는 작고 잘 조직된 여러 개의 테이블로 나누어집니다. 예를 들어서, 어떤 학원의 성적 관리 데이터베이스에서는 성적 데이터를 아래와 같이 저장할 수 있을 것입니다. 정규화를 거치고 나서 테이블이 나뉘어져서 조금 더 복잡해졌지만, 중복되는 데이터가 없어져서 데이터를 관리하기도 쉬워지고 또 데이터가 차지하는 용량도 줄어들었습니다. 보통 데이터 모델링을 할 때에는 정규화 과정을 통해 중복을 없애주는 것이 좋습니다. 다만 성능상의 이유로 일부러 데이터를 중복시켜 저장하는 경우도 있는데, 이를 반정규화라고 합니다. Entity Relationship DiagramERD(Entity Relationship Diagram)은 개체, 속성, 관계를 도표로 나타내는 방법으로, 데이터 모델링의 결과를 시각화하기 위해 널리 사용됩니다. MySQL Workbench을 통해 ERD를 그려볼 수 있습니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Database","slug":"Node-js/Database","permalink":"http://yoursite.com/categories/Node-js/Database/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Database","slug":"Database","permalink":"http://yoursite.com/tags/Database/"}]},{"title":"JavaScript ES6 LinkedList, Tree","slug":"js-study-linkedlist","date":"2017-09-08T03:54:00.000Z","updated":"2017-11-22T13:19:09.000Z","comments":true,"path":"2017/09/08/js-study-linkedlist/","link":"","permalink":"http://yoursite.com/2017/09/08/js-study-linkedlist/","excerpt":"","text":"Javascript LinkedList Linked List Tree Linked List Array vs Linked List Array vs Linked List Size =&gt; Fixed vs Dynamic Insert =&gt; Hard vs Easy Deletion =&gt; Hard vs Easy Random Access(원하는 곳에 한번에 접근할 수 있다) =&gt; Allowed vs Not allowed Extra memory space =&gt; doesn’t need vs required Array vs Linked List o(1) access o(n) o(n) search o(n) o(n) insert o(1) o(n) remove o(1) Create Linked List123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122function LinkedList()&#123; //define Node var Node = function(element)&#123; this.element = element; this.next = null; &#125;; var length = 0; var head = null; //값을 추가하는 method this.append = function(element)&#123; var node = new Node(element), current; if(head === null)&#123; head = node; &#125;else &#123; current = head; // current값이 null일때 까지 돌아간다. while(current.next)&#123; current = current.next; &#125; // 마지막값에 node를 집어넣는다. current.next = node; &#125; length++; &#125;; //특정 위치의 값을 제거하는 method this.removeAt = function(position)&#123; if(position &gt; -1 &amp;&amp; position &lt; length)&#123; var current = head, previous, index=0; if(position === 0)&#123; head = current.next; &#125;else &#123; while(index++ &lt; position)&#123; previous = current; current = current.next; &#125; // 이전값을 덮어 씌운다. previous.next = current.next; &#125; // 값이 1개 지워졌음으로 1 감소. length--; return current.element; &#125;else &#123; return null; &#125; &#125;; // 값을 추가한다. this.insert = function(position, element)&#123; if(position &gt;= 0 &amp;&amp; position &lt;= length&gt;)&#123; var node = new Node(element), current = head, previous, index = 0; //head 에다가 insert를 해주려고 할떄 if(position === 0)&#123; node.next = current; head = node; &#125; else &#123; while(index++ &lt; position)&#123; previous = current; current = current.next; &#125; node.next = current; privious.next = node; &#125; length++; return true; &#125;else &#123; return false; &#125; &#125;; // remove 요소를 제거한다. this.remove = function(element)&#123; var index = this.indexOf(element); return this.removeAt(index); &#125;; this.indexOf = function(element)&#123; var current = head, index = 0; while(current)&#123; if(element === current.element )&#123; return index; &#125; index++; current = current.next; &#125; return false; &#125;; this.isEmpty = function()&#123; return length === 0; &#125;; this.size = function()&#123; return length; &#125;; this.toString = function()&#123; var current = head, string = ''; while(current) &#123; string += current.element; current = current.next; &#125; return string; &#125;; this.getHead = function()&#123; return head; &#125;;&#125; Tree root: 2 level: (0 ~ 3) child of 2: 7,5 subtree: 6,5,11 Node: (9) edge: (8) Binary Search Tree2진 탐색 트리이다. 왼쪽에는 작은값 오른쪽에는 큰 값이 존재한다. 123456789101112131415161718192021222324252627282930313233343536373839function BinarySearchTree()&#123; var Node = function(key)&#123; this.key = key; this.left = null; this.right = null; &#125;; var root = null; function insertNode(node, newNode)&#123; if(newNode.key &lt; node.key)&#123; if(node.left === null)&#123; node.left = newNode; &#125;else &#123; insertNode(node.left, newNode); &#125; &#125;else &#123; if(node.right === null)&#123; node.right = newNode; &#125;else &#123; insertNode(node.right, newNode); &#125; &#125; &#125;; this.insert = function(key)&#123; var newNode = new Node(key) if(root === null)&#123; root = newNode; &#125;else &#123; insertNode(root, newNode); &#125; &#125;;&#125; Binary Search Tree - inOrderTraverse 왼쪽 가운데 오른쪽 순서로 탐색한다. 1234567891011var inOrderTraverseNode = function(node, callback)&#123; if(node !== null)&#123; inOrderTraverseNode(node.left, callback); callback(node.key); inOrderTraverseNode(node.right, callback); &#125;&#125;this.inOrderTraverse = function(callback)&#123; inOrderTraverseNode(root, callback);&#125;; Binary Search Tree - preOrderTraverse 가운데 왼쪽 오른쪽 순서로 탐색한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// preOrderTraversefunction BinarySearchTree()&#123; var Node = function(key)&#123; this.key = key; this.left = null; this.right = null; &#125;; var root = null; function insertNode(node, newNode)&#123; if(newNode.key &lt; node.key)&#123; if(node.left === null)&#123; node.left = newNode; &#125;else &#123; insertNode(node.left, newNode); &#125; &#125;else &#123; if(node.right === null)&#123; node.right = newNode; &#125;else &#123; insertNode(node.right, newNode); &#125; &#125; &#125;; this.insert = function(key)&#123; var newNode = new Node(key) if(root === null)&#123; root = newNode; &#125;else &#123; insertNode(root, newNode); &#125; &#125;; // preorderTraverse var preOrderTraverseNode = function(node, callback)&#123; if(node !== null)&#123; callback(node.key); preOrderTraverseNode(node.left, callback); preOrderTraverseNode(node.right, callback); &#125; &#125; this.preOrderTraverse = function(callback)&#123; preOrderTraverseNode(root, callback); &#125;; function printNode(value) &#123; console.log(value); &#125;&#125; Binary Search Tree - postOrderTraverse 오른쪽 가운데 왼쪽 순서대로 탐색한다. 1234567891011var postOrderTraverseNode = function(node, callback)&#123; if(node !== null)&#123; postOrderTraverseNode(node.right, callback); callback(node.key); postOrderTraverseNode(node.left, callback); &#125;&#125;this.postOrderTraverse = function(callback)&#123; postOrderTraverseNode(root, callback);&#125;; Binary Search Tree - find min/max value123456789101112131415161718192021222324252627282930313233this.min = function()&#123; return minNode(root);&#125;;var minNode = function(node)&#123; if(node)&#123; while(node &amp;&amp; node.left !== null)&#123; node = node.left; &#125; return node.key; &#125; return null;&#125;;this.max = function()&#123; return maxNode(root);&#125;;var maxNode = function(node)&#123; if(node)&#123; while(node &amp;&amp; node.right !== null)&#123; node = node.right; &#125; return node.key; &#125; return null;&#125;; Binary Search Tree - find specific value 특정 값을 찾기 12345678910111213141516171819 this.search = function()&#123; return searchNode(root, key); &#125;; var serachNode = function(node, key)&#123; if(node === null)&#123; return false; &#125; if(key &lt; node.key)&#123; return searchNode(node.left, key); &#125; else if(key &gt; node.key)&#123; return searchNode(node.right, key); &#125; else &#123; return true; &#125; &#125;console.log(tree.search(1) ? 'Key 1 found.' : 'Key 1 not found.'); gulp1$ npm install --save-dev gulp-imagemin gulp-imagemin : image minify1234567gulp.task(\"imagemin\", function()&#123; pump([ gulp.src(publicPath.src + 'img/*.jpg'), imagemin(), gulp.dest(publicPath.dest + 'img/') ]);&#125;); css minify(gulp-clean-css) : css minify1234567gulp.task(\"cleancss\", function()&#123; pump([ gulp.src(publicPath.src + 'css/minify.css'), cleancss(), gulp.dest(publicPath.dest + 'css/') ]);&#125;); gulp-sass : convert .scss to .css1234567gulp.task(\"sass\", function()&#123; pump([ gulp.src(publicPath.src + 'sass/*.scss'), sass().on('error', sass.logError), gulp.dest(publicPath.dest + 'css/') ]);&#125;); gulp-concat-css : concatenate css files1234567gulp.task(\"concatcss\", function()&#123; pump([ gulp.src([publicPath.src + 'css/concat1.css', publicPath.src + 'css/concat2.css']), concat('concatenated.css'), gulp.dest(publicPath.dest + 'css/') ]);&#125;); clean(del)123gulp.task(\"clean\", function()&#123; return del.sync([publicPath.dest + 'js/*.js', publicPath.dest + 'css/*.css', publicPath.dest + 'img/']); &#125;); watch12345gulp.task(\"watch\", function()&#123; gulp.watch(\"public/src/*.js\", [\"uglify\"]);&#125;);gulp.task(\"default\", [\"uglify\", \"watch\"]); watch123456gulp.task(\"watch\", function()&#123; gulp.watch(publicPath.src + 'js/*.js', [\"uglify\", \"concat\"]), gulp.watch(publicPath.src + 'css/*.css', [\"cleancss\", \"concatcss\"]), gulp.watch(publicPath.src + 'img/*.jpg', [\"imagemin\"]), gulp.watch(publicPath.src + 'sass/*.scss', [\"sass\"]) +&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"LinkedList Tree","slug":"JavaScript/LinkedList-Tree","permalink":"http://yoursite.com/categories/JavaScript/LinkedList-Tree/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://yoursite.com/tags/LinkedList/"},{"name":"Tree","slug":"Tree","permalink":"http://yoursite.com/tags/Tree/"}]},{"title":"Node-GraphQL","slug":"node-study-http-cache","date":"2017-09-06T03:54:00.000Z","updated":"2017-09-21T02:17:13.000Z","comments":true,"path":"2017/09/06/node-study-http-cache/","link":"","permalink":"http://yoursite.com/2017/09/06/node-study-http-cache/","excerpt":"","text":"HTTP CacheCache컴퓨터 분야에서의 캐시는(주로 접근 속도의 개선을 위해) 데이터를 미리 복사해 놓는 임시 저장소, 혹은 그 임시 저장소에 데이터를 저장하는 행위를 가리킴 cache 혹은 caching이라는 용어 자체는 특정 기술을 가리키는 것이 아니라,접근 속도를 개선하기 위해 따로 저장소를 두는 ‘방법’을 가리킴 컴퓨터의 아주 많은 부분(CPU, GPU, HDD, 네트워크, 웹, 데이터베이스…)에서 사용되고 있음 HTTP Cache 자원의 효율적 로딩을 위한 웹 표준 서버에서 가져온 자원(HTML, CSS, JS, 이미지, …)을 가까운 곳(브라우저, 혹은 다른 서버)에 저장해놓고 재사용 캐시를 할 것인지 말 것인지, 어떻게 할 것인지를 결정하는 규칙이 복잡하고, 브라우저마다 조금씩 다름 Common Problem캐시된 자원과 실제 자원의 내용이 달라지는 문제를 어떻게 해결할 것인가? SolutionExpiration(만료) 정해진 시간이 지나면 캐시가 자동으로 삭제되도록 설정 Validation(검증) 서버에 요청을 보내서 캐시를 계속 사용할 수 있는지 확인 Cache 관련 헤더Cache 범주Conditionals 범주 Cache-Control (요청, 응답) 캐시와 관련된 다양한 기능을 하는 지시자를 포함. no-cache, max-age가 많이 사용됨. no-cache, max-age=0 지시자는 캐시를 사용하지 않도록 하거나, 캐시를 아직도 쓸 수 있는지 검증하기 위해 사용됨 각각의 자세한 의미 ETag (응답) 캐시의 검증을 위해 사용되는 자원의 식별자. 주로 자원의 해시값이 사용되나, 마지막으로 수정된 시각, 혹은 버전 넘버를 사용하기도 함 Expires (응답) 캐시를 만료시킬 시각을 서버에서 명시적으로 지정 Last-Modified (응답) 원래 자료가 마지막으로 수정된 시각 If-None-Match (요청) 검증을 위해 사용됨. 이전에 저장해두었던 자원의 ETag 값을 If-None-Match 헤더의 값으로 요청에 포함시켜서 보내면, 서버는 해당 경로에 있는 자원의 ETag와 비교해보고 자원의 전송 여부를 결정 If-Modified-Since (요청) 검증을 위해 사용됨. 이전에 저장해두었던 자원의 Last-Modified 값을 If-Modified-Since 헤더의 값으로 요청에 포함시켜서 보내면, 서버는 해당 경로에 있는 자원의 Last-Modified와 비교해보고 자원의 전송 여부를 결정 브라우저 실습Link Response의 etag와 Request의 if-none-match가 일치하면 브라우저와 서버가 자원의 변경이 없다는 것을 알 수 있다 그러면 HTML파일을 다시보낼 필요가 없으니 304응답이 되는 것이다 (304통신이란? 통신이 되어서 헤더는 이동해도 HTML은 이동하지 않는다) 이것을 검증작업이라고 한다. cache를 사용하지 않을 경우 Disable cache를 사용한다. cache를 새로고침하려면 command+shift+r을 누르면 된다. Cacheable MethodsPOST 메소드는 Cacheable 범주에 포함되기는 하지만, 특별한 조건을 만족시켜야 하며 실무에서는 POST cache가 거의 사용되지 않습니다. Get, Head만 cache가 가능하다. 캐시의 사용 브라우저는 이미 캐시를 잘 활용하도록 만들어져 있습니다. Express는 이미 캐시를 잘 활용하도록 만들어져 있습니다. 일단은 별다른 추가작업 없이도 편하게 캐시 기능을 사용할 수 있지만, 우리가 원하는대로 캐시가 동작하지 않을 때 그 원인을 파악하기 위해 캐시 관련 헤더는 숙지해두는 것이 좋습니다. 그리고 HTTP method를 용도에 맞게 사용하는 것도 중요합니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"http-cache","slug":"Node-js/http-cache","permalink":"http://yoursite.com/categories/Node-js/http-cache/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"cache","slug":"cache","permalink":"http://yoursite.com/tags/cache/"}]},{"title":"Node-GraphQL","slug":"node-study-graphql","date":"2017-09-06T03:54:00.000Z","updated":"2017-09-21T02:17:10.000Z","comments":true,"path":"2017/09/06/node-study-graphql/","link":"","permalink":"http://yoursite.com/2017/09/06/node-study-graphql/","excerpt":"","text":"Node GraphQLREST API의 단점 각각의 자원마다 경로가 따로 있음. 즉, 여러 자원이 동시에 필요한 경우에는 요청을 여러 번 보내야 함 (요청의 횟수 면에서 비효율적) (보통의 경우) 자원의 필요한 속성만 얻어올 수 없음. 즉, 일부 속성의 필요하더라도 전체 속성을 가져와야만 함 (요청의 용량 면에서 비효율적) GraphQL Facebook에서 2015년 공개한 데이터 질의 언어 REST API를 대체하기 위해 만들어짐 클라이언트에서 필요한 데이터의 구조를 GraphQL 언어로 정의한 후 질의할 수 있고, 서버는 그에 맞게 구조화된 데이터를 응답 서버에서는 GraphQL 질의를 해석하기 위해 별도의 해석기가 필요하며, 여러 언어의 구현체가 나와있는 상태 Example1234567// request&#123; human(id:\"1000\")&#123; name height &#125;&#125; 123456789//response&#123; \"data\": &#123; \"human\":&#123; \"name\": \"Luke Skywalker\", \"height\":1.72 &#125; &#125;&#125; 내가 원하는 자료만 받아 올 수 있다. Github Graph API 실습Link 참고 링크 https://dev-blog.apollodata.com/graphql-vs-rest-5d425123e34b http://graphql.org/learn/","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"GraphQL","slug":"Node-js/GraphQL","permalink":"http://yoursite.com/categories/Node-js/GraphQL/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"GraphQL","slug":"GraphQL","permalink":"http://yoursite.com/tags/GraphQL/"}]},{"title":"Node-SPA(Single Page Application)","slug":"node-study-spa","date":"2017-09-06T03:54:00.000Z","updated":"2017-09-21T02:18:50.000Z","comments":true,"path":"2017/09/06/node-study-spa/","link":"","permalink":"http://yoursite.com/2017/09/06/node-study-spa/","excerpt":"","text":"Node Single-page ApplicationSPA의 구조 ejs를 사용하여서 웹개발을 하게되면 전체를 다시 새로고침을 해야한다. SPA 구조를 사용하면 Ajax를 통하여 부분만 고쳐준다. SPA 실습Link data 부분을 node.js module로 빼뒀다. npm으로 설치한 module은 경로지정이 없어도 불러와 지지만 직접만든 module은 경로를 입력해줘야한다. send, end를 통해서 SPA를 구현한다. (redirect, render가 필요없다) 비관적 업데이트(pessimistic) event 발생시 ajax 요청을 보낼때 실패 or 성공을 모른다 ajax응답을 기다리다가 응답이 온뒤에 화면을 갱신 낙관적 업데이트(optimistic) ajax 요청과 화면 갱신을 같은 단계에 한다 그리고 미리 화면을 갱신하는데 이것은 ajax요청이 성공하면 끝난다. ajax요청이 실패하면 취소 or 에러처리 요즘 자주 사용한다. 개선 예시 title 수정 기능 ‘기한’ 디자인 개선 로그인 cookie session사용. 데이터 유지","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"SPA","slug":"Node-js/SPA","permalink":"http://yoursite.com/categories/Node-js/SPA/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"SPA","slug":"SPA","permalink":"http://yoursite.com/tags/SPA/"}]},{"title":"Node-jwt","slug":"node-study-jwt","date":"2017-09-05T03:54:00.000Z","updated":"2017-10-04T11:41:45.000Z","comments":true,"path":"2017/09/05/node-study-jwt/","link":"","permalink":"http://yoursite.com/2017/09/05/node-study-jwt/","excerpt":"","text":"Node JWT쿠키의 단점 쿠키를 지원하는 클라이언트에서 밖에 사용할 수 없음 적절히 관리되지 않은 쿠키는 보안에 취약하며, 관리를 하려고 해도 CORS 대응이 복잡함 Token Based Auth 토큰이란, 사용자의 자격증명(아이디, 패스워드 등)을 통해 인증이 이루어진 후, 특정 자원에 대한 자격증명으로서 대신 사용되는 인증 수단 서버에 요청을 할 때마다 토큰을 요청에 직접 포함시켜서 전송 (주로 Authorization 헤더에 넣어서 전송) Cookie vs Token token을 사용할때는 프론트와 백엔드가 다른 url을 사용할때 자주 사용된다. client side의 js가 token 정보를 기억한다. 토큰 사용의 장점 다양한 인증 수단(전화번호, 공인인증서, 생체정보 등)의 인증 결과를 토큰이라는 하나의 수단으로 통일할 수 있음 쿠키를 사용하지 않음으로써 CORS 관련 문제를 회피할 수 있음 토큰 사용의 단점 매 요청에 토큰이 포함되게 되므로 적당히 짧은 길이를 유지해야 함 토큰 유출에 대한 대비책이 필요 (토큰에 유효기간을 두거나, 유출된 토큰을 강제로 무효화하는 등의 방법을 사용) 쿠키와는 다르게, 클라이언트에서 직접 토큰을 저장하고 관리해야 함 Web Storage 브라우저에서 키-값 쌍을 저장할 수 있는 저장소 쿠키에 비해 사용하기 편리하고 저장 가능한 용량도 큼(10MB 가량) 브라우저 탭이 닫히면 내용이 삭제되는 sessionStorage, 브라우저 탭이 닫혀도 내용이 유지되는 localStorage가 있음 localStorage.setItem(‘foo’, ‘bar’) // key value 저장가능 보안 상 주의사항 토큰을 localStorage에 저장하게 되면 자바스크립트로 토큰을 탈취할 수 있게 되므로, 웹사이트에 악성 스크립트를 삽입하는 공격(XSS)에 노출되지 않도록 신경써야 함 직접 DOM API를 사용하는 대신 EJS, React 같은 템플릿 언어를 사용하기만 해도 XSS에 대한 방어는 충분함 token 기반으로 사용할 때는 서명을 해주면 보안성을 높힐수있다. 암호화는 성능을 많이 낭비하게된다. JSON Web Token 최근 널리 사용되고 있는 토큰 형식의 표준 토큰 안에 JSON 형식으로 정보를 저장함 보안을 위해 서명 또는 암호화를 사용할 수 있음jwt.io JWT 실습Link server.js를 다이해해두는 것이 좋다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101const express = require('express')const bodyParser = require('body-parser')/** * JWT의 사용을 위해 두 패키지가 필요합니다. * jsonwebtoken: JWT의 생성과 검증을 위한 범용 패키지입니다. 여기에서는 JWT 생성을 위해 사용하고 있습니다. * express-jwt: JWT가 요청에 포함되어 서버에 들어왔을 때, 해당 토큰을 검증 및 변환해서 `req.user`에 저장해주는 express 미들웨어입니다. */ // token만들때 사용하는 비밀키 SECRET을 넣어줘야한다.const jwt = require('jsonwebtoken')const expressJwt = require('express-jwt')// 토큰의 서명을 위해 필요한 비밀 키를 저장해둡니다.const SECRET = 'mysecret'const app = express()const jsonMiddleware = bodyParser.json()app.use(express.static('public'))/** * 인증 미들웨어 생성 * * `expressJwt()`로 생성된 미들웨어의 기능은 다음과 같습니다. * * 1. `Authorization: Bearer &lt;token&gt;` 형태로 jwt가 들어왔는지 검사하고 * 2. 토큰이 없으면 401 Unauthorized 응답을 보낸다. * 3. 토큰이 있으면 토큰에 들어있는 JSON 정보를 객체로 변환한 후 `req.user`에 저장한다. * * 미들웨어 생성 시에 서명에 필요한 secret을 전달해 줍니다. */const authMiddleware = expressJwt(&#123;secret: SECRET&#125;)const users = [ &#123; username: 'fast', password: 'campus', isAdmin: true &#125;, &#123; username: 'foo', password: 'bar' &#125;]/** * `/auth` 경로로 들어온 사용자 이름과 비밀번호를 users 배열과 대조한 후 * 일치하는 계정이 있다면 해당 계정 정보를 가지고 JWT 토큰을 만들어서 응답한다. */app.post('/auth', jsonMiddleware, (req, res) =&gt; &#123; const &#123;username, password&#125; = req.body const matched = users.find(user =&gt; user.username === username &amp;&amp; user.password === password) if (matched) &#123; // `jwt.sign` 메소드는 새로운 JWT 토큰을 생성한다. // 토큰에 넣을 객체와 서명에 필요한 secret을 전달한다. const token = jwt.sign(&#123;username, isAdmin: matched.isAdmin&#125;, SECRET) res.send(&#123; ok: true, token &#125;) &#125; else &#123; // 일치하는 계정이 없으면 400 응답 res.status(400) res.send(&#123; ok: false, error: 'No matched user' &#125;) &#125;&#125;)/** * 토큰에 들어있는 정보를 그대로 반환하는 라우트 핸들러 */app.get('/auth', authMiddleware, (req, res) =&gt; &#123; res.send(req.user)&#125;)/** * JWT로 인증이 된 요청만 API를 사용할 수 있게 해준다. */app.get('/some-api', authMiddleware, (req, res) =&gt; &#123; res.send(&#123; ok: true, message: 'Hello JWT!' &#125;)&#125;)let count = 0app.post('/count', authMiddleware, (req, res) =&gt; &#123; count += 1 res.send(&#123; ok: true, count &#125;)&#125;)app.listen(3000, () =&gt; &#123; console.log('listening...')&#125;) const token = jwt.sign({username, isAdmin: matched.isAdmin}, SECRET) 서명을 할때 SECRET이라는 비밀키를 생성한다 Axios는 get, header, delete 같은 읽기전용은 인자를 2개만 받는데 post, fetch, 이런값들은 인자를 3개를 받는다. 2번째 인자로 받을 데이터를 넣는다. 123456789101112131415161718192021222324252627282930313233// 토큰 받아오기let token;axios.post('/auth', &#123; username: 'fast', password: 'campus'&#125;).then(res =&gt; &#123; token = res.data.token console.log(`token: $&#123;token&#125;`)&#125;)// 토큰으로 요청하기 1axios.get('/auth', &#123; headers: &#123; 'Authorization': `Bearer $&#123;token&#125;` &#125;&#125;).then(res =&gt; &#123; prettyPrint(res.data)&#125;)// 토큰으로 요청하기 2axios.get('/some-api', &#123; headers: &#123; 'Authorization': `Bearer $&#123;token&#125;` &#125;&#125;).then(res =&gt; &#123; prettyPrint(res.data)&#125;)// 토큰으로 요청하기 3axios.post('/count', null, &#123; headers: &#123; 'Authorization': `Bearer $&#123;token&#125;` &#125;&#125;).then(res =&gt; &#123; prettyPrint(res.data)&#125;) 중복되는 값을 제거하기 위한 방법으로는 Axios instance를 만들면 된다. 123456789101112131415// Axios.createconst authedAxios = axios.create(&#123; headers: &#123; 'Authorization': `Bearer $&#123;token&#125;` &#125;&#125;)authedAxios.get('/auth').then(res =&gt; &#123; prettyPrint(res.data)&#125;)authedAxios.get('/some-api').then(res =&gt; &#123; prettyPrint(res.data)&#125;)authedAxios.post('/count').then(res =&gt; &#123; prettyPrint(res.data)&#125;) 참고링크 https://jwt.io/introduction/ https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage https://blog.outsider.ne.kr/1160 https://velopert.com/2448 https://auth0.com/blog/json-web-token-signing-algorithms-overview/","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"JWT","slug":"Node-js/JWT","permalink":"http://yoursite.com/categories/Node-js/JWT/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"JWT","slug":"JWT","permalink":"http://yoursite.com/tags/JWT/"}]},{"title":"Node-CORS","slug":"node-study-cors","date":"2017-09-05T03:54:00.000Z","updated":"2017-09-21T02:17:02.000Z","comments":true,"path":"2017/09/05/node-study-cors/","link":"","permalink":"http://yoursite.com/2017/09/05/node-study-cors/","excerpt":"","text":"Node CORS보내는쪽과 받는쪽의 Domain이 다를때 발생하는 문제 Some-origin Plicy(동일 출처 정책) 웹페이지에서 리소스를 불러올 때, 리소스의 출처가 웹페이지의 출처와 같으면 안전하다고 보고, 출처가 다르면 해당 리소스는 안전하지 않다고 보는 원칙 여기서 &#39;출처&#39;란 &#39;프로토콜 + 도메인 + 포트번호&#39;의 결합을 가리킴. 즉, 세 개가 다 같아야 동일 출처라고 할 수 있고, 셋 중에 하나라도 다르면 동일 출처로 간주되지 않음 웹 보안의 기본 원칙으로, 웹 브라우저의 많은 요소에 적용됨 Same-origin Policy 실습12345678910111213&gt; const child = window.open('http://www.fastcampus.co.kr')// 새로 열린 웹 페이지의 콘솔에서&gt; window.foo = 'bar'// 이전 웹 페이지의 콘솔에서&gt; child.foo// 출처가 같다면 접근 가능, 아니면 불가// fastcampus 홈페이지에서 naver를 오픈한다.&gt; const naver = window.open('https://naver.com') // naver가 실행되는데 naver의 콘솔에서 만든 foo는 적용이 안된다.&gt; foo = 'bar'// fastcampus쪽에서 naver.foo를 하면 에러가난다.&gt; naver.foo // error 이러한 에러를 same-origin policy 이라고 한다. Content-Security-PolicyContent-Security-Policy 헤더를 이용하면, 동일하지 않은 출처에 대한 리소스를 불러올지 말지 결정할 수 있음 CORSCross-Origin Resource Sharing 클라이언트 측 cross-origin 요청을 안전하게 보낼 수 있는 방법을 정한 표준 쉽게 말하면, 스크립트가 전혀 다른 출처를 갖는 API 서버를 사용하려고 하는 상황에서는 뭔가 추가적인 처리를 해주어야 한다는 것! 도메인이 다를때 서로 통신하는 방법 Cross-origin 요청의 위험성아래 상황을 가정해봅시다. mywebsite.com에서 서비스 중인 웹 사이트는 mywebsite.com/api 에서 REST API를 통해 필요한 정보를 얻습니다. mywebsite.com/api 경로에 대한 인증은 쿠키로 이루어지고 있습니다. 그런데 만약 evil.com 웹 사이트의 스크립트에서 mywebsite.com API에 요청을 마음대로 보낼 수 있다면, 이미 my-website.com 도메인에 대해 브라우저에 저장된 쿠키를 이용해서 API를 마음대로 호출할 수 있을 것입니다. 쿠키는 요청을 하기만하면 자동으로 보내진다. Cross-origin 요청 예제 IE8 이상의 모던 웹 브라우저는 cross-origin 요청에 대해 여러가지 제한을 두고 있음 cross-origin 요청을 허용하려면, 서버가 특별한 형태의 응답을 전송해야 함 만약 서버가 cross-origin 요청을 허용하지 않으면, 웹 브라우저는 에러를 발생시킴 어느 웹페이지는 허락하고 거절할지에 대해서 서버단에서 설정할 수 있다.Link 참고express를 비롯한 일반적인 웹 서버는 별도의 설정을 하지 않으면 cross-origin 요청을 모두 불허(즉 웹브라우저가 거부)하도록 만들어져 있습니다. 그런데 json-server는 개발자의 편의를 위해 쿠키가 포함되어있지 않은 모든 cross-origin 요청을 허용하도록 만들어져 있습니다. 본 예제의 원활한 진행을 위해, json-server가 일반적인 웹 서버와 같이 cross-origin 요청을 허용하지 않도록 설정한 부분이 wpsn-axios-example의 코드를 보시면 나와있습니다. get은 그냥 보내는데 나머지는 options로 보낸다. CORS에 관여하는 응답 헤더 Access-Control-Allow-Origin 서버를 허용해 줄 때 Access-Control-Expose-Headers Access-Control-Max-Age Access-Control-Allow-Credentials 쿠키를 추가하는 명령도 받는다. Access-Control-Allow-Methods 특정 Method만 받는다. Access-Control-Allow-Headers 특정 Header만 받는다. CORS에 관여하는 요청 헤더 Origin Access-Control-Request-Method (preflighted 전용) Access-Control-Request-Headers (preflighted 전용) CORS - Safe, Unsafe GET, HEAD 요청은 safe(읽기 전용)이기 때문에 서버에 요청이 도달한다고 해서 서버의 상태에 영향을 미칠 일은 없으므로, 웹 브라우저는 일단 해당 요청을 보내본다. 만약 서버가 cross-origin 요청을 허용한다고 응답하면 응답을 그대로 사용하고, 그렇지 않으면 에러를 낸다. POST, PUT, PATCH, DELETE 등의 메소드는 요청이 서버에 전송되는 것 자체가 위험하므로, 실제 요청을 보내기 전에 서버가 cross-origin 요청을 허용하는지를 알아보기 위해 시험적으로 요청을 한 번 보내본다.(options) 이 요청을 preflighted request라고 한다. (단, 기존 HTML form의 동작방식인 application/x-www-form-urlencoded 혹은multipart/form-data 형태의 POST 요청은 preflighted request가 발생하지 않음) safe, unsafe 말고도 다른 원인에 의해 preflighted request가 발생하는 경우가 있는데, 자세한 사항은 MDN 문서를 참고해주세요. CORS with credentialscross-origin 요청에는 기본적으로 쿠키가 포함되지 않으나, XMLHttpRequest 혹은 fetch를 통해서 요청을 보낼 때 쿠키를 포함시키는 옵션을 줄 수 있고 이 때 CORS 요건이 더 엄격해짐 (Access-Control-Allow-Credentials 헤더 설정 필요, Access-Control-Allow-Origin 헤더에 와일드카드 허용 안됨) cross-origin Ajax 요청에는 기본적으로 쿠키가 포함되지 않으나 옵션을 줘서 쿠키를 포함시켜서 보낼 수 있지만 보안 정책이 더욱 엄격해진다. 복잡하면 그냥… 프론트엔드와 API 서버를 같은 도메인으로 제공한다. 불가피하게 둘을 다른 도메인으로 제공해야 한다면 CORS를 허용한다 (cors 미들웨어를 사용하면 간단함) CORS를 허용했으므로 쿠키를 쓰지 않는다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"CORS","slug":"Node-js/CORS","permalink":"http://yoursite.com/categories/Node-js/CORS/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"CORS","slug":"CORS","permalink":"http://yoursite.com/tags/CORS/"}]},{"title":"Node-Ajax","slug":"node-study-ajax","date":"2017-09-05T03:54:00.000Z","updated":"2017-10-04T11:40:44.000Z","comments":true,"path":"2017/09/05/node-study-ajax/","link":"","permalink":"http://yoursite.com/2017/09/05/node-study-ajax/","excerpt":"","text":"Node AjaxAjax비동기적인 웹 어플리케이션의 제작을 위한 클라리언트 측 웹 개발 기법요즈음은 의미가 변형되어 웹 브라우저에서 XMLHttpRequest 혹은 fetch를 이용해서 보내는 HTTP 요청을 통칭하기도 함 Ajax Model Ajax의 장점 화면 전체를 다시 로드하지 않고도 내용을 갱신할 수 있어 더 나은 사용자 경험 제공 서버의 응답을 기다리는 동안에도 여전히 웹 어플리케이션을 사용 가능 필요한 자원만 서버에서 받아오게 되므로 트래픽이 줄어듬 Ajax의 단점 클라이언트 구현이 굉장히 복잡해짐 Ajax Library ComparisonAxios를 사용한다. Axios Promise based HTTP client 브라우저와 Node.js에서 모두 사용 가능 XMLHttpRequest, fetch에 비해 사용하기 편하고 기능이 더 많음 fetch는 취소가안되서 Axios를 더 사용하게된다. Axios + json-server 예제Link GET 자료읽기POST 자료 생성PUT 자료 갱신(값을 통째로 다 바꾼다 = 치환)PATCH 자료 갱신DELETE 삭제 Axios는 기본적으로 json을 받는다. 12345678axios.get('/api/todos/1') .then(res =&gt; &#123; console.log(`status code: $&#123;res.status&#125;`) console.log('headers:') prettyPrint(res.headers) console.log('data:') prettyPrint(res.data) &#125;) 상태 코드(res.status), 응답 헤더 (res.headers), 데이터 쿠키를 통한 인증 예제Link AxiosAxios는 최근 인기를 끌고 있는 HTTP client입니다. 브라우저에서 사용하면 XMLHttpRequest를 사용하여 Ajax 요청을 보내고, Node.js에서 사용하면 내장 http 모듈을 이용해 요청을 보냅니다. 사용법이 아주 간단하며 Promise 기반으로 깔끔한 코드를 작성할 수 있습니다. 상단의 Show 버튼을 누르고 개발자 도구의 콘솔을 열어 예제 코드를 입력해보세요. axios 변수가 미리 로드되어 있습니다. json-server + express이 프로젝트는 json-server 패키지를 사용해 REST API를 제공하고 있습니다. json-server는 내부적으로 express를 사용하고 있어서 커맨드라인을 통해서 json-server를 실행시키지 않고 직접 자바스크립트 파일에서 불러와 사용할 수 있습니다. 보통의 express 객체를 사용하듯이 사용할 수 있어서 필요한 경로에 미들웨어를 마음대로 추가할 수 있습니다. server.js 파일을 참고해주세요. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 const jsonServer = require('json-server')const fs = require('fs')const cookieSession = require('cookie-session')const bodyParser = require('body-parser')// json-server의 구성요소들을 생성합니다.const server = jsonServer.create()const router = jsonServer.router('.data/db.json')const middlewares = jsonServer.defaults()// 쿠키를 glitch에서 사용하기 위해 필요한 설정입니다.server.set('trust proxy', 1)// cookie-session 미들웨어를 주입합니다.server.use(cookieSession(&#123; name: 'session', secret: 'secret'&#125;))// json-server가 제공하는 미들웨어를 주입합니다.server.use(middlewares)// 사용자 데이터를 관리할 데이터베이스가 필요한데// json-server로 관리되는 데이터에 접근하기 어렵기 때문에// 사용자 데이터만 아래와 같이 따로 배열로 관리합니다.const users = [ &#123;username: 'fast', password: 'campus'&#125;, &#123;username: 'node', password: 'js'&#125;, &#123;username: 'react', password: 'facebook'&#125;]// 인증을 위한 라우트 핸들러입니다.// bodyParser.json json을 다루는 미들웨어이다.server.post('/auth', bodyParser.json(), (req, res) =&gt; &#123; const &#123;username, password&#125; = req.body // const username = req.body.username // const password = req.body.password const matched = users.find(user =&gt; user.username === username &amp;&amp; user.password === password) if (matched) &#123; req.session.username = username res.send(&#123;ok: true, data: &#123;users&#125;&#125;) // res.end() &#125; else &#123; res.status(400) res.send(&#123;ok: false, message: '400 Bad Request'&#125;) // res.end() &#125;&#125;)// 로그아웃을 위한 라우트 핸들러입니다.server.delete('/auth', (req, res) =&gt; &#123; req.session = null res.end()&#125;)// `/api` 경로의 인증을 담당하는 미들웨어입니다.function authMiddleware(req, res, next) &#123; if (!req.session.username) &#123; res.status(401) res.send('401 Unauthorized') &#125; else &#123; next() &#125;&#125;server.use('/api', authMiddleware, router)server.listen(3000, () =&gt; &#123; console.log('JSON Server is running')&#125;) 쿠키를 통한 인증 예제현재 authMiddleware로 인해 /api 경로로 요청을 해도 401 응답이 오는 상태입니다. /auth 경로로 인증 요청을 보낸 후, 쿠키의 변경사항을 확인하시고 /api 경로로 요청을 보내보세요. 모든 요청을 보낸 후에 로그아웃 요청을 보낸 후, 로그아웃이 잘 되었는지 확인해보세요. 로그인1234567// 로그인axios.post('/auth', &#123; username: 'fast', password: 'campus'&#125;).then(res =&gt; &#123; prettyPrint(res.data)&#125;) 12345678로그아웃// 로그아웃axios.delete('/auth') .then(res =&gt; &#123; prettyPrint(res.data) &#125;)아래부터는 이전 예제와 동일한 내용입니다. 1234567GET /api/todos// GETaxios.get('/api/todos') .then(res =&gt; &#123; prettyPrint(res.data) &#125;) 1234567POST /api/todos// POSTaxios.post('/api/todos', &#123;title: \"ajax 공부\"&#125;) .then(res =&gt; &#123; prettyPrint(res.data) &#125;) 1234567PATCH /api/todos/3// PATCHaxios.patch('/api/todos/3', &#123;title: \"axios 공부\"&#125;) .then(res =&gt; &#123; prettyPrint(res.data) &#125;) 12345678DELETE /api/todos/3// DELETEaxios.delete('/api/todos/3') .then(res =&gt; &#123; prettyPrint(res.data) &#125;)GET /api/todos/?title=react axios 요청 메소드의 두 번째 인자로 config 객체를 넘길 수 있습니다. config 객체를 통해 요청의 쿼리 스트링, 요청 헤더, 쿠키 포함 여부 등 많은 것들을 설정할 수 있습니다. 12345678910111213// config 객체axios.get('/api/todos', &#123; params: &#123; // query string title: 'react 공부' &#125;, headers: &#123; // 요청 헤더 'X-Api-Key': 'my-api-key' &#125;, timeout: 1000 // 1초 이내에 응답이 오지 않으면 에러로 간주&#125;).then(res =&gt; &#123; prettyPrint(res.data) &#125;)응답 객체 응답 객체를 통해 응답의 여러 정보에 접근할 수 있습니다. 123456789// config.paramsaxios.get('/api/todos/1') .then(res =&gt; &#123; console.log(`status code: $&#123;res.status&#125;`) console.log('headers:') prettyPrint(res.headers) console.log('data:') prettyPrint(res.data) &#125;) Not a Number문자열을 정수로 변경하는 방법 1 : undefined 1 를하면 NaN이 나오는 문제가 발생한다. NaN을 판별할때는 isNaN을 사용해야한다. parseInt","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Ajax","slug":"Node-js/Ajax","permalink":"http://yoursite.com/categories/Node-js/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"Node-fetchApi","slug":"node-study-fetchapi","date":"2017-09-05T03:54:00.000Z","updated":"2017-09-21T02:17:07.000Z","comments":true,"path":"2017/09/05/node-study-fetchapi/","link":"","permalink":"http://yoursite.com/2017/09/05/node-study-fetchapi/","excerpt":"","text":"Node Fetch APIFetch API 웹 브라우저의 XMLHttpRequest를 대체하기 위해 만들어진 새로운 HTTP client 표준 비교적 최근에 도입되어 IE 및 구형 안드로이드 브라우저(4.x)는 지원하지 않음 Fetch Polyfill 최신기술로써 지원하지 않는 브라우저가 많지만 Fetch Polyfill을 사용하면 사용가능하다. isomorphic-fetch npm library이다. Axios vs Fetch API Instance와 같이 설정을 재사용하거나 요청중인 연결을 취소하는 등의 편의기능이 Fetch API에는 없음 현재로서는 Axios를 사용하는 것이 좋은 선택 다만, Axios는 내부적으로 XMLHttpRequest를 사용하고 있는데 Service Worker 등의 웹 최신 기술이 XMLHttpRequest를 지원하지 않으므로, Service Worker를 사용할 예정에 있는 프로젝트에서는 Axios를 사용할 수 없음 Fetch APIFetch API","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Fetch","slug":"Node-js/Fetch","permalink":"http://yoursite.com/categories/Node-js/Fetch/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Fetch","slug":"Fetch","permalink":"http://yoursite.com/tags/Fetch/"}]},{"title":"Node-Express-Middleware","slug":"node-study-node-Express-Middleware","date":"2017-09-04T03:54:00.000Z","updated":"2017-09-16T11:11:26.000Z","comments":true,"path":"2017/09/04/node-study-node-Express-Middleware/","link":"","permalink":"http://yoursite.com/2017/09/04/node-study-node-Express-Middleware/","excerpt":"","text":"Node Express MiddlewareMiddleware?1234567// 미들웨어 = 함수function helloMiddleware(res, req, next) &#123; console.log('hello') next()&#125;app.use(helloMiddleware) 요청이 발생할 때 마다 console.log(‘hello’)가 나타난다. Middleware 함수, 즉 안에서 어떤 작업이든 가능 request 객체, response 객체, next 함수를 인자로 받음 request 객체, response 객체를 조작해서 기능 구현 다음 미들웨어를 동작시키기 위해 next 함수를 인자 없이 호출 미들웨어는 등록된 순서가 중요하다 먼저 등록된 것이 먼저 시작되기 때문이다. 등록된 순서대로 실행됨 app.use미들웨어를 앱 전체에서 동작하도록 주입1app.use(helloMiddleware) 특정 경로에서만 동작하도록 주입1app.use('/some-path', helloMiddleware)\\ 한번에 여러 개 주입 1app.use(middleware1, middleware2, middleware3, ...) 미들웨어로 하는 일 로깅 HTTP body를 객체로 변환 사용자 인증 권한 관리 Why middleware?미들웨어로 할 수 있는 모든 일은 라우트 핸들러에서도 할 수 있으나, 여러 라우터에서 사용해야 하는 기능을 중복 작성하는 불편을 덜고 코드를 재사용하기 위해 미들웨어를 사용하는 것 미들웨어 생태계Express resourceNPM search 미들웨어 예제Link Express 미들웨어 예제 middlewares.js 파일에서 작성한 미들웨어를 server.js에서 불러와 사용하고 있습니다. 각각 어떤 방식으로 미들웨어를 사용하고 있는지 확인해보세요. next? 미들웨어는 req, res에 더해서 next라는 함수를 추가로 인자로 받습니다. next 함수를 호출하면 다음 미들웨어로 처리를 넘기는 효과가 있습니다. 만약에 미들웨어가 next 함수를 호출하지도 않고, 응답도 보내지 않으면 클라이언트는 응답을 받지 못하게 되므로 주의하세요! App Local, Response Local app.locals와 res.locals는 특별한 객체를 담고 있습니다. 템플릿에서는 res.render를 통해 명시적으로 주입받지 않아도 저 두 객체의 속성에 바로 접근할 수 있습니다. 템플릿을 가리지 않고 사용되는 정보들, 예를 들어 ‘현재 로그인 중인 사용자 정보’ 같은 것을 res.render에 매번 인자로 넘기는 것은 귀찮을 뿐더러 빠뜨리기도 쉽습니다. 그런 정보들을 템플릿에서 쉽게 사용하기 위해, app.locals나 res.locals에 우리가 원하는 이름으로 속성을 주입할 수 있습니다. app.locals는 앱 단위로 공통적으로 쓰이는 정보를 담는 목적으로 사용됩니다. res.locals는 각 요청마다 달라지는 정보를 담는 목적으로 사용됩니다. app.local 객체를 조작하는 것은 매우 쉽습니다. res 객체는 매 요청마다 새로 생성되어 미들웨어 바깥에서 접근할 수 있는 방법이 없으므로, res.locals를 조작하려면 미들웨어를 사용해야 합니다. 미들웨어에서도 직접 res.send를 통해서 값을 보낼 수 도있다 next or res.send 둘중하나는 꼭 해줘야한다. app.locals는 변하지 않는 값을 쓸때 사용하고 res.locals는 변경가능한 값을 쓸때 사용한다. 12345678910111213141516171819202122function makeAdder(x) &#123; return function(y) &#123; return x + y &#125;&#125;undefinedadd1 = makeAdder(1)ƒ (y) &#123; return x + y &#125;add1(2)3// 값이 이렇게 사용해도되는데 이것을 currying이라고 한다.makeAdder(3)(4)7 // 위의 함수와 같은 역할을 한다.makeAdder2 = x =&gt; y =&gt; x+yx =&gt; y =&gt; x+ymakeAdder2(4)(4)8 closure를 사용하여서 함수를 2가지를 사용한다 currying이라고도 불린다. 12345678910111213141516171819202122232425262728293031323334353637383940//server.jsconst express = require('express')const &#123; ipLoggingMiddleware, urlLoggingMiddleware, resLocalMiddleware, lock&#125; = require('./middlewares')const app = express()app.set('view engine', 'ejs')// 앱 단위 미들웨어는 모든 라우트 핸들러에서 실행됩니다.// 미들웨어는 등록된 순서대로 실행됩니다.// 아래 미들웨어 적용 순서를 바꿔보세요.app.use(urlLoggingMiddleware)app.use(ipLoggingMiddleware)// 라우트 단위 미들웨어는 적용된 라우트에서만 실행됩니다.app.get('/', resLocalMiddleware, (req, res) =&gt; &#123; res.render('index.ejs')&#125;)app.get('/secret', lock('thisisthekey'), (req, res) =&gt; &#123; res.send('my secret is...')&#125;)// 요청이 라우트 핸들러가 등록된 어떤 경로와도 일치하지 않을 때,// 맨 마지막 미들웨어를 실행시킬 수 있습니다. 이를 이용해 우리만의 404 페이지를 보여줄 수 있습니다.// 아래에 작성해보세요. (참고: http://expressjs.com/ko/starter/faq.html)app.use((req, res, next) =&gt; &#123; res.render('404.ejs')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) 12345678910111213141516171819202122232425//middlewares.jsexports.ipLoggingMiddleware = (req, res, next) =&gt; &#123; console.log(`request ip: $&#123;req.ip&#125;`) next()&#125;exports.urlLoggingMiddleware = (req, res, next) =&gt; &#123; console.log(`request url: $&#123;req.originalUrl&#125;`) next()&#125;exports.resLocalMiddleware = (req, res, next) =&gt; &#123; res.locals.myVar = 'FASTCAMPUS!' next()&#125;exports.lock = key =&gt; (req, res, next) =&gt; &#123; if (req.query.key === key) &#123; next() &#125; else &#123; res.status(403) res.send('403 Forbidden') &#125;&#125; 404관련 페이지는 가장 밑에서 실행해야한다. 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;%= myVar %&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 미들웨어 vs 라우트 핸들러 라우트 핸들러도 미들웨어 즉, next함수를 인자로 받는 것이 가능 1234567app.get('/', (req, res, next) =&gt; &#123; if (!someCondition) &#123; next() // 요청을 처리를 하지 않고 다른 핸들러로 넘김 &#125; else &#123; res.send('hello') &#125;&#125;) 오류 핸들러를 설정하는 방법 오류 처리 미들웨어는 다른 미들웨어와 동일한 방식으로 정의할 수 있지만, 다음과 같이 오류 처리 함수는 3개가 아닌 4개의 인수, 구체적으로 말하면 (err, req, res, next) 시그니처를 갖는다는 점이 다릅니다. bugsnag sentry 1234app.use(function(err, req, res, next) &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;);","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Express-Middlware","slug":"Node-js/Express-Middlware","permalink":"http://yoursite.com/categories/Node-js/Express-Middlware/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://yoursite.com/tags/Express/"},{"name":"Middleware","slug":"Middleware","permalink":"http://yoursite.com/tags/Middleware/"}]},{"title":"Node-Cookie","slug":"node-study-node-cookie","date":"2017-09-04T03:54:00.000Z","updated":"2017-09-16T11:07:34.000Z","comments":true,"path":"2017/09/04/node-study-node-cookie/","link":"","permalink":"http://yoursite.com/2017/09/04/node-study-node-cookie/","excerpt":"","text":"Node Cookie쿠키의 필요성 개별 클라이언트의 여러 요청에 걸친 정보의 유지 장바구니 로그인/로그아웃 방문 기록 HTTP Cookie 서버가 응답을 통해 웹 브라우저에 저장하는 이름+값 형태의 정보 웹 브라우저는 쿠키를 저장하기 위한 저장소를 가지고 있음 저장소는 자료의 유효기간과 접근 권한에 대한 다양한 옵션을 제공 쿠키 전송 절차 서버는 브라우저에 저장하고 싶은 정보를 응답과 같이 실어 보낸다(Set-Cookie 헤더) 12HTTP/1.1 200 OKSet-Cookie: cookieName=cookieValue; Secure; Max-Age=60000 브라우저는 같은 서버에 요청이 일어날 때마다 해당 정보를 요청에 같이 실어서 서버에 보낸다 (Cookie 헤더) 12GET / HTTP/1.1Cookie: cookieName=cookieValue; anotherName=anotherValue Set-Cookie OptionsExpires, Max-Age 쿠키의 지속 시간 설정 Secure HTTPS를 통해서만 쿠키가 전송되도록 설정 HttpOnly 자바스크립트에서 쿠키를 읽지 못하도록 설정 Domain, Path 쿠키의 scope 설정 (쿠키가 전송되는 URL을 제한) Express + Cookie쿠키 읽기 - req.cookies 요청에 실려온 쿠키가 객체로 변환되어 req.cookies에 저장됨(cookie-parser middleware 필요) 쿠키 쓰기 - res.cookie(name, value) 쿠키의 생성 혹은 수정 쿠키 예제Link 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const express = require('express')const cookieParser = require('cookie-parser')const app = express()app.set('trust proxy', 1)app.use(cookieParser())app.get('/', (req, res) =&gt; &#123; res.send(req.cookies)&#125;)app.get('/somePath', (req, res) =&gt; &#123; res.send(req.cookies)&#125;)// 별다른 옵션 없이 쿠키를 저장하는 응답을 보냅니다.app.get('/set', (req, res) =&gt; &#123; res.cookie('cookieName', 'cookieValue') res.redirect('/')&#125;)// httpOnly 옵션은 해당 쿠키를 자바스크립트에서 접근할 수 없게 합니다. 즉 보안성이 향상app.get('/httpOnly', (req, res) =&gt; &#123; res.cookie('httpOnlyCookie', 'value', &#123; httpOnly: true &#125;) res.redirect('/')&#125;)// secure 옵션은 http 프로토콜을 통한 요청에는 쿠키가 포함되지 않게 합니다. (https로 했을 때만 포함시킴)app.get('/secure', (req, res) =&gt; &#123; res.cookie('secureCookie', 'value', &#123; secure: true &#125;) res.redirect('/')&#125;)// maxAge 옵션은 쿠키가 해당 시간이 지났을 때 삭제되도록 합니다.app.get('/maxAge', (req, res) =&gt; &#123; res.cookie('maxAgeCookie', 'value', &#123; maxAge: 5000 &#125;) res.redirect('/')&#125;)// domain 옵션은 해당 도메인 및 서브도메인으로 쿠키가 전송되도록 합니다.app.get('/domain', (req, res) =&gt; &#123; res.cookie('domainCookie', 'value', &#123; domain: 'glitch.me' &#125;) res.redirect('/')&#125;)// path 옵션은 쿠키가 지정된 경로 및 그 하위 경로에 요청이 일어났을 때만 전송되도록 합니다.// 루트에서는 안보이고 somePath에서는 보인다.app.get('/path', (req, res) =&gt; &#123; res.cookie('pathCookie', 'value', &#123; path: '/somePath' &#125;) res.redirect('/')&#125;)// 여러 옵션을 한꺼번에 지정할 수도 있습니다.app.get('/multiple-options', (req, res) =&gt; &#123; res.cookie('multipleOption', 'value', &#123; secure: true, httpOnly: true, maxAge: 5000 &#125;) res.redirect('/')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) JavaScript + Cookie자바스크립트로도 쿠키를 읽고 쓰는 방법이 존재하지만, 보안 상 문제를 일으킬 수 있으므로 이런 접근 방식은 거의 사용되지 않는다. 자바스크립트에서 쿠키에 접근하지 못하도록 HttpOnly를 항상 설정하는 것이 best practice 쿠키의 한계점 US-ASCII 밖에 저장하지 못함. 보통 percent encoding을 사용 4000 바이트 내외(영문 4000자, percent encoding 된 한글 444자 가량)밖에 저장하지 못함 브라우저에 저장됨. 즉, 여러 브라우저에 걸쳐 공유되어야 하는 정보, 혹은 웹 브라우저가 아닌 클라이언트(모바일 앱)에 저장되어야 하는 정보를 다루기에는 부적절","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Cookie","slug":"Node-js/Cookie","permalink":"http://yoursite.com/categories/Node-js/Cookie/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"}]},{"title":"Git Manage","slug":"js-study-git","date":"2017-09-04T03:54:00.000Z","updated":"2017-11-23T12:36:20.000Z","comments":true,"path":"2017/09/04/js-study-git/","link":"","permalink":"http://yoursite.com/2017/09/04/js-study-git/","excerpt":"","text":"Git 으로 배포하기 Repository를 새로 만든다. Portfolio를 만드는데 안에 플젝(a, b)을 넣을때는 index.html이 존재해야하며 상대경로로 이루어져야한다. terminal로 이동하여서 portfolio로 이동 후 git init, add, commit을 순차적으로 한다. Git remote add origin (portfolio git 주소) Git checkout -b gh-pages Git push origin gh-pages 나의 깃주소/portfolio/a OR 나의 깃주소/portfolio/b 로 접속한다. gh-pages로 branch를 만들어야지 git에서 배포가 가능하다","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"},{"name":"배포","slug":"Git/배포","permalink":"http://yoursite.com/categories/Git/배포/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Node-Session","slug":"node-study-node-session","date":"2017-09-04T03:54:00.000Z","updated":"2017-09-16T11:12:55.000Z","comments":true,"path":"2017/09/04/node-study-node-session/","link":"","permalink":"http://yoursite.com/2017/09/04/node-study-node-session/","excerpt":"","text":"Node SessionSession사전적 의미 (특정한 활동을 위한) 시간 (의회 등의)회기; (법정의) 개정 (기간) 실질적 의미시작 조건과 종료조건이 있는 시간, 또는 회기정보 교환이 지속되는 시간, 또는 회기 세션의 예 HTTP session요청 - 응답 클라이언트가 TCP 연결을 수립합니다(또는 전송 계층이 TCP가 아닌 다른 적당한 연결로). 클라이언트는 요청을 전송한 뒤 응답을 기다립니다. 서버는 요청에 대해 처리하고 그에 대한 응답을 상태 코드 그리고 요청에 부합하는 데이터와 함께 돌려보냅니다. 로그인 세션로그인 - 로그아웃 Google Analytics 세션페이지 접속 - 30분간 접속이 없으면 종료로 간주 (커스터마이징 가능) 웹 서비스를 위한 세션의 구현 세션이 시작되면, 세션이 시작되었다는 사실을 쿠키에 저장 세션에 대한 정보를 여러 요청에 걸쳐서 지속시키기 위해, 정보를 어딘가에 저장 세션이 만료되면, 세션이 만료되었다는 사실을 쿠키에 반영 위 방식은 널리 사용되는 방식일 뿐, 반드시 위와 같이 구현해야 하는 것은 아닙니다. 세션 스토어세션에 대한 정보를 저장하는 어딘가 쿠키 데이터베이스 파일 기타 정보를 저장할 수 있는 곳 어디든 세션 스토어의 선택서비스의 요구사항에 맞춰서 적절한 저장소를 선택하면 됨 정보의 형태가 간단하고 자주 바뀔 일이 없으면 쿠키 저장해야 할 정보의 양이 많으면 데이터베이스 정보가 굉장히 자주 변경되면 메모리 기반 저장소 세션? 세션 스토어?&#39;세션&#39;과 &#39;세션 스토어&#39;는 엄연히 다른 말이지만 혼용되는 경우가 많습니다. &#39;세션에 정보를 저장한다&#39;는 말은 &#39;세션 스토어에 정보를 저장한다&#39;는 말과 같은 뜻이라고 생각하면 됩니다. Express + Sessioncookie-session 쿠키에 모든 정보를 저장하는 세션 스토어. 첫 방문시 무조건 세션 시작express-session 쿠키에는 세션 식별자만 저장하고 실제 정보의 저장은 외부 저장소(데이터베이스 등)를 이용하는 세션 스토어. 외부 저장소에 대한 별도의 설정 필요 cookie-session 예제Link cookie-session NPM 패키지는 쿠키를 세션 스토어로 사용할 수 있도록 해주며 세션 스토어를 쉽게 사용할 수 있는 방법을 제공합니다. server.js 파일과 앱을 열어 어떤 방식으로 동작하는 앱인지 확인하고, 크롬 개발자 도구를 이용해 쿠키가 전달되고 저장되는 모습을 확인하세요. cookie-session 동작 방식 cookie-session 미들웨어는 첫 요청이 일어났을 때 빈 세션 정보(빈 객체)를 req.session에 주입합니다. 프로그래머는 세션과 관련된 정보를 req.session에 저장합니다. req.session은 보통의 자바스크립트 객체로, JSON으로 표현될 수 있는 자료라면 뭐든지 저장할 수 있습니다. cookie-session 미들웨어는 응답이 일어나기 직전에 req.session 객체를 문자열로 바꾼 뒤(JSON &amp; base64), 쿠키에 저장합니다. cookie-session 미들웨어는 다음 번 요청부터 쿠키에 저장된 정보를 자바스크립트 객체로 변환해 req.session에 주입합니다. 프로그래머는 req.session 객체를 이용해 세션 정보를 읽을 수 있습니다. 또한 세션 정보를 통째로 삭제하기 위해 미들웨어 또는 라우트 핸들러에서 req.session = null을 대입할 수 있습니다. session.sig? 서명!session 쿠키에 저장된 정보는 일반인은 알아볼 수 없지만 프로그래머라면 쉽게 복원하거나 변경할 수 있습니다. (base64 디코더로 session 쿠키를 변환해보세요) 만약에 세션에 계정 정보가 들어있고, 악의적인 해커가 쿠키의 값을 변경해서 세션 스토어를 조작할 수 있다면, 마치 다른 사람인 척 행세할 수 있고 그에 따라 정보를 탈취당할 수도 있을 것입니다. 그래서, cookie-session 미들웨어는 보안 유지를 위해 서명(signature)을 활용하고 있습니다. 컴퓨터 분야에서의 서명이란, 비밀 키를 이용해 정보를 특별한 알고리즘(hashing)으로 변형시킨 것을 말합니다. 서명의 가장 중요한 성질은, 같은 비밀 키로 같은 정보를 서명했을 때 언제나 같은 결과가 나온다는 것, 그리고 비밀 키나 정보 중 어느 한 쪽만 바뀌어도 서명의 결과가 크게 달라진다는 것입니다. 비밀 키와 서명을 활용하면 정보가 조작되었는지의 여부를 알 수 있습니다. 어떤 정보를 서명과 함께 공개하고 비밀 키는 숨기면, 누군가가 정보를 조작해서 올바른 정보인 척 흉내를 내려고 해도 비밀 키를 모르기 때문에 서명을 할 수 없어서 금방 조작인 것이 탄로가 나겠죠. cookie-session 미들웨어는 응답을 보낼 때 session 쿠키에 저장된 문자열을 비밀 키로 서명해서 그 결과를 session.sig 쿠키에 저장합니다. 만약에 요청에 포함된 session 쿠키를 다시 같은 비밀 키로 서명했는데 session.sig 쿠키와 일치하지 않는다면, 정보가 조작된 것을 알아채고 세션을 아예 삭제해버리는 방식으로 조작을 막습니다! 서명을 활용할 때 주의할 점이 있습니다. 비밀 키는 당연히 공개되지 않도록 관리해야 합니다. 비밀 키와 서명 알고리즘이 공개되면 서명이 조작될 수 있습니다. 키의 길이를 충분히 길게 해야 합니다. 해커가 서명 알고리즘을 알고 있다면, 짧은 비밀 키는 어렵지 않게 계산해낼 수 있습니다. 서명은 정보의 조작을 막아주지만, 정보의 공개를 막아주지는 않습니다. session 쿠키만 하더라도 base64 디코딩만 거치면 어떤 정보가 들어있는지 바로 확인할 수 있죠. 따라서 비밀번호나 신용카드 번호 등은 cookie-session이 제공하는 세션 스토어에 저장하면 안 됩니다. 참고로, 이전에 다뤘던 cookie-parser 미들웨어도 옵션을 활성화하면 서명을 사용하여 조작을 방지할 수 있습니다. 곧 배울 JWT도 보안을 위해 서명을 사용하고 있습니다. 서명 과정을 직접 시험해보고 싶다면 여기를 참고하세요. 12345678910111213141516171819202122232425262728293031323334353637383940414243const express = require('express')const cookieSession = require('cookie-session')const app = express()app.set('trust proxy', 1) app.set('view engine', 'ejs')// cookie-session 설정// name: 쿠키 이름으로 사용할 문자열// secret: 세션 정보를 서명할 때 사용할 키// 여러가지 옵션을app.use(cookieSession(&#123; name: 'session', secret: process.env.SECRET&#125;))// req.session.count를 처리하는 미들웨어const countMiddleware = (req, res, next) =&gt; &#123; if ('count' in req.session) &#123; // count 속성이 있으면 1으. req.session.count += 1 &#125; else &#123; // count 속성이 없으면 처음 방문한 것이므로 1로 설정한다. req.session.count = 1 &#125; next()&#125;// 첫 방문 후, 쿠키 관련 헤더가 요청과 응답에 잘 포함되는지 살펴보고,// 실제로 쿠키가 어떻게 저장되어있는지 살펴보세요.app.get('/', countMiddleware, (req, res) =&gt; &#123; res.render('index.ejs', &#123;count: req.session.count&#125;)&#125;)app.post('/reset-count', (req, res) =&gt; &#123; delete req.session.count res.redirect('/')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) req.session에다가 값을 저장하면 cookie value에 값이 저장된다. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;%= count %&gt;번 째 방문하셨습니다. &lt;/div&gt; &lt;form action=\"/reset-count\" method=\"post\"&gt; &lt;button type=\"submit\"&gt; 초기화 &lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 인증(Authentication)과 인가(Authorization)인증(Authentication)은 클라이언트가 누구인지를 확인하는 과정입니다. 지금은 ‘인증과 로그인은 같은 말’이라고 생각하셔도 무방합니다. 인가는 클라이언트가 하려고 하는 작업이 해당 클라이언트에게 허가된 작업인지를 확인하는 과정입니다. ‘권한 설정’이라고 생각하셔도 무방합니다. 예를 들어 다음 카페나 네이버 클럽에서는 관리자만이 게시판을 만들거나 없앨 수 있도록 인가됩니다. 인증 구현 전략인증은 여러가지 방식으로 구현될 수 있으며, 여기에서는 우리가 쓰고 있는 cookie-session 의 기능에 맞추어서 구현해보도록 하겠습니다. cookie-session이 제공하는 미들웨어는 첫 방문시 바로 세션을 시작하고 (이를 guest session이라 부릅니다) 쿠키에 빈 세션 정보(빈 객체)를 저장합니다. 그래서 첫 방문자에 대해서도 session 객체를 바로 쓸 수 있습니다. 아래와 같은 규칙으로 인증을 구현해보도록 합니다. req.session.username === undefined이면 로그인된 사용자가 없는 것으로 간주합니다. 사용자가 로그인 폼을 전송하면 accounts 배열에 저장된 계정 정보 중에 일치하는 것이 있는지 확인하고, 있다면 req.session.username에 해당 사용자 이름을 저장합니다. 만약 일치하는 계정이 없으면 400 Bad Request 응답을 보냅니다. req.session.username에 저장된 값이 있다면 해당 사용자로 로그인이 되어 있다고 간주합니다. 로그아웃을 하기 위해 req.session = null와 같이 대입해서 세션을 초기화합니다. (인증이 된 뒤에는 req.user와 res.locals.user에 계정 객체를 주입해서 라우트 핸들러와 템플릿에서 편하게 접근할 수 있도록 미리 코드를 짜 두었습니다.) 인가 구현 전략관리자만이 비밀 정보(/secret)에 접근할 수 있도록 해 보겠습니다. 사용자가 관리자인지 아닌지의 여부는 계정 객체의 admin 속성에 저장되어 있습니다. 로그인한 정보를 맞는지 확인하여서 값을 찾아낸다.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//server.jsconst express = require('express')const cookieSession = require('cookie-session')const bodyParser = require('body-parser')const app = express()const urlencodedMiddleware = bodyParser.urlencoded(&#123;extended: false&#125;)app.set('trust proxy', 1) app.set('view engine', 'ejs')const accounts = [ &#123; username: 'tpwns', password: 'kim', name: '김세준' &#125;, &#123; username: 'fast', password: 'campus', name: '패스트캠퍼스', admin: true &#125;]app.use(cookieSession(&#123; name: 'session', secret: process.env.SECRET&#125;))app.use((req, res, next) =&gt; &#123; if (req.session.username) &#123; req.user = res.locals.user = accounts.find(acc =&gt; acc.username === req.session.username) &#125; else &#123; req.user = res.locals.user = null &#125; next()&#125;)app.get('/', (req, res) =&gt; &#123; res.render('index.ejs')&#125;)app.post('/login', urlencodedMiddleware, (req, res) =&gt; &#123; const account = accounts.find(acc =&gt; acc.username === req.body.username &amp;&amp; acc.password === req.body.password) // 인증 과정을 작성해주세요. if(account)&#123; req.session.username = account.username res.redirect('/') &#125;else &#123; res.status(400) res.send('400 Bad Request') &#125; &#125;)function onlyAdminMiddleware(req, res, next) &#123; // `/secret`에 접속했을 때 이 미들웨어가 작동합니다. // 관리자가 아니면 403 Forbidden 응답을 보내도록 작성해주세요. // 위에서 req.session.username에 저장한 값을 통해 비교한다. const manage = accounts.find(acc =&gt; acc.username === req.session.username) if(manage.admin == true)&#123; // next를 통하여 전달한다. next() &#125;else &#123; res.status(403) res.send('403 Forbidden') &#125;&#125;app.get('/secret', onlyAdminMiddleware, (req, res) =&gt; &#123; res.send('It is my secret')&#125;)app.post('/logout', urlencodedMiddleware, (req, res) =&gt; &#123; req.session = null res.redirect('/')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) MiddleWare에서는 성공시 next로 보내줘야한다. session.sig을 통하여 session의 보안성이 지켜진다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Session","slug":"Node-js/Session","permalink":"http://yoursite.com/categories/Node-js/Session/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Session","slug":"Session","permalink":"http://yoursite.com/tags/Session/"}]},{"title":"JavaScript ES6 Data Structure","slug":"js-study-es6-data-structure","date":"2017-09-01T03:54:00.000Z","updated":"2017-11-21T11:47:01.000Z","comments":true,"path":"2017/09/01/js-study-es6-data-structure/","link":"","permalink":"http://yoursite.com/2017/09/01/js-study-es6-data-structure/","excerpt":"","text":"Javascript ES6 Data Structure Data Structures in Web DevelopmentArray &amp; Hash(Dictionary) - indexing post 123456789101112in RDB[articleId, title, body, userId, view][&#123; userId: 1, articleId: 1, view: 100, title: \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\", body: \"quia et suscipit suscipit recusandae consequuntur expedita et cum reprehenderit molestiae ut ut quas totam nostrum rerum est autem sunt rem eveniet architecto\"&#125;, ...] Data Structures in Web DevelopmentTree - DOM rendering performance, reply 1234567&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; div로 영역을 나누어서 묶으면 더욱 빠른 접근이 가능하다. Data Structures in Web Development Binary Tree Search Queue(BFS, Breadth First Search) = 너비우선탐색 Stack(DFS, Depth First Search) = 깊이우선탐색 We’ll Learn about.. Stack Queue Linked-list Tree StackA stack is an abstract data type that serves as a collection of elements, with two principal operations. push: which adds an element to the collection (값을 add) pop: which removes the most recently added element that was not yet removed (값을 remove) LIFO = Last In First Out pusj &amp; pop &amp; peek &amp; isEmpty &amp; size &amp; clear &amp; print12345678910111213141516171819202122232425262728293031function Stack()&#123; var items = []; this.push = function(element)&#123; return items.push(element); &#125;; this.pop = function()&#123; return items.pop(); &#125;; this.peak = function()&#123; return items[items.length-1]; &#125;; this.isEmpty = function()&#123; return items.length === 0; &#125;; this.size = function()&#123; return items.length; &#125;; this.clear = function()&#123; items = []; &#125;; this.print = function()&#123; console.log(items.toString()); &#125;;&#125; 10진수를 2진수로 변경하는 함수 구현 1234567891011121314151617function binaryConverter(x) &#123; var stack = []; var y = 0; var last = ''; while (x &gt; 0) &#123; y = Math.floor(x % 2); stack.push(y); x = Math.floor(x / 2); &#125; while (stack.length &gt; 0) &#123; last += stack.pop(); &#125; return console.log(last);&#125;binaryConverter(10); Queue들어온 순서대로 나가게 도와주는 자료구조이다. 선입선출(FIFO) Enqueue &amp; Dequeue Enqueue: addition of entities to the rear terminal position Dequeue: removal of entities from the front terminal position Enqueue &amp; Dequeue &amp; front &amp; isEmpty &amp; clear &amp; size &amp; print12345678910111213141516171819202122232425262728function Queue() &#123; //properties, methods var items = []; this.enqueue = function(element) &#123; items.push(element); &#125;; this.dequeue = function() &#123; return items.shift(); &#125;; this.front = function() &#123; return items[0]; &#125;; this.isEmpty = function() &#123; return items.length == 0; &#125;; this.clear = function() &#123; items = []; &#125;; this.size = function() &#123; return items.length; &#125;; this.print = function() &#123; console.log(items.toString()); &#125;;&#125; GulpTask runner 매우 귀찮은 루틴한 작업들을 자동화 할 수 있는 툴 현재 2735 + a 개의 패키지가 존재 따라서 필요한 기능을 골라 설치할 필요가 있음!! task flow 코드작성 - JS test(jshint) - JS Minify - JS Merge(concat) - CSS Minify - CSS Merge - 결과물 123456789101112$ npm install gulp --global$ npm install gulp --save-dev$ touch gulpfile.jsvar gulp = require(\"gulp\");//hello라는 gulp task를 등록gulp.task(\"hello\", function () &#123; return console.log(\"hello gulpworld\");&#125;);$ gulp hello gulp 기본 문법 gulp.task : gulp의 작업단위 gulp.src : gulp 실행의 대상 gulp.dest : gulp 실행 후 목적지 gulp.watch : 변화 감지 후 자동 실행 기본값 설정하기123456789101112$ gulpfile.jsvar gulp = require(&quot;gulp&quot;);//hello라는 gulp task를 등록gulp.task(&quot;hello&quot;, function () &#123; return console.log(&quot;hello gulpworld&quot;);&#125;);gulp.task(&quot;default&quot;, [&quot;hello&quot;]);$ gulp gulp 만 실행하면 default랑 다른 task들이 실행된다. gulp hello 만 실행하면 이것만 실행된다. 우선순위 설정하기12345678910111213141516$touch gulpfile.jsvar gulp = require(&quot;gulp&quot;);//hello라는 gulp task를 등록gulp.task(&quot;hello&quot;, function () &#123; return console.log(&quot;hello&quot;);&#125;);gulp.task(&quot;gulpworld&quot;, [&quot;hello&quot;], function () &#123; return console.log(&quot;gulpworld&quot;);&#125;);gulp.task(&quot;default&quot;, [&quot;gulpworld&quot;]);$ gulp 자주쓰는 목적지 설정하기1234var publicPath = &#123; src : './public/src/', dest : './public/dist/'&#125;; uglify(gulp-uglify): js uglify npm install –save-dev gulp-uglify npm install –save-dev pump1234567gulp.task(\"uglify\", function()&#123; pump([ gulp.src(publicPath.src + 'js/uglify.js'), uglify(), gulp.dest(publicPath.dest + 'js/') ]);&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","permalink":"http://yoursite.com/categories/JavaScript/ES6/"},{"name":"Data Structure","slug":"JavaScript/ES6/Data-Structure","permalink":"http://yoursite.com/categories/JavaScript/ES6/Data-Structure/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}]},{"title":"Node-Service-Develop","slug":"node-study-service-develope","date":"2017-08-30T03:54:00.000Z","updated":"2017-09-15T14:50:58.000Z","comments":true,"path":"2017/08/30/node-study-service-develope/","link":"","permalink":"http://yoursite.com/2017/08/30/node-study-service-develope/","excerpt":"","text":"Node Service DevelopURL Shortener goo.gl bit.ly urlo.cc 요구사항 긴 URL을 짧은 URL로 변경하는 것은 한 명의 관리자만 만들 수 있음 짧은 URL은 누구나 이용할 수 있음 시나리오 설계화면 설계데이터 설계프로젝트 세팅 npm init -y .gitignore 추가 Express 앱 세팅 npm install –save express 템플릿 엔진 설 npm script 추 static 라우트 설 템플릿, CSS 파일 추가 로깅과 인증 morgan 설정 express-basic-auth 설정 초기 데이터 작업 randomstring 표로 보여주기 .ejs extension 설치 emmet 사용법 템플릿 작성 짧은 URL의 리디렉션 핸들러 작성 (301 Moved Permanently) Redirection cache 짧은 URL 링크 만들기 폼 body-parser 인증 설정 폼, 핸들러 작성 스타일링 Bootstrap CSS now.sh를 통한 배포 now 설치 환경변수란? dotenv 관리자 계정을 포함시켜 배포 Discussion 최적의 개발 순서? 적절한 커밋의 단위는?","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Service Develop","slug":"Node-js/Service-Develop","permalink":"http://yoursite.com/categories/Node-js/Service-Develop/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Service Develop","slug":"Service-Develop","permalink":"http://yoursite.com/tags/Service-Develop/"}]},{"title":"Node-Web-Form","slug":"node-study-web-form","date":"2017-08-30T03:54:00.000Z","updated":"2017-09-21T02:18:35.000Z","comments":true,"path":"2017/08/30/node-study-web-form/","link":"","permalink":"http://yoursite.com/2017/08/30/node-study-web-form/","excerpt":"","text":"Node Web FormHTML FormHTML form의 기본 동작HTML form을 전송하면, 입력된 정보가 기본적으로 percent encoding 되어 요청됨 GET method 이름=값 형식으로 간다.12GET /search?query=%EA%B0%9C&amp;sort=latest HTTP/1.1... Post method 이름=값 형식으로 간다. urlencoded로는 파일을 보내기에 부적절해서 다른 Content-type인 multipart를 사용한다. 12345POST /form HTTP/1.1Content-Type: application/x-www-form-urlencoded...home=Cosby&amp;favorite+flavor=flies multipart/ form-data 기본 설정(percent encoding)으로는 폼으로 파일을 업로드하는 것은 불가능 (클라이언트 측) form 태그에 enctype=&quot;multipart/form-data&quot;속성을 적용하면 파일 업로드 가능 (서버 측) body-parser 미들웨어는 multipart/form-data 형태의 요청을 지원하지 않음 (multer 필요) json, url-encoded형식을 req.body에서 사용하기 위해서는 body-parser가 필요하다. HTML Form 예제 Link UUID Redirection after submission Form validation 클라이언트 측 validation을 잘하면 사용자가 사용하기에 편하다. 클라이언트 측 validation 구현방법 1&lt;input required type=\"text\" name=\"title\"&gt; redirect(‘/‘)는 300(301 Moved Permanently302 Found) 번대 에러가 발생했을 때 다른 곳으로 보내준다. post 응답이 redirect가아닌 새로고침을 하면 같은 값이 계속 간다. Ajax를 사용할때는 redirect를 하지 않아도 괜찮다. 301과 302의 차이 301응답이란? 사용자가 보내면 web browser는 그걸을 기억했다가 똑같은 요청이 온다면 web browser가 서버에 요청을 하지않고 web browser에서 그전의 저장한 정보를 보낸다. res.redirect는 302 상태코드로 응답합니다. UUID 범용 공용 식별자 : 어디에서든지 유니크한 아이디 128bit의 숫자로 이루어져 있으며","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Web Form","slug":"Node-js/Web-Form","permalink":"http://yoursite.com/categories/Node-js/Web-Form/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Web Form","slug":"Web-Form","permalink":"http://yoursite.com/tags/Web-Form/"}]},{"title":"Node-Http","slug":"node-study-http","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-14T13:25:48.000Z","comments":true,"path":"2017/08/29/node-study-http/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-http/","excerpt":"","text":"HTTP History APIHTTP History API history.back() window.history.back(); history.forward() window.history.forward(); history.go() 히스토리에서 특정 위치로 가기 history.pushState() 히스토리 엔트리의 추가 및 변경 이 메서드들은 window.onpopstate 이벤트와 연동하여 동작합니다. HTTP 까보기 WireShark https를 사용하는 사이트는 wireshark로 찾아볼 수 없다. Chrome Devtools 검사탭 -&gt; Network HTTP 웹 브라우저와 웹 서버 간의 통신을 위해 개발된 통신규약 최근에는 REST API의 부상와 함꼐 다른 용도로도 널리 사용됨 모바일 앱 - 서버 간 통신 서버 - 서버 간 통신 80번 포트를 기본으로 사용 클라이언트의 요청(requert)과 서버의 응답(response)으로 이루어짐 HTTPS HTTP over SSL HTTP 통신을 암호화해 주고받는 내용을 중간에서 가로챌 수 없도록 함 443번 포트를 기본으로 사용 HTTP/2 구글의 SPDY 프로토콜을 기반으로 2015년에 확정된 새로운 HTTP 표준 속도 개선에 중점을 두고 개발됨 반드시 HTTPS를 사용해야 함 현재 전체 웹사이트 중 16% 이상이 사용중 HTTP 구성요소Request &amp; Response 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보냄 그에 따라 서버는 클라이언트에 응답(response)를 보냄 웹 브라우저의 경우, HTML 문서 형태의 응답이 오면 해당 문서를 분석한 후, 문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보냄 (이미지, 동영상, 오디오, CSS, JS, 폰트, …) Request Methods HTTP 명세에는 8 종류가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있음 GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH HTTP request methods 웹 브라우저는 특정 상황에서 특정 메소드로 요청을 보내도록 강제되어져 있음 Ajax와 같이 요청을 보내는 코드를 직접 짤 때는 요청 메소드를 선택할 수 있음 자료의 본문을 요청하는 GET메소드와, 새로운 자료를 등록하는 POST 메소드가 가장 많이 쓰임 (서버가 충족시켜야 하는) 메소드의 성질Safe 요청이 서버의 상태에 영향을 미치지 않아야 함. 즉, 읽기 전용 Idempotent 여러 번 같은 요청을 해도 한 번 요청한 것과 같은 효과여야 함. 네트워크가 불안정해도 안전하게 요청을 보낼 수 있음 Cacheable (특정 조건을 만족하면) 응답을 클라이언트에 저장해두었다가 다음 번 요청 때 다시 쓸 수 있음 fetch는 일부분만 바꿀때 사용하며, put은 전체를 바꿀때 사용한다, link 반드시 이 성질을 따르도록 서버를 구현해야 하는 것은 아니나, 구현했을 때의 이점이 있으므로 이대로 구현하는 것이 좋다 URL 2,3,4는 domain영역이다. 4(TOP)는 특별한 기관에서 관리를한다. Percent Encoding URL은 ASCII 문자(128개의 영문자+특수문자+제어문자)밖에 사용하지 못하기 때문에, non-ASCII 문자를 위한 표현방법이 필요함 # Percent encoding은 non-ASCII 문자를 위한 웹 표준 인코딩 방법으로, JavaScript에 관련 기능이 포함되어 있음 1234&gt; encodeURIComponent(\"한글\")\"%ED%95%9C%EA%B8%80\"&gt; decodeURIComponent(\"%ED%95%9C%EA%B8%80\")\"한글\" 1234const encoded = encodeURIComponent('패스트캠퍼스')undefineddecodeURIComponent(encoded)\"패스트캠퍼스\" Request Target일반적인 경우 아래와 같은 구조가 사용됨 absolute path + query string + fragment id 1GET /path/to/resource?foo=bar&amp;spam=hoge#fragid HTTP/1.1 Response Status 응답의 성공, 실패 여부와 종류를 나타내며, 상태 코드 + 상태 메시지의 형태로 응답에 포함됨 1HTTP/1.1 200 OK HTTP Status Codes Status Category2xx 성공 3xx 추가 작업이 필요함 4xx 실패 - 클라이언트 책임 5xx 실패 - 서버 책임 Status Code - 2xx200 ok 성공 201 Created 자료가 성공적으로 생성됨 Status Code - 3xx301 Moved Permanently (Redirection) 자료가 완전히 다른 곳으로 이동했음 302 Found (Redirection) 자료가 일시적으로 다른 곳에 있음 304 Not Modified (Cache) 클라이언트가 이미 가지고 있던 자료가 수정되지 않았음 (그대로 사용하면 됨) Status Code - 4xx400 Bad Request 요청의 형태가 잘못되어 응답할 수 없음 403 Forbidden 요청한 자료에 접근할 권한이 없음 404 Not Found 요청한 자료가 없음 Status Code - 5xx500 Internal Server Error 요청을 처리하던 중에 예상치 못한 오류가 발생함 503 Service Unavailable 서버가 일시적으로 응답을 할 수 없음 Header 요청과 응답에 대한 추가 정보를 표현하는 데 사용됨 인증, 캐싱, 쿠키, 보안, 내용협상, 프록시 등 웹 표준에 정의된 많은 기능을 제어하는 데 사용됨 Authorization 요청의 인증 정보 User-Agent 요청 중인 클라이언트의 정보 Location 301, 302 응답에서 자료의 위치 Accept 요청이 어떤 형태의 자료를 원하는지 나타냄 Content-Type 요청 혹은 응답이 어떤 형태의 자료인지 나타냄 Content Negotiation 요청의 Accept, Accept-Language 등의 헤더를 보고 서버가 그에 맞는 형태의 자료를 응답하는 절차를 content negotiation(내용협상)이라고 함","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Http","slug":"Node-js/Http","permalink":"http://yoursite.com/categories/Node-js/Http/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Http","slug":"Http","permalink":"http://yoursite.com/tags/Http/"}]},{"title":"Node-Template-Language","slug":"node-study-template-language","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-15T14:51:19.000Z","comments":true,"path":"2017/08/29/node-study-template-language/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-template-language/","excerpt":"","text":"Node Template LanguageStatic Web Page누가 어떻게 요청하든 미리 저장되어 있던 HTML 파일을 그대로 응답 Dynamic Web Page요청한 사람과 요청한 내용에 따라 각각 다른 내용으로 편집한 HTML을 응답 Template Engine템플릿과 데이터를 결합해 문서를 생성하는 프로그램, 혹은 라이브러리템플릿을 작성할 때 사용하는 언어를 템플릿 언어라고 함 EJSEmbedded JavaScript Template # Node.js 생태계에서 가장 많이 사용되는 템플릿 엔진 문법이 단순 JavaScript 코드를 템플릿 안에서 그대로 쓸 수 있음 .ejs VSCode Extension 1234567891011121314&lt;%# index.ejs %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"message\"&gt; &lt;%= message %&gt; &lt;/div&gt; &lt;% if (showSecret) &#123; %&gt; &lt;div&gt;my secret&lt;/div&gt; // showSecret이 true면 my secret을 보여주고 false면 보여주지 말아라. &lt;% &#125; %&gt; &lt;/body&gt;&lt;/html&gt; &lt;%= title %&gt; 을 사용하여서 데이터의 title을 가진 값을 집어 넣는다. Express에서 EJS 사용하기ejs 설치1$ npm install --save ejs template engine 설정1app.set('view engine', 'ejs') res.render()123456const data = &#123; title: 'Template Language', message: 'Hello EJS!', showSecret: true&#125;res.render('index.ejs', data) Serving Static Files 템플릿 파일에서 참조할 수 있다. 변하지 않는 파일들을 넣어서 보관해둔다.1234567// `public` 폴더에 있는 파일을 `/static` 경로 아래에서 제공app.set('view engine', 'ejs')app.use('/static', express.static('public'))&lt;!-- 템플릿 파일에서 참조할 수 있음 --&gt;&lt;link rel=\"stylesheet\" href=\"/static/index.css\"&gt;&lt;script type=\"text/javascript\" src=\"/static/index.js\"&gt;&lt;/script&gt;","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Template Language","slug":"Node-js/Template-Language","permalink":"http://yoursite.com/categories/Node-js/Template-Language/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"template Language","slug":"template-Language","permalink":"http://yoursite.com/tags/template-Language/"}]},{"title":"Node-Express","slug":"node-study-express","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-16T11:08:16.000Z","comments":true,"path":"2017/08/29/node-study-express/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-express/","excerpt":"","text":"Node Express 실습환경Glitch Tutorial 나의 Glitch Express Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크 내장하고 있는 기능은 매우 적으나, 미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음 공식 매뉴얼 한국어 번역 Express 앱의 기본 구조12345678910111213141516// Express Instance 생성const app = express()// 미들웨어 주입app.use(sessionMiddleware())app.use(authenticationMiddleware())// router handler registerapp.get('/', (request, response) =&gt; &#123; response.send('Hello express!')&#125;)// Server Startapp.listen(3000, ()=&gt;&#123; console.log('Example app listening on port 3000!')&#125;) Routing1234567891011121314151617181920212223const app = express()// HTTP Request Method (GET, POST, DELETE, PUT, ...)app.get('/articles', (req, res) =&gt; &#123; res.send('Hello Routing!')&#125;)// 특정 경로에만 미들웨어를 주입하는 것도 가능app.post('/articles', bodyParserMiddleware(), (req, res) =&gt; &#123; database.articles.create(req.body) // 요청한 body를 넣어둔다. .then(() =&gt; &#123; res.send(&#123;ok: true&#125;) &#125;)&#125;)// 경로의 특정 부분을 함수의 인자처럼 입력받을 수 있음app.get('/articles/:id', (req, res)=&gt; &#123; database.articles.find(req.params.id) // 'req.params.id'에 요청한 사람의 id가 저장된다. .then(article =&gt; &#123; res.send(article) &#125;)&#125;) Request 객체req.body requset.body를 적절한 형태의 자바스크립트 객체로 변환하여 이곳에 저장 (body-parser 미들웨어에 의해 처리됨) req.ip 요청한 쪽의 IP req.params route parameter req.query query string이 객체로 저장됨 Response 객체res.status(...) 응답의 상태 코드를 지정하는 메소드 res.append(...) 응답의 헤더를 지정하는 메소드 res.send(...) 응답의 바디를 지정하는 메소드 인자가 텍스트면 text/html, 객체면 application/json타입으로 응답 숫자를 send에 넣으면 error가 발생한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Express","slug":"Node-js/Express","permalink":"http://yoursite.com/categories/Node-js/Express/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://yoursite.com/tags/Express/"}]},{"title":"Node-Rest-API","slug":"node-study-restapi","date":"2017-08-28T03:54:00.000Z","updated":"2017-09-14T13:23:54.000Z","comments":true,"path":"2017/08/28/node-study-restapi/","link":"","permalink":"http://yoursite.com/2017/08/28/node-study-restapi/","excerpt":"","text":"Node Rest API 실습PostMan REST API를 시험해볼 수 있는 도구 다양한 편의기능 제공 Github Rest API https://api.github.com/users/KimSejune 나의 정보를 받아올수있다.Rest API link HTTP의 전송 GET/user/repo Authorization은 Basic, Digest, Bearer 3가지로 이루어져있다. Node.js NVM을 통하여 새로운 노드를 추가적으로 설치한다. nvm 설치방법curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash 터미널을 종료한 후에 123 export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 12345# 주석: `#`으로 시작하는 명령은 bash에서 무시됩니다.# 아래 명령을 한 줄씩 차례대로 입력하세요$ nvm install 8.4$ nvm use 8.4$ nvm alias default 8.4 # nvm-windows는 필요없음 다시 돌아가는 방법 nvm ls를 하고 nvm use system을 하면 원래사용하던 node로 돌아온다. nvm use default를 통해서 nvm으로 돌아온다. 1234567891011// 여러 줄에 나눠서 입력하기&gt; function factorial2(n) &#123;... return n &lt; 1 ? 1 : n * factorial(n-1)... &#125;undefined&gt; factorial2(4)24// `.exit`를 입력하거나 `Ctrl+C`를 두 번 입력해서 나가기&gt; .exit node.js module을 사용한다. 123456789// Node.js module 사용하기&gt; const os = require('os') // 급할땐 `os = ...`undefined&gt; os.platform()'darwin'&gt; os.freemem()658300928 운영체제에 상관없이 경로를 사용할 수 있게 해준다.node.js path api Node.js로 파일 실행시키기1$ node (파일 경로) Node js의 이론 node.js 는 js의 runtime이며 chrome의 Javascript V8 engine을 사용한다. event-drive, non-blocking I/O model을 사용한다. JavaSCript runtime js는 언어 js runtime은 js를 구동하기 위해 필요한 실행 환경 프로그래머는 런타임이 제공하는 도구를 응용해서 프로그램을 개발 웹 브라우저(chrome, edge)나 Node.js도 JavaScript 런타임의 일종 Chrome이 제공하는 웹 브라우저용 런타임 Node.js가 제공하는 서버용 런타임 MongoDB가 제공하는 데이터 처리용 런타임 Photoshop이 제공하는 전용 런타임 V8 JavaScript Engine JIT(Just-In-Time) compilation Code Optimization Used in Google Chrome Node.js MongoDB … js가 V8 js engine을 통하여 속도가 대폭 향상되었다. Event-driven Programming 프로그램의 흐름이 외부 요인에 의해 일어나는 사건에 의해 결정되는 프로그래밍 양식 약속된 방식으로 이벤트 핸들러를 작성함으로써 외부 이벤트가 일어났을 때 코드를 실행 마우스 입력 키보드 입력 다른 프로그램/컴퓨터로부터의 통신 123456789101112// DOM 이벤트 핸들러 등록 (웹 브라우저)domElement.addEventListener('click', function(e) &#123; e.stopPropagation() alert('hello')&#125;)// 서버도 똑같이 합니다.// (단, 프레임워크를 쓸 때는 직접 이벤트를 다룰 일이 별로 없음)// HTTP 응답 이벤트 핸들러 등록 (Node.js)httpResponse.on('data', data =&gt; &#123; console.log(data)&#125;) node.js를 할 때 직접적으로 이벤트를 다룰 일은 별로 없다. Non-blocking I/O Blocking I/O는 스레드가 입력/출력이 완료될 때까지 기다렸다가 다음 코드를 실행 Non-blocking I/O는 스레드가 입력/출력을 기다리지 않고 코드를 계속 실행 I/O 성능 향상 &amp; 복잡한 코드 Node.js Module123456789101112131415// name.js// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음module.exports = &#123; familyName: '김', givenName: '승하', fullName: function() &#123; return this.familyName + this.givenName &#125;&#125;// calc.js// `exports`로도 참조 가능exports.add = (x, y) =&gt; x + yexports.sub = (x, y) =&gt; x - y name.js에서 저장한 module.exports의 값들을 다른 파일에서 사용할 수 있게한다. module.exports 안에는 빈객체가 들어있어서 exports. ~~ 를해도 코드가 작동한다. module를 생략해도된다. 단) 객체를 통째로 생성할때는 module을 붙여준다. 123456789101112131415&gt; const name = require('./name.js')undefined&gt; name&#123; familyName: '김', givenName: '세준', fullName: [Function: fullName] &#125;&gt; name.familyName'김'&gt; name.givenName'세준'&gt; name.fullName[Function: fullName]&gt; name.fullName()'김세준'&gt; 객체를 내가원하는 함수에다가 바로 넘길수도 있다 ReceiveObjsct(require(&#39;./name.js&#39;)) node.js는 module마다 각각의 scope가 존재한다. 그래서 전역에다가 저장이 안되고 module scope에다가 저장을 한다. 다른 module에서 사용하려면 무조건 export안에 들어있어야한다. REPL에서 불러오기 Node.js 패키지 관리 도구 + 클라우드 패키지 저장소 의존 패키지 관리 스크립트 실행 패키지 설정 NPM에 패키지 배포 Node.js 종합 작업 도구 Hello NPM1234567891011121314151617$ mkdir hello-npm$ cd hello-npm$ npm init -y$ code .// package.json&#123; \"name\": \"hello-npm\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\"&#125; package.json 패키지 정보를 담고 있는 파일 dependencies npm install --save 명령으로 설치한 패키지가 기록됨 scripts 원래 목적은 패키지 생명주기마다 자동으로 실행되는 명령을 등록하기 위함이나, 개발자 편의를 위해 자주 사용되는 명령을 등록하는 용도로 더 많이 사용됨 1234567891011$ npm install --save randomstring # node_modules에 저장됨// index.jsconst randomstring = require('randomstring')console.log(randomstring.generate())// package.json... \"scripts\": &#123; \"start\": \"node index.js\" &#125;...$ npm start // start라는 이름으로 script에 등록을 하여서 실행시킬수있다. Concurrency(동시성)Concurrency Model(동시성 모델) 프로그램이 생애 주기가 겹치는 여러 실행 과정을 통해 실행된다 하더라도 프로그램의 결과에는 영향을 미치지 않는 성질 생애 주기가 겹치는 여러 실행 과정이 자원을 공유할 때 어떻게 충돌이 생기지 않도록 할 것인가? Resources CPU Memory Network thread 코드 실행의 가장 작은 단위 프로그램은 하나 이상의 스레드로 이루어짐 CPU 코어 하나는 한 번에 하나의 스레드를 실행 thread 확인방법 1$ sysctl -n hw.ncpu // 시스템의 코어개수 운영체제 차원의 도구 Process Thread Mutex (Mutual Exclusion) 언어 차원의 도구 Python - asyncio Go - goroutine Erlang - actor JavaScript - …? 자바스크립트의 동시성(Single-Threaded Event Loop) 자바스크립트를 실행시키는 스레드가 하나 뿐임 실행 과정(보통 콜백 연쇄)의 생애 주기가 겹칠 수는 있지만 어떤 경우에도 두 자바스크립트 실행과정이 동시에 실행되는 경우는 없음 내부적으로 메시지 큐를 활용하고 있으나, 모든 처리가 자동으로 이루어짐MDN 장점 프로그래머가 동시성에 대해 신경쓸 필요가 없어짐 프로그램 작성이 쉬워짐 단점 CPU를 많이 쓰는 작업에 부적절 오래 걸리는 자바스크립트 코드가 실행되면 전체 프로그램에 영향을 미침 전략 오래 걸리는 일은 외부에 위임하고 넘어간 뒤, 나중에 결과를 받아 처리하기 Database Node.js-External libraries Web browser - webAssembly 긴 실행과정을 여러개의 함수로 쪼개서한 번의 함수 실행이 금방 끝나게 만들기 Ascynchronous JavaScript non-blocking하고 비슷한 개념이다. 코드의 작성법에 대한 개념이다. Ascynchronous Callback 함수를 호출할 떄, 콜백까지 같이 인자에 넣어서 호출하는 비동기 프로그래밍 양식 콜백에서 에러 인자를 받는 방식으로 에러 처리를 함 Node.js 내장 모듈 전체가 이 방식을 사용하도록 만들어져 있음 모든 콜백이 비동기인 것은 아님 12&gt; [1,2,3].map(x =&gt; x*x)[ 1, 4, 9 ] 계산을 기다렸다가 바로 출력한다. readFile fs라는 file에 내장되어있다. 첫번째 인자를 err로 받는다. 123456789101112// readFile.js 비동기식 코드const fs = require('fs') // Node.js 내장 모듈fs.readFile('./calc.js', 'utf8', (err, data) =&gt; &#123; console.log(data)&#125;)console.log('done!')// readFileSync.js 동기식 코드const fs = require('fs') // Node.js 내장 모듈const data = fs.readFileSync('./calc.js', 'utf8')console.log(data)console.log('done!') try, catch는 동기식에서만 에러처리를 할 수 있다. request 설치12$ # hello-npm 폴더 안에서 실행$ npm install --save request Github REST API 호출123456789101112131415161718192021222324252627282930313233// 유저 이름, 저장소, 할당된 이슈 갯수 출력하기const request = require('request')const apiUrl = 'https://api.github.com'const option = &#123; json: true, auth: &#123; 'user': 'username', 'pass': 'password', &#125;, headers: &#123; 'User-Agent': 'request' &#125;&#125;request.get(`$&#123;apiUrl&#125;/user`, option, function (error, response, body) &#123; const name = body.name if (error) console.error(error) // 콜백 안에 콜백 request.get(`$&#123;apiUrl&#125;/user/repos`, option, function (error, response, body) &#123; if (error) console.error(error) const repoNames = body.map(item =&gt; item.name) // 콜백 안에 콜백 안에 콜백 request.get(`$&#123;apiUrl&#125;/issues`, option, function (error, response, body) &#123; if (error) console.error(error) const issueNum = body.length console.log(`name: $&#123;name&#125;`) console.log('repos:') repoNames.forEach(name =&gt; &#123; console.log(name) &#125;) console.log(`num of assigned issues: $&#123;issueNum&#125;`) &#125;) &#125;)&#125;) request function이 만든사람이 error, response, body 를 parameter로 받는다. Callback Hell Callback의 Hell을 방지하기 위해서 Promise를 사용한다. Promise 비동기 작업의 결과를 담는 객체 정확히 언제가 될지 모르지만, 결국 성공 또는 실패의 상태를 갖게 됨 12345678910111213141516171819// tenSec.jsmodule.exports = function tenSec(value) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(value) &#125;, 10000) &#125;)&#125;// REPL&gt; const tenSec = require('./tenSec')&gt; const p = tenSec(1)&gt; p // 만든지 10초가 지나기 전Promise &#123; [pending], ...&gt; p // 만든지 10초가 지난 후Promise &#123; 1, ... export안에 함수를 넣어서 값이 함수로 나온다. 12345678&gt; tenSec('hello promise').then(value =&gt; &#123;... console.log(value)... &#125;)Promise &#123; // `then`은 Promise를 반환 [pending], ...&gt; // 10초 후'hello promise' then안에서 promise를 return하면 promise를 벗기고 안의 값만 들어간다. 1234567891011121314151617181920212223// chaining.jsconst tenSec = require('./tenSec')tenSec('hello promise') .then(value =&gt; &#123; console.log(value) return 1 // 위 `.then`은 값이 1인 Promise를 반환함 &#125;) .then(value =&gt; &#123; console.log(value) return tenSec('new promise') // Promise도 반환할 수 있음 &#125;) .then(value =&gt; &#123; console.log(value) &#125;) .then(() =&gt; &#123; throw new Error('error in promise') &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) .then(() =&gt; &#123; // 에러 처리 이후에도 코드 실행 가능 console.log('done') &#125;) catch 앞의 then 부분에서 에러가 발생하면 catch안의 값이 실행된다. 맨 위의 then에서 에러가나면 바로 catch로 넘어간다. promise.all([…]) 배열안의 넘기는 값들이 모두 성공해야지 성공한다. promise.rase([…]) 배열안의 값중에서 먼저 성공한것을 나타낸다. readFile - promise node.js v8부터 새로들어온 함수이다. 1234567891011// readfilePromise.jsconst &#123;promisify&#125; = require('util') // Node.js 8.0.0부터 추가됨const fs = require('fs')const readFile = promisify(fs.readFile)readFile('./calc.js', 'utf8') .then(data =&gt; &#123; console.log(data) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 파일을 다읽으면 반환하는 promise파일을 반환한다. Promise의 특징 이미 resolve 된 Promise에도 콜백을 실행할 수 있음 12&gt; const resolved = Promise.resolve(1)&gt; resolved.then(v =&gt; console.log(v)) .then에 넘겨진 콜백은 무조건 다음 루프에 실행됨 12345678&gt; (function() &#123;... Promise.resolve(1).then(v =&gt; console.log(v))... console.log(&apos;done!&apos;)... &#125;)()/* 출력:done!1*/ Promise.all1234567891011121314151617181920212223242526272829// npm install --save request-promiseconst rp = require('request-promise')const apiUrl = 'https://api.github.com'const option = &#123; json: true, auth: &#123; 'user': 'username', 'pass': 'password', &#125;, headers: &#123; 'User-Agent': 'request' &#125;&#125;const userPromise = rp.get(`$&#123;apiUrl&#125;/user`, option)const reposPromise = rp.get(`$&#123;apiUrl&#125;/user/repos`, option)const issuesPromise = rp.get(`$&#123;apiUrl&#125;/issues`, option)// 배열 내의 모든 Promise 객체가 완료되었을 때// resolve 되는 Promise를 만든다.Promise.all([userPromise, reposPromise, issuesPromise]) .then(([user, repos, issues]) =&gt; &#123; console.log(`name: $&#123;user.name&#125;`) console.log('repos:') repos.forEach(repo =&gt; &#123; console.log(repo.name) &#125;) console.log(`num of assigned issues: $&#123;issues.length&#125;`) &#125;) axiosfetch api fetch api, axios를 통하여 Ajax통신을 promise를 통하여 통신을 할 수 있게한다. Async/Await javascript의 문법을 바꾸어버렸다. 비동기 코드를 동기식 코드처럼 편하게 짤 수 있게 만든 것이다. async function은 무조건 promise를 반환하며 await가 완료될때 까지 기다린다.12345678910const tenSec = require('./tenSec')async function resolveAfterTenSec() &#123; await tenSec() return 1&#125;resolveAfterTenSec().then(value =&gt; &#123; console.log(value)&#125;) ES2017에서 도입되어, 비동기식 코드를 동기식 코드처럼 쓸 수 있는 문법 제공 Chrome 55, Node.js 8.0.0 부터 사용가능 async function 안에서 반환된 값은 최종적으로 Promise 객체로 변환되어 반환된다. async function 안에서 쓸 수 있는 await 키워드는 현재 함수를 중단시키고 Promise 객체가 충족될 때까지 기다리지만, 스레드를 block 하지 않는다. 에러 처리는 동기식 코드처럼 try, catch 블록을 통해서 한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Rest-API","slug":"Node-js/Rest-API","permalink":"http://yoursite.com/categories/Node-js/Rest-API/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"RestAPI","slug":"RestAPI","permalink":"http://yoursite.com/tags/RestAPI/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"JavaScript ES6 Promise","slug":"js-study-es6-promise","date":"2017-08-22T03:54:00.000Z","updated":"2017-11-21T11:51:57.000Z","comments":true,"path":"2017/08/22/js-study-es6-promise/","link":"","permalink":"http://yoursite.com/2017/08/22/js-study-es6-promise/","excerpt":"","text":"Javascript ES6 Promise 1. PROMISE &amp; CALLBACK HELL비동기식 처리모델 장점 병럴로 처리해 다른 요청이 BLOCKING 되지 않는다. 단점 CALLBACK HELL : 여러개의 콜백함수가 순서를 보장하기 위해 NESTING 되어 복잡도가 높아지는 것123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Promise example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Promise example&lt;/h1&gt; &lt;script&gt; function get(url) &#123; // XMLHttpRequest 객체의 생성 var req = new XMLHttpRequest(); // 비동기 방식으로 Request를 오픈한다 req.open('GET', url); // Request를 전송한다 req.send(); // Event Handler req.onreadystatechange = function () &#123; // 서버 응답 완료 &amp;&amp; 정상 응답 if (req.readyState === XMLHttpRequest.DONE) &#123; if (req.status == 200) &#123; console.log(req.response); // 비동기 함수는 실행 완료를 기달리지 않고 다음 task를 실행한다. 따라서 비동기 함수 내에서 처리 결과를 return(또는 전역변수에의 할당)하면 기대한 대로 동작하지 않는다. return req.response; // 비동기 함수의 결과에 대한 처리는 이곳에서 진행하여야 한다. &#125; else &#123; // 서버의 응답이 정상이 아니면 console.log(Error(req.statusText)); &#125; &#125; &#125;; &#125; var url = 'http://jsonplaceholder.typicode.com/posts/1'; // get 함수는 비동기 함수이므로 실행 완료를 기달리지 않고 다음 task를 수행한다. // 즉, 함수의 실행이 완료하여 함수의 반환값을 받기 이전에 다음 task로 진행된다. 따라서 res는 undefined이다. var res = get(url); console.log(res); // undefined &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 비동기 함수 내에서 처리결과를 return(또는 전역 변수에 할당)하면 기대한 대로 동작하지 않는다. CALLBACK HELL 문제점 가독성이 매우 나쁘게한다. 복잡도를 증가시켜 실수를 유발 시킬 확률이 높아진다. 에러처리가 안된다.12345678try &#123; setTimeout(function()&#123; throw 'Error!'; &#125;, 1000);&#125; catch(e) &#123; console.log('에러를 캐치하지 못한다..'); console.log(e);&#125; 3. PROMISE 상태비동기 처리가 성공하였는지 실패하였는지 등의 상태정보를 갖는다. PENDING 비동기 처리가 아직 수행되지 않은 상태 RESOLVE 또는 REJECT함수가 아직 호출되지 않은 상태이다. FULFILLED 비동기 처리가 수행된 상태(성공) RESOLVE 함수가 호출된 상태 REJECTED 비동기 처리가 수행된 상태(실패) REJECT 함수가 호출된 상태 SETTLED 비동기 처리가 수행된 상태(성공 또는 실패) RESOLVED 또는 REJECT 함수가 호출된 상태 1. PROMISE 생성PROMISE 생성자를 통해 인스턴스화한다.12345678910var promise = new Promise(function(resolve, reject) &#123; // 비동기 작업 수행 if (/* 비동기 작업 수행 성공 */) &#123; resolve('resolved!'); &#125; else &#123; /* 비동기 작업 수행 실패 */ reject(Error('rejected!')); &#125;&#125;); promise 생성자는 비동기 작업을 수행할 콜백함수를 인자로 전달받는데 이 콜백함수는 resolve 와 reject 콜백함수를 인수로 전달받는다. Promise 생성자가 인자로 전달받은 콜백함수는 비동기작업을 수행한다. 이때, 비동기 작업이 성공하면 resolve를 호출 실패하면 reject호출 2. PROMISE 후속처리 함수 THEN, CATCHPROMISE 생성자가 인자로 전달받은 콜백함수에서 비동기작업을 실행한 예제123456789// 비동기 함수function asyncFunc(param) &#123; // Promise 객체 선언과 반환 return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; // 비동기 함수 param ? resolve('resolved!') : reject('rejected!'); &#125;, 2000); &#125;);&#125;; then 두개의 콜백함수를 인자로 전달받는다. 첫번째 함수는 성공시 호출되는 함수 두번째 함수는 실패시 호출되는 함수 catch 예외 발생시 호출123456789101112131415161718192021222324252627282930313233343536373839// 비동기 함수function asyncFunc(param) &#123; // Promise 객체 선언과 반환 return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; // 비동기 함수 param ? resolve('resolved!') : reject('rejected!'); &#125;, 2000); &#125;);&#125;;// asyncFunc 함수를 호출하면 Promise 객체를 생성하고 반환한다.// 인자에 true를 전달 : resolve 메소드 호출asyncFunc(true) .then(function(data) &#123; // resolve가 실행된 경우(성공), resolve 함수에 전달된 값이 data에 저장된다 console.log(data); // resolved! &#125;,function(reason) &#123; // reject가 실행된 경우(실패), reject 함수에 전달된 값이 reason에 저장된다 console.log(reason); // rejected! throw 'Error:' + reason; &#125;).catch(function(error) &#123; // 예외 발생 시 호출된다. console.error(error); &#125;);// asyncFunc 함수를 호출하면 Promise 객체를 생성하고 반환한다.// 인자에 false를 전달 : reject 메소드 호출asyncFunc(false) .then(function (data) &#123; // resolve가 실행된 경우(성공), resolve 함수에 전달된 값이 data에 저장된다 console.log(data); &#125;, function (reason) &#123; // reject가 실행된 경우(실패), reject 함수에 전달된 값이 reason에 저장된다 console.log(reason); throw 'Error:' + reason; &#125;).catch(function (error) &#123; // 예외 발생 시 호출된다. console.error(error); &#125;); asyncFunc 함수는 함수 내부에서 Promise 객체를 생성하고 반환한다. 이 함수를 실행하면 asyncFunc 함수는 Promise 객체를 반환하는데 이 객체를 상태를 갖는다. Promise 객체의 상태에 따라 후속 처리함수를 체이닝 방식을 호출한다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Promise example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Promise example&lt;/h1&gt; &lt;script&gt; function get(url) &#123; // promise 생성과 반환 return new Promise(function (resolve, reject) &#123; // XMLHttpRequest 객체의 생성 var req = new XMLHttpRequest(); // 비동기 방식으로 Request를 오픈한다 req.open('GET', url); // Request를 전송한다 req.send(); // Event Handler req.onreadystatechange = function () &#123; // 서버 응답 완료 &amp;&amp; 정상 응답 if (req.readyState === XMLHttpRequest.DONE) &#123; if (req.status == 200) &#123; // resolve 메소드에 전달한 처리 결과는 then 메소드의 첫번째 콜백함수에서 취득 가능 resolve(req.response); // then이 캐치 &#125; else &#123; // 서버의 응답이 정상이 아니면 // reject 메소드에 전달한 처리 결과는 then 메소드의 두번째 콜백함수에서 취득 가능 reject(req.statusText); //실패 이유 &#125; &#125; &#125;; &#125;); &#125; var url = 'http://jsonplaceholder.typicode.com'; get(url + '/posts/1') .then(function (response) &#123; //데이터가 들어간다. console.log('Success 1', response); // Ajax 요청 결과에 의해 또 다른 Ajax 요청을 실행한다. // Request: /posts?userId=1 // JSON.parse(): JSON 문자열 =&gt; 객체. // 반대의 경우 : stringDefine console.log(JSON.parse(response).userId); return get(url + '/posts?userId=' + JSON.parse(response).userId); //promise 객체를 리턴 // then 메소드의 콜백 함수가 반환하는 값은 자동으로 다음에 오는 then 또는 catch 메소드로 전달된다. &#125;) .then(function (response) &#123; // Request: /posts?userId=1의 처리 결과를 수신 console.log('Success 2', response); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위의 코드는 바닐라코드이다. 프레임워크를 사용하면 이러한 부분은 해소 가능하다. 앵귤러, 리엑트, 뷰: 대표적 프레임워크","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","permalink":"http://yoursite.com/categories/JavaScript/ES6/"},{"name":"Promise","slug":"JavaScript/ES6/Promise","permalink":"http://yoursite.com/categories/JavaScript/ES6/Promise/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"}]},{"title":"JavaScript ES6 Module","slug":"js-study-es6-module","date":"2017-08-22T03:54:00.000Z","updated":"2017-11-20T12:04:19.000Z","comments":true,"path":"2017/08/22/js-study-es6-module/","link":"","permalink":"http://yoursite.com/2017/08/22/js-study-es6-module/","excerpt":"","text":"Javascript ES6 Module 1. IntroductionMODULE : 애플리케이션을 구성하는 개별적 요소 구현된 세부사항을 캡슐화하고 공개가 필요한 API를 외부에 노출해 다른 코드에서 로드하고 사용할 수 있도록 작성된 재사용 가능한 코드조각 모듈은 캡슐화가 되는 것이 기본적 공개할 것만 공개하는 것이 캡슐화이다. 모듈만의 개별적인 전역을 가져야한다. private은 함수내의 지역변수로 선언된 것으로 사용된다. COMMONJS 와 AMD(Asynchronous Module Definition) : 클라이언트 사이드에 국한되지 않고 범용적으로 사용하고자 하는 움직임이 생기면서 제안된 것 2. EXPORT &amp; IMPORT모듈안에 선언한 모든 것들은 기본적으로 해당 모듈 안에서만 참조가능하다. 모듈안에 선언한 항목을 외부에 공개해 다른 모듈들이 사용할 수 있게 하고 싶다면 export해야 한다. 123456789101112// lib.jsexport const pi = Math.PI; //공개하겠다export function square(x) &#123; // 공개하겠다 return x * x;&#125;export class Person &#123; // 공개하겠다 constructor(name) &#123; this.name = name; &#125;&#125; 선언문 앞에 매번 키워드를 붙이는 것이 싫다면 대상을 한번에 모아 export할 수 있다. 1234567891011121314// lib.jsconst pi = Math.PI;function square(x) &#123; return x * x;&#125;class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125;export &#123; pi, square, Person &#125;; import : export된 이름으로 import한다. 12345// main.jsimport &#123; pi, square, Person &#125; from './lib';console.log(pi); // 3.141592653589793console.log(square(10)); // 100console.log(new Person('Lee')); // Person &#123; name: 'Lee' &#125; 각각의 이름을 지정하지 않고 하나로 한꺼번에 import할 수 있다. 12345// main.jsimport * as lib from './lib';console.log(lib.pi); // 3.141592653589793console.log(lib.square(10)); // 100console.log(new lib.Person('Lee')); // Person &#123; name: 'Lee' &#125; 이름을 변경해 import 할 수 도 있다. 12345// main.jsimport &#123; pi as PI, square as sq, Person as P &#125; from './lib';console.log(PI); // 3.141592653589793console.log(sq(2)); // 4console.log(new P('Kim')); // Person &#123; name: 'Kim' &#125; 모듈에서 하나만을 export하는 경우, default 키워드를 사용할 수 있다. 1234567891011// lib.jsfunction (x) &#123; return x * x;&#125;export default;//축약형// lib.jsexport default function (x) &#123; return x * x;&#125; default 키워드와 함께 export한 모듈은 {}없이 임의의 이름으로 import한다. 1234// main.jsimport square from './lib';console.log(square(3)); // 9","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","permalink":"http://yoursite.com/categories/JavaScript/ES6/"},{"name":"Module","slug":"JavaScript/ES6/Module","permalink":"http://yoursite.com/categories/JavaScript/ES6/Module/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"Module","slug":"Module","permalink":"http://yoursite.com/tags/Module/"}]},{"title":"JavaScript ES6 Extended Parameter Handling","slug":"js-study-es6-extended-parameter-handling","date":"2017-08-21T03:54:00.000Z","updated":"2017-11-18T11:24:20.000Z","comments":true,"path":"2017/08/21/js-study-es6-extended-parameter-handling/","link":"","permalink":"http://yoursite.com/2017/08/21/js-study-es6-extended-parameter-handling/","excerpt":"","text":"Javascript ES6 Extended Parameter Handling 1. 기본 파라미터 초기값(Default Parameter value) 파라미터에 초기값을 설정하여 함수 내에서 수행하던 파라미터 체크 및 초기화를 간편화 할 수 있다. 123456789101112131415161718// ES5function plus(x, y) &#123; x = x || 0; y = y || 0; return x + y;&#125;console.log(plus()); // 0console.log(plus(1, 2)); // 3// ES6function plus(x = 0, y = 0) &#123; // x, y에 인수가 할당되지 않으면 초기값 0이 할당된다. return x + y;&#125;console.log(plus()); // 0console.log(plus(1, 2)); // 3 2. Rest 파라미터(Rest Parameter)2.1 Syntax Rest 파라미터를 사용하면 인수를 함수 내부에서 배열로 전달받을 수 있다. Rest 파라미터가 생성된 이유는 argument가 유사배열이다 보니 call, reply를 호출해야하는 불편함을 해소하기 위해서 생성되었다. 123456function foo( ...rest) &#123; console.log(Array.isArray(rest)); // true console.log(rest); // [ 1, 2, 3, 4, 5 ]&#125;foo(1, 2, 3, 4, 5); rest parameter는 가장 후미에 등장하거나 홀로 사용해야한다. 12345678910111213141516171819function foo(param, ...rest) &#123; console.log(param); // 1 console.log(rest); // [ 2, 3, 4, 5 ]&#125;foo(1, 2, 3, 4, 5);function bar(param1, param2, ...rest) &#123; console.log(param1); // 1 console.log(param2); // 2 console.log(rest); // [ 3, 4, 5 ]&#125;bar(1, 2, 3, 4, 5);function foo( ...rest, param1, param2) &#123; &#125;foo(1, 2, 3, 4, 5);// SyntaxError: Rest parameter must be last formal parameter 2.2 arguments와 rest 파라미터 ES6 이전에는 인자의 갯수를 사전에 알 수 없는 가변 인자 함수의 경우, arguments 객체를 통해 인자값을 확인한다. arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회가능한(iterable) 유사 배열 객체(array-like object)이다. 함수 객체의 arguments 프로퍼티는 arguments 객체를 값으로 가지며 함수 내부에서 지역변수처럼 사용된다. 123456// ES5var foo = function () &#123; console.log(arguments);&#125;;foo(1, 2); // &#123; '0': 1, '1': 2 &#125; 1234567891011// ES5function sum() &#123; // 가변 인자 함수의 경우, 파라미터를 통해 인수를 전달받는 것이 불가능하므로 arguments 객체를 활용하여 인수를 전달받는다. // arguments 객체를 배열로 변환 var array = Array.prototype.slice.call(arguments); return array.reduce(function (pre, cur) &#123; return pre + cur; &#125;);&#125;console.log(sum(1, 2, 3, 4, 5)); // 15 ES6에서는 rest 파라미터를 사용하여 가변인자를 함수 내부에 배열로 전달할 수 있다. 유사 배열인 arguments 객체를 배열로 변환하는 등의 번거로움을 피할 수 있다. 1234567// ES6function sum(...args) &#123; console.log(arguments); // (5) [1, 2, 3, 4, 5, callee: (...), Symbol(Symbol.iterator): function] console.log(Array.isArray(args)); // true return args.reduce((pre, cur) =&gt; pre + cur);&#125;console.log(sum(1, 2, 3, 4, 5)); // 15 Arrow function에는 arguments 프로퍼티가 없다. Arrow function에서 가변 인자 함수를 구현하는 경우, rest 파라미터를 사용하여야 한다. 123456789// ES6const sum = (...args) =&gt; &#123; // console.log(arguments); // Uncaught ReferenceError: arguments is not defined console.log(Array.isArray(args)); // true return args.reduce((pre, cur) =&gt; pre + cur);&#125;;console.log(sum(1, 2, 3, 4, 5)); // 15 3. Spread 연산자 (Spread Operator)12// ...[1, 2, 3]는 [1, 2, 3]을 개별 요소로 분리한다(-&gt; 1, 2, 3)...[1, 2, 3] // -&gt; 1, 2, 3 3.1 함수의 인수로 사용하는 경우 배열을 함수의 인수로 사용하고, 배열의 각 요소를 개별적인 파라미터로 전달하고 싶은 경우, Function.prototype.apply를 사용하는 것이 일반적이다. 12345678910111213// ES5function foo(x, y, z) &#123; console.log(x); // 1 console.log(y); // 2 console.log(z); // 3&#125;// 배열을 foo 함수의 인자로 전달하려고 한다.const arr = [1, 2, 3];// apply 함수의 2번째 인자(배열)는 호출하려는 함수(foo)의 개별 인자로 전달된다.foo.apply(null, arr);// foo.call(null, 1, 2, 3); ES6의 Spread 연산자(…)를 사용한 배열을 함수의 인수로 사용하면 배열의 요소를 개별적으로 분리하여 순차적으로 파라미터에 할당한다. 12345678910111213// ES6function foo(x, y, z) &#123; console.log(x); // 1 console.log(y); // 2 console.log(z); // 3&#125;// 배열을 foo 함수의 인자로 전달하려고 한다.const arr = [1, 2, 3];// ...[1, 2, 3]는 [1, 2, 3]을 개별 요소로 분리한다(-&gt; 1, 2, 3)// spread 연산자에 의해 분리된 배열의 요소는 개별적인 인자로서 각각의 매개변수에 전달된다.foo(...arr); 앞에서 살펴본 Rest 파라미터는 Spread 연산자를 사용하여 파라미터를 작성한 것을 의미한다. 형태가 동일하여 혼동할 수 있으므로 주의가 필요하다. 12345678910111213141516171819// Spread 연산자를 사용한 매개변수 정의 (= Rest 파라미터)// ...rest는 분리된 요소들을 함수 내부에서 배열로 변환한다function foo(param, ...rest) &#123; console.log(param); // 1 console.log(rest); // [ 2, 3 ]&#125;foo(1, 2, 3);// Spread 연산자를 사용한 인수// 배열 인수는 분리되어 순차적으로 매개변수에 할당function bar(x, y, z) &#123; console.log(x); // 1 console.log(y); // 2 console.log(z); // 3&#125;// ...[1, 2, 3]는 [1, 2, 3]을 개별 요소로 분리한다(-&gt; 1, 2, 3)// spread 연산자에 의해 분리된 배열의 요소는 개별적인 인자로서 각각의 매개변수에 전달된다.bar(...[1, 2, 3]); Rest 파라미터는 반드시 마지막 파라미터이어야 하지만 Spread 연산자를 사용한 인수는 자유롭게 사용할 수 있다. 123456789101112// ES6function foo(v, w, x, y, z) &#123; console.log(v); // 1 console.log(w); // 2 console.log(x); // 3 console.log(y); // 4 console.log(z); // 5&#125;// ...[2, 3]는 [2, 3]을 개별 요소로 분리한다(-&gt; 2, 3)// spread 연산자에 의해 분리된 배열의 요소는 개별적인 인자로서 각각의 매개변수에 전달된다.foo(1, ...[2, 3], 4, ...[5]); 3.2 배열에서 사용하는 경우 Spread 연산자를 배열에서 사용하는 경우, 보다 간결하고 가독성이 향상된 표현이 가능하다. 3.2.1 concat 기존 배열의 요소를 새로운 배열 요소의 일부로 만들고 싶은 경우, 배열 리터럴 구문만으로 해결할 수 없고 concat 메소드를 사용하여야 한다. 123// ES5var arr = [1, 2, 3];console.log(arr.concat([4, 5, 6])); // [ 1, 2, 3, 4, 5, 6 ] Spread 연산자를 배열에서 사용하는 경우, 배열 리터럴 구문만으로 기존 배열의 요소를 새로운 배열 요소의 일부로 만들 수 있다. 1234// ES6const arr = [1, 2, 3];// ...arr은 [1, 2, 3]을 개별 요소로 분리한다console.log([...arr, 4, 5, 6]); // [ 1, 2, 3, 4, 5, 6 ] 3.2.2 push ES5에서 기존 배열에 다른 배열을 push하기 위해서는 아래와 같은 방법을 사용한다. 12345678// ES5var arr1 = [1, 2, 3];var arr2 = [4, 5, 6];// apply 메소드의 2번째 인자는 배열. 이것은 개별 인자로 push 메소드에 전달된다.Array.prototype.push.apply(arr1, arr2);console.log(arr1); // [ 1, 2, 3, 4, 5, 6 ] Spread 연산자를 사용하면 아래와 같이 보다 간편하게 표현할 수 있다. call은 1번째 인자를 ,로 받고 apply는 2번째 인자를 배열로 받는다. 12345678// ES6const arr1 = [1, 2, 3];const arr2 = [4, 5, 6];// ...arr2는 [4, 5, 6]을 개별 요소로 분리한다arr1.push(...arr2); // == arr1.push(4, 5, 6);console.log(arr1); // [ 1, 2, 3, 4, 5, 6 ] 3.2.3 splice ES5에서 기존 배열에 다른 배열을 삽입하기 위해서는 아래와 같은 방법을 사용한다. 12345678910// ES5var arr1 = [1, 2, 3, 6];var arr2 = [4, 5];// apply 메소드의 2번째 인자는 배열. 이것은 개별 인자로 push 메소드에 전달된다.// [3, 0].concat(arr2) =&gt; [3, 0, 4, 5]// arr1.splice(3, 0, 4, 5) =&gt; arr1[3]부터 0개의 요소를 제거하고 그자리(arr1[3])에 새로운 요소(4, 5)를 추가한다.Array.prototype.splice.apply(arr1, [3, 0].concat(arr2));console.log(arr1); // [ 1, 2, 3, 4, 5, 6 ] Spread 연산자를 사용하면 아래와 같이 보다 간편하게 표현할 수 있다. 12345678// ES6const arr1 = [1, 2, 3, 6];const arr2 = [4, 5];// ...arr2는 [4, 5]을 개별 요소로 분리한다arr1.splice(3, 0, ...arr2); // == arr1.splice(3, 0, 4, 5);console.log(arr1); // [ 1, 2, 3, 4, 5, 6 ] 3.2.4 copy ES5에서 기존 배열을 복사하기 위해서는 아래와 같은 방법을 사용한다 12345678910// ES5var arr = [1, 2, 3];var copy = arr.slice();console.log(copy); // [ 1, 2, 3 ]// copy를 변경한다.copy.push(4);console.log(copy); // [ 1, 2, 3, 4 ]// arr은 변경되지 않는다.console.log(arr); // [ 1, 2, 3 ] Spread 연산자를 사용하면 아래와 같이 보다 간편하게 표현할 수 있다. 1234567891011// ES6const arr = [1, 2, 3];// ...arr은 [1, 2, 3]을 개별 요소로 분리한다const copy = [...arr];console.log(copy); // [ 1, 2, 3 ]// copy를 변경한다.copy.push(4);console.log(copy); // [ 1, 2, 3, 4 ]// arr은 변경되지 않는다.console.log(arr); // [ 1, 2, 3 ]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","permalink":"http://yoursite.com/categories/JavaScript/ES6/"},{"name":"Extended Parameter Handling","slug":"JavaScript/ES6/Extended-Parameter-Handling","permalink":"http://yoursite.com/categories/JavaScript/ES6/Extended-Parameter-Handling/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"Extended Parameter Handling","slug":"Extended-Parameter-Handling","permalink":"http://yoursite.com/tags/Extended-Parameter-Handling/"}]},{"title":"JavaScript ES6 Arrow Function","slug":"js-study-es6-arrow","date":"2017-08-21T03:54:00.000Z","updated":"2017-11-16T09:09:55.000Z","comments":true,"path":"2017/08/21/js-study-es6-arrow/","link":"","permalink":"http://yoursite.com/2017/08/21/js-study-es6-arrow/","excerpt":"","text":"Javascript ES6 Arrow Function 1. Syntax Arrow function(화살표 함수)은 function 키워드 대신 화살표(=&gt;)를 사용하여 간략한 방법으로 함수를 선언할 수 있다. 하지만 모든 경우 사용할 수 있는 것은 아니다. 문법은 아래와 같다. 123456789101112131415161718// 매개변수 지정 방법 () =&gt; &#123; ... &#125; // 매개변수가 없을 경우 ES6 function() &#123; ... &#125; // ES5 x =&gt; &#123; ... &#125; // 매개변수가 한개인 경우, 소괄호를 생략할 수 있다.(x, y) =&gt; &#123; ... &#125; // 매개변수가 여러개인 경우// 함수 몸체 지정 방법x =&gt; &#123; return x * x &#125; // single line blockx =&gt; x * x // 함수 몸체가 한줄의 표현식이라면 중괄호를 생략할 수 있으며 자동으로 return된다. 위 표현과 동일하다.() =&gt; &#123; return &#123; a: 1 &#125;; &#125;() =&gt; (&#123; a: 1 &#125;) // 위 표현과 동일하다. 객체 반환시 소괄호를 사용한다.() =&gt; &#123; // multi line block. const x = 10; return x * x;&#125;; body가 한 줄일때만 return을 생략할 수 있다. 2. Arrow function의 호출 Arrow function은 익명 함수로만 사용할 수 있다. 따라서 Arrow function을 호출하기 위해서는 함수표현식을 사용한다. 1234567// ES5var pow = function (x) &#123; return x * x; &#125;;console.log(pow(10)); // 100// ES6const pow = x =&gt; x * x;console.log(pow(10)); // 100 일급객체의 대해서 알아보자. 또는 콜백함수로 사용할 수 있다. 이 경우 일반적인 함수 표현식보다 표현이 간결하다. 12345678910111213// ES5var arr = [1, 2, 3];var pow = arr.map(function (x) &#123; // x는 요소값 return x * x;&#125;);console.log(pow); // [ 1, 4, 9 ]// ES6const arr = [1, 2, 3];const pow = arr.map(x =&gt; x * x);console.log(pow); // [ 1, 4, 9 ] map은 순회를 하며 1번째 인자는 요소값 2번째 인자는 index를 받는다. 3. arguments와 rest 파라미터 arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회가능한(iterable) 유사 배열 객체(array-like object)이다. 함수 객체의 arguments 프로퍼티는 arguments 객체를 값으로 가지며 함수 내부에서 지역변수처럼 사용된다. 123456// ES5var foo = function () &#123; console.log(arguments);&#125;;foo(1, 2); // &#123; '0': 1, '1': 2 &#125; ES5에서 매개변수 갯수가 확정되지 않은 가변 인자 함수를 구현할 때 arguments 객체가 유용하게 사용된다. 파라미터를 통해 인수를 전달받는 것이 불가능하므로 arguments 객체를 활용하여 인수를 전달받는다. 하지만 arguments 객체는 유사 배열 객체이기 때문에 배열 메소드를 사용하려면 Function.prototype.call, Function.prototype.apply를 사용하여야 하는 번거로움이 있다. 1234567891011// ES5function sum() &#123; // 가변 인자 함수의 경우, 파라미터를 통해 인수를 전달받는 것이 불가능하므로 arguments 객체를 활용하여 인수를 전달받는다. // arguments 객체를 배열로 변환 var array = Array.prototype.slice.call(arguments); return array.reduce(function (pre, cur) &#123; return pre + cur; &#125;);&#125;console.log(sum(1, 2, 3, 4, 5)); // 15 ES6의 Arrow function에는 함수 객체의 arguments 프로퍼티가 없다. 12345var es5 = function () &#123;&#125;;console.log(es5.hasOwnProperty('arguments')); // trueconst es6 = () =&gt; &#123;&#125;;console.log(es6.hasOwnProperty('arguments')); // false ES6에서는 rest 파라미터를 사용하여 가변인자를 함수 내부에 배열로 전달할 수 있다. arguments 프로퍼티가 없는 Arrow function에서 가변 인자 함수를 구현하는 경우, rest 파라미터를 사용하여야 한다. 123456789// ES6const sum = (...args) =&gt; &#123; // console.log(arguments); // Uncaught ReferenceError: arguments is not defined console.log(Array.isArray(args)); // true return args.reduce((pre, cur) =&gt; pre + cur);&#125;;console.log(sum(1, 2, 3, 4, 5)); // 15 4.this function 키워드를 사용하여 생성한 일반 함수와 Arrow function와의 가장 큰 차이점은 this이다. 4.1 일반 함수의 this 일반 함수의 경우, 해당 함수 호출 패턴에 따라 this에 바인딩되는 객체가 달라진다. 콜백함수 내부의 this는 전역 객체 window를 가리킨다. 12345678910111213function Prefixer(prefix) &#123; this.prefix = prefix;&#125;Prefixer.prototype.prefixArray = function (arr) &#123; // (A) return arr.map(function (x) &#123; return this.prefix + ' ' + x; // (B) &#125;);&#125;;var pre = new Prefixer('Hi');console.log(pre.prefixArray(['Lee', 'Kim'])); 생성자함수는 1. 빈객체를 생성하고 this를 담을 곳이다, 2. (A)에서의 this는 생성자 함수 Prefixer가 생성한 객체, 즉 생성자 함수의 인스턴스(위 예제의 경우 pre)이다. (B)에서 사용한 this는 아마도 생성자 함수 Prefixer가 생성한 객체(위 예제의 경우 pre)일 것으로 기대하였겠지만 이곳에서 this는 전역 객체 window를 가리킨다. 이는 생성자 함수와 객체의 메소드를 제외한 모든 함수(내부함수, 콜백함수 포함)의 내부의 this는 전역객체를 가리키기 때문이다. 해결방법 4가지를 아래에 소개하겠다. 1.that변수를 함수안에 선언해준다. 1234567891011121314// Solution 1: that = thisfunction Prefixer(prefix) &#123; this.prefix = prefix;&#125;Prefixer.prototype.prefixArray = function (arr) &#123; var that = this; // this: Prefixer 생성자 함수의 인스턴스 return arr.map(function (x) &#123; return that.prefix + ' ' + x; &#125;);&#125;;var pre = new Prefixer('Hi');console.log(pre.prefixArray(['Lee', 'Kim'])); 2.map의 2번째 parameter로 this를 추가한다. 12345678910111213// Solution 2: map(func, this)function Prefixer(prefix) &#123; this.prefix = prefix;&#125;Prefixer.prototype.prefixArray = function (arr) &#123; return arr.map(function (x) &#123; return this.prefix + ' ' + x; &#125;, this); // this: Prefixer 생성자 함수의 인스턴스&#125;;var pre = new Prefixer('Hi');console.log(pre.prefixArray(['Lee', 'Kim'])); ES5에 추가된 Function.prototype.bind()로 this를 바인딩한다. call(), apply()도 사용 가능하다. 12345678910111213// Solution 3: bind(this)function Prefixer(prefix) &#123; this.prefix = prefix;&#125;Prefixer.prototype.prefixArray = function (arr) &#123; return arr.map(function (x) &#123; return this.prefix + ' ' + x;; &#125;.bind(this)); // this: Prefixer 생성자 함수의 인스턴스&#125;;var pre = new Prefixer('Hi');console.log(pre.prefixArray(['Lee', 'Kim'])); 4.2 Arrow function의 this Arrow function은 언제나 자신을 포함하는 외부 scope에서 this를 계승 받는다. Lexical this란? Arrow function은 자신만의 this를 생성하지 않고 자신을 포함하고 있는 컨텍스트로 부터 this를 계승 받는다. 12345678910function Prefixer(prefix) &#123; this.prefix = prefix;&#125;Prefixer.prototype.prefixArray = function (arr) &#123; return arr.map(x =&gt; `$&#123;this.prefix&#125; $&#123;x&#125;`);&#125;;const pre = new Prefixer('Hi');console.log(pre.prefixArray(['Lee', 'Kim'])); ``를 사용하여서 한번에 문자열로 추가하였다. 5. Arrow Function을 사용해서는 안되는 경우 Arrow Function는 Lexical this를 지원하므로 콜백함수에 사용하기 편리하다. 하지만 Arrow Function을 사용하는 것이 오히려 혼란을 불러오는 경우도 있기 때문에 주의하여야 한다. 5.1 메소드 메소드 정의 시 Arrow Function을 사용하는 것은 피해야 한다. Arrow Function으로 메소드를 정의하여 보자. 1234567// Badconst obj = &#123; name: 'Lee', sayHi: () =&gt; console.log(`Hi $&#123;this.name&#125;`)&#125;;obj.sayHi(); // Hi undefined 해당 메소드를 소유한 객체 즉 해당 메소드를 호출한 객체에 this를 바인딩하지 않고 전역 객체에 바인딩된다. 따라서 Arrow Function으로 메소드를 정의하는 것은 바람직하지 않다. ES6의 축약 메소드 표현 방식으로 위 예제를 수정하여 보자. ES6의 축약 메소드 표현은 메소드명에 할당된 함수를 위한 단축 표기법이다. 123456789// Goodconst obj = &#123; name: 'Lee', sayHi() &#123; // === sayHi: function() &#123; console.log(`Hi $&#123;this.name&#125;`); &#125;&#125;;obj.sayHi(); // Hi Lee 5.2 prototype prototype에 메소드를 할당하는 경우도 동일한 문제가 발생한다. prototype에 Arrow Function 메소드를 할당하여 보자. 12345678// Badconst obj = &#123; name: 'Lee',&#125;;Object.prototype.sayHi = () =&gt; console.log(`Hi $&#123;this.name&#125;`);obj.sayHi(); // Hi undefined Arrow Function으로 객체 메소드를 정의하였을 때와 같은 문제가 발생한다. 일반 함수를 할당한다. 12345678910// Goodconst obj = &#123; name: 'Lee',&#125;;Object.prototype.sayHi = function() &#123; console.log(`Hi $&#123;this.name&#125;`);&#125;;obj.sayHi(); // Hi Lee 5.3 생성자 함수 Arrow Function은 생성자 함수로 사용할 수 없다. Arrow Function은 prototype 프로퍼티를 가지고 있지 않기 때문이다. 1234const Foo = () =&gt; &#123;&#125;;// Arrow Function은 prototype 프로퍼티가 없다console.log(Foo.hasOwnProperty('prototype')); // falseconst foo = new Foo(); // TypeError: Foo is not a constructor arrow function은 callback에서 주로사용한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","permalink":"http://yoursite.com/categories/JavaScript/ES6/"},{"name":"Arrow","slug":"JavaScript/ES6/Arrow","permalink":"http://yoursite.com/categories/JavaScript/ES6/Arrow/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"Arrow","slug":"Arrow","permalink":"http://yoursite.com/tags/Arrow/"}]},{"title":"JavaScript ES6 Enhanced-Object-Property","slug":"js-study-es6-enhanced-object-property","date":"2017-08-21T03:54:00.000Z","updated":"2017-11-18T11:22:35.000Z","comments":true,"path":"2017/08/21/js-study-es6-enhanced-object-property/","link":"","permalink":"http://yoursite.com/2017/08/21/js-study-es6-enhanced-object-property/","excerpt":"","text":"Javascript ES6 Extended Object property 객체 리터럴 프로퍼티 기능 확장 1. 프로퍼티 축약 표현 ES5에서 객체 리터럴의 프로퍼티는 프로퍼티 이름과 프로퍼티 값으로 구성된다. 123456789// ES5var x = 1, y = 2;var obj = &#123; x: x, y: y&#125;;console.log(obj); // &#123; x: 1, y: 2 &#125; ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 프로퍼티 이름을 생략(Property shorthand)할 수 있다. 이때 프로퍼티 이름은 변수의 이름으로 자동 생성된다. 123456// ES6let x = 1, y = 2;const obj = &#123; x, y &#125;;console.log(obj); // &#123; x: 1, y: 2. 프로퍼티 이름 조합 ES5에서 객체 리터럴의 프로퍼티 이름을 문자열 또는 변수를 조합하여 동적으로 생성하고 싶은 경우, 객체 리터럴과는 별도로 프로퍼티를 설정하여야 한다. 1234567891011// ES5var i = 0;var propNamePrefix = 'prop_';var obj = &#123;&#125;;obj[propNamePrefix + ++i] = i;obj[propNamePrefix + ++i] = i;obj[propNamePrefix + ++i] = i;console.log(obj); // &#123; prop_1: 1, prop_2: 2, prop_3: 3 &#125; ES6에서는 객체 리터럴 내에서 프로퍼티 이름을 동적으로 생성(Computed property name)할 수 있다. 1234567891011// ES6let i = 0;const propNamePrefix = 'prop_';const obj = &#123; [propNamePrefix + ++i]: i, [propNamePrefix + ++i]: i, [propNamePrefix + ++i]: i&#125;;console.log(obj); // &#123; prop_1: 1, prop_2: 2, prop_3: 3 &#125; 3. 메소드 축약 표현 ES5에서 객체 리터럴에 메소드를 선언하기 위해서는 function 키워드를 사용한다. 123456789// ES5var obj = &#123; name: 'Lee', sayHi: function() &#123; console.log('Hi! ' + this.name); &#125;&#125;;obj.sayHi(); // Hi! Lee ES6에서는 메소드를 선언에 function 키워드를 생략 가능하다. 12345678910// ES6const obj = &#123; name: 'Lee', // 메소드 축약 표현 sayHi() &#123; console.log('Hi! ' + this.name); &#125;&#125;;obj.sayHi(); // Hi! Lee 4. proto 프로퍼티에 의한 상속 ES5에서 객체 리터럴을 상속하기 위해서는 Object.create() 함수를 사용한다. 이를 프로토타입 패턴 상속이라 한다. 비표준방식이다. 1234567891011121314// ES5var parent = &#123; name: 'parent', sayHi() &#123; console.log('Hi! ' + this.name); &#125;&#125;;// 프로토타입 패턴 상속var child = Object.create(parent);child.name = 'child';parent.sayHi(); // Hi! parentchild.sayHi(); // Hi! child ES6에서는 객체 리터럴 내부에서 proto 프로퍼티를 직접 설정할 수 있다. 객체 리터럴에 의해 생성된 객체의 proto 프로퍼티에 다른 객체를 직접 바인딩하여 상속을 표현할 수 있음을 의미한다. 12345678910111213141516// ES6const parent = &#123; name: 'parent', sayHi() &#123; console.log('Hi! ' + this.name); &#125;&#125;;const child = &#123; // child 객체의 프로토타입 객체에 parent 객체를 바인딩하여 상속을 구현한다. __proto__: parent, name: 'child'&#125;;parent.sayHi(); // Hi! parentchild.sayHi(); // Hi! child","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","permalink":"http://yoursite.com/categories/JavaScript/ES6/"},{"name":"Enhanced Object Property","slug":"JavaScript/ES6/Enhanced-Object-Property","permalink":"http://yoursite.com/categories/JavaScript/ES6/Enhanced-Object-Property/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"Enhanced Object Property","slug":"Enhanced-Object-Property","permalink":"http://yoursite.com/tags/Enhanced-Object-Property/"}]},{"title":"JavaScript ES6 Destructuring","slug":"js-study-es6-destructuring","date":"2017-08-21T03:54:00.000Z","updated":"2017-11-17T13:47:07.000Z","comments":true,"path":"2017/08/21/js-study-es6-destructuring/","link":"","permalink":"http://yoursite.com/2017/08/21/js-study-es6-destructuring/","excerpt":"","text":"Javascript ES6 Destructuring 디스트럭처링(Destructuring)은 기존에 구조로 가지고 있던 객체(배열 또는 객체)를 분석하여 개별적인 변수에 할당하는 것이다. 배열 또는 객체 리터럴에서 필요한 값만을 추출하여 변수에 할당하거나 반환할 때 유용하다. 1. 배열 디스트럭처링 (Array destructuring) ES5의 경우, 배열의 각 요소를 배열로부터 분리하여 변수에 할당하기 위한 방법은 아래와 같다. 12345678// ES5var arr = [1, 2, 3];var one = arr[0];var two = arr[1];var three = arr[2];console.log(one, two, three); // 1 2 3 배열 디스트럭처링은 배열의 각 요소를 배열로부터 추출하여 변수 리스트에 할당한다. 이때 추출/할당 기준은 인덱스이다. 1234567// ES6 Destructuringconst arr = [1, 2, 3];// 인덱스를 기준으로 배열로부터 요소를 추출하여 변수에 할당const [one, two, three] = arr;console.log(one, two, three); // 1 2 3 배열 디스트럭처링을 위해서는 할당 연산자 왼쪽에 배열 형태의 변수 리스트가 필요하다. 12345let x, y, z;[x, y, z] = [1, 2, 3];// 위의 구문과 동치이다.let [x, y, z] = [1, 2, 3]; 왼쪽의 변수 리스트와 오른쪽의 배열은 인덱스를 기준으로 할당된다. 123456789101112131415161718192021222324let x, y, z;[x, y] = [1, 2];console.log(x, y); // 1 2[x, y] = [1];console.log(x, y); // 1 undefined[x, y] = [1, 2, 3];console.log(x, y); // 1 2[x, , z] = [1, 2, 3];console.log(x, z); // 1 3// default value[x, y, z = 3] = [1, 2];console.log(x, y, z); // 1 2 3[x, y = 10, z = 3] = [1, 2];console.log(x, y, z); // 1 2 3// spread operator[x, ...y] = [1, 2, 3];console.log(x, y); // 1 [ 2, 3 ] 배열 디스트럭처링은 배열에서 필요한 요소만 추출하여 변수에 할당하고 싶은 경우에 유용하다. [x, …y] = [1, 2, 3]; spread를 사용하면 배열로 [2,3]이 들어간다. 1234const arr = [1, 2, 3, 4];const [one, , three] = arr;console.log(one, three); // 1 3 2. 객체 디스트럭처링 (Object destructuring) ES5의 경우, 객체의 각 프로퍼티를 객체로부터 분리하여 변수에 할당하기 위해서는 프로퍼티 명(키)를 사용하여야 한다. 12345678// ES5var obj = &#123; firstName: 'Ungmo', lastName: 'Lee' &#125;;var name = &#123;&#125;;name.firstName = obj.firstName;name.lastName = obj.lastName;console.log(name); // &#123; firstName: 'Jane', lastName: 'Doe' &#125; 객체 디스트럭처링은 객체의 각 프로퍼티를 객체로부터 추출하여 변수 리스트에 할당한다. 이때 할당 기준은 프로퍼티 명(키)이다. 123456// ES6 Destructuringconst obj = &#123; firstName: 'Ungmo', lastName: 'Lee' &#125;;const &#123; firstName, lastName &#125; = obj;console.log(firstName, lastName); // Ungmo Lee 객체 디스트럭처링을 위해서는 할당 연산자 왼쪽에 객체 형태의 변수 리스트가 필요하다. 12345678910const &#123; prop1: p1, prop2: p2 &#125; = &#123; prop1: 'a', prop2: 'b' &#125;;console.log(&#123; prop1: p1, prop2: p2 &#125;); // &#123; prop1: 'a', prop2: 'b' &#125;// 아래는 위의 축약형이다const &#123; prop1, prop2 &#125; = &#123; prop1: 'a', prop2: 'b' &#125;;console.log(&#123; prop1, prop2 &#125;); // &#123; prop1: 'a', prop2: 'b' &#125;// default valueconst &#123; prop1, prop2, prop3 = 'c' &#125; = &#123; prop1: 'a', prop2: 'b' &#125;;console.log(&#123; prop1, prop2, prop3 &#125;); // &#123; prop1: 'a', prop2: 'b', prop3: 'c' &#125; 객체 디스트럭처링은 객체에서 프로퍼티 명(키)으로 필요한 프로퍼티 값만을 추출할 수 있다. 123456function margin() &#123; const left = 1, right = 2, top = 3, bottom = 4; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, bottom &#125; = margin();console.log(left, bottom); // 1 4 중첩 객체의 경우는 아래와 같이 사용한다. 생략할 수 없다.(displayColor, keyboardLayout를 나타낸다.)123456function settings() &#123; return &#123; display: &#123; color: 'red' &#125;, keyboard: &#123; layout: 'qwerty'&#125; &#125;;&#125;const &#123; display: &#123; color: displayColor &#125;, keyboard: &#123; layout: keyboardLayout &#125;&#125; = settings();console.log(displayColor, keyboardLayout); // red qwerty 객체 destricturing은 꼭 각 프로퍼티를 객체로부터 추출해서 변수리스트에 할당을 해야한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","permalink":"http://yoursite.com/categories/JavaScript/ES6/"},{"name":"Destructuring","slug":"JavaScript/ES6/Destructuring","permalink":"http://yoursite.com/categories/JavaScript/ES6/Destructuring/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"Destructuring","slug":"Destructuring","permalink":"http://yoursite.com/tags/Destructuring/"}]},{"title":"JavaScript ES6 Template Literals","slug":"js-study-es6-template-literals","date":"2017-08-21T03:54:00.000Z","updated":"2017-11-19T12:46:24.000Z","comments":true,"path":"2017/08/21/js-study-es6-template-literals/","link":"","permalink":"http://yoursite.com/2017/08/21/js-study-es6-template-literals/","excerpt":"","text":"Javascript ES6 Template Literals 템플릿 리터럴은 일반 문자열과 비슷해 보이지만, ‘ 또는 “ 같은 통상적인 따옴표 문자 대신 백틱(backtick) 문자 `를 사용한다. 123const template = `템플릿 리터럴은 '작은따옴표(single quotes)'과 \"큰따옴표(double quotes)\"를 혼용할 수 있다.`;console.log(template); 일반적인 문자열에서 줄바꿈은 허용되지 않으며 공백(white-space)를 표현하기 위해서는 백슬래시()로 시작하는 이스케이프 시퀀스(Escape Sequence)를 사용하여야 한다 12345678const template = `&lt;ul class=\"nav-items\"&gt; &lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#news\"&gt;News&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`;console.log(template); 템플릿 리터럴은 + 연산자를 사용하지 않아도 간단한 방법으로 새로운 문자열을 삽입할 수 있는 기능을 제공한다. 이를 String Interpolation(문자열 삽입)이라 한다. 12345678const first = 'Ung-mo';const last = 'Lee';// 기존의 문자열 연결console.log('My name is ' + first + ' ' + last + '.');// ES6 String Interpolationconsole.log(`My name is $&#123;first&#125; $&#123;last&#125;.`); // My name is Ung-mo Lee. ${expression}을 템플릿 대입문(template substitution)이라 한다. 123456// 템플릿 대입문에는 문자열뿐만 아니라 표현식도 사용할 수 있다.console.log(`1 + 1 = $&#123;1 + 1&#125;`); // 1 + 1 = 2const name = 'ungmo';console.log(`Hello $&#123;name.toUpperCase()&#125;`); // Hello UNGMO","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","permalink":"http://yoursite.com/categories/JavaScript/ES6/"},{"name":"Template Literals","slug":"JavaScript/ES6/Template-Literals","permalink":"http://yoursite.com/categories/JavaScript/ES6/Template-Literals/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"Template Literals","slug":"Template-Literals","permalink":"http://yoursite.com/tags/Template-Literals/"}]},{"title":"JavaScript ES6 let const","slug":"js-study-es6-let-const","date":"2017-08-21T03:54:00.000Z","updated":"2017-11-19T12:44:13.000Z","comments":true,"path":"2017/08/21/js-study-es6-let-const/","link":"","permalink":"http://yoursite.com/2017/08/21/js-study-es6-let-const/","excerpt":"","text":"Javascript ES6 let, const ES5에서의 변수선언의 유일한 방법은 var키워드를 사용하는 것이다. var 키워드의 단점 1.Function-level-scope 전역 변수의 남발(전역 변수는 어디서 변경될지 알기 힘들어지기 때문에 사용하지 않는 것이 좋다.) for loop 초기화식에서 사용한 변수를 for loop 외부 또는 전역에서 참조할 수 있다. 2.var 키워드 생략 허용 의도하지 않은 변수의 전역화 3.중복 선언 허용 의도하지 않은 변수값 변경 4.변수 호이스팅 변수를 선언하기 전에 참조가 가능하다. 전연 변수는 유효범위가 넓어서 어디에서 사용될 것인지 파악하기 힘들다 따라서 변수의 유효범위는 좁을수록 좋다. 1. let1.1 Block-level scope 대부분의 C-family 언어는 Block-level-scope를 지원하지만 JS는 Function-level-scope를 갖는다. Function-level scope : 함수내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다. Block-level scope : 코드 블럭 내에서 선언된 변수는 코드 블럭 내에서만 유효하며 코드 블럭 외부에서는 참조할 수 없다. 1234567console.log(foo); // undefinedvar foo = 123;console.log(foo); // 123&#123; var foo = 456;&#125;console.log(foo); // 456 ES6는 Block-level scope를 갖는 변수를 선언하기 위해 let 키워드를 제공한다. 1234567let foo = 123;&#123; let foo = 456; let bar = 456;&#125;console.log(foo); // 123console.log(bar); // ReferenceError: bar is not defined let 키워드로 선언된 변수는 Block-level scope를 갖는다. 1.2 중복 선언 금지 var는 중복 선언이 가능하였으나 let은 중복 선언시 SyntaxError가 발생한다. 12345var foo = 123;var foo = 456; // OKlet bar = 123;let bar = 456; // Uncaught SyntaxError: Identifier 'bar' has already been declared 1.3 호이스팅(Hoisting) 자바스크립트는 ES6에서 도입된 let, const를 포함하여 모든 선언(var, let, const, function, function*, class)을 호이스팅한다. 호이스팅이란? var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮기는 것을 말한다. let 키워드로 선언된 변수를 선언문 이전에 참조하면 ReferenceError가 발생한다. let 키워드로 선언된 변수는 스코프의 시작에서 변수의 선언까지 일시적 사각지대(Temporal Dead Zone; TDZ)에 빠지기 때문이다. 12345console.log(foo); // undefinedvar foo;console.log(bar); // Error: Uncaught ReferenceError: bar is not definedlet bar; 변수는 3단계에 걸쳐 생성된다. 선언 단계(Decllaration phase) 변수 객체(Variable Obejct)에 변수를 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다. 초기화 단계(Initialization phase) 변수 객체(Variable Object)에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다. 할당 단계(Assignment phase) undefined로 초기화된 변수에 실제값을 할당한다. var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어 진다. 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 이것을 변수 호이스팅이라 한다. let 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다. 스코프에 변수가 선언단계에 등록되지만 초기화 단계는 변수 선언문을 도달했을 때 이루어진다. 초기화 이전에 변수에 접근하려고 하면 ReferenceError 에러가 발생한다. 일시적 사각지대에 들어오면 ReferenceError가 발생한다. 1.4 클로저 Block-level scope를 지원하는 let은 var보다 직관적이다. 123456789101112var funcs = [];// 함수의 배열을 생성한다// i는 전역 변수이다for (var i = 0; i &lt; 3; i++) &#123; funcs.push(function () &#123; console.log(i); &#125;);&#125;// 배열에서 함수를 꺼내어 호출한다for (var j = 0; j &lt; 3; j++) &#123; funcs[j]();&#125; 위 코드의 실행 결과로 0, 1, 2를 기대할 수도 있지만 결과는 3이 3번 출력된다. 그 이유는 for문의 var i가 전역 변수이기 때문이다. 0, 1, 2를 출력시키기 위해서는 아래와 같은 코드가 필요하다 1234567891011121314var funcs = [];// 함수의 배열을 생성한다// i는 전역 변수이다for (var i = 0; i &lt; 3; i++) &#123; (function (index) &#123; // index는 자유변수이다. funcs.push(function () &#123; console.log(index); &#125;); &#125;(i));&#125;// 배열에서 함수를 꺼내어 호출한다for (var j = 0; j &lt; 3; j++) &#123; funcs[j]();&#125; JavaScript의 Function-level scope로 인하여 for loop의 초기화식에 사용된 변수가 전역 스코프를 갖게되어 발생하는 문제를 회피하기 위해 클로저를 활용한 방법이다. 123456789101112var funcs = [];// 함수의 배열을 생성한다// i는 for loop에서만 유효한 지역변수이면서 자유변수이다for (let i = 0; i &lt; 3; i++) &#123; funcs.push(function () &#123; console.log(i); &#125;);&#125;// 배열에서 함수를 꺼내어 호출한다for (var j = 0; j &lt; 3; j++) &#123; funcs[j]();&#125; for loop의 let i는 for loop에서만 유효한 지역 변수이다의 1.5 전역 객체와 let 전역 객체는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window 객체, Server-side(Node.js)에서는 global 객체를 의미한다. var 키워드로 선언된 변수를 전역 변수로 사용하면 전역 객체(Global Object)의 프로퍼티가 된다. 123var foo = 123; // 전역변수console.log(window.foo); // 123 let 키워드로 선언된 변수를 전역 변수로 사용하는 경우, let 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉 window.foo와 같이 접근할 수 없다. 123let foo = 123; // 전역변수console.log(window.foo); // undefined 2. const const는 상수(변하지 않는 값)를 위해 사용한다. 하지만 반드시 상수만을 위해 사용하지는 않는다. const는 let과 대부분 동일한 특징을 갖는다. 규칙을 정해줄때 사용한다. 암묵적으로 대문자로 사용한다. 2.1 선언과 초기화 let은 초기화 이후 다른 값으로 재할당이 자유로우나 const는 초기화 이후 재할당이 금지된다. 12const FOO = 123;FOO = 456; // TypeError: Assignment to constant variable. 주의할 것은 const는 반드시 선언과 동시에 초기화가 이루어져야 한다는 것이다. 1const FOO; // SyntaxError: Missing initializer in const declaration 또한 const는 let과 마찬가지로 Block-level scope를 갖는다. 12345&#123; const FOO = 10; console.log(FOO); //10&#125;console.log(FOO); // ReferenceError: FOO is not defined 2.2 상수 상수는 가독성의 향상과 유지보수의 편의를 위해 적극적으로 사용해야한다. 12345678// Low readabilityif (x &gt; 10) &#123;&#125;// Better!const MAXROWS = 10;if (x &gt; MAXROWS) &#123;&#125; 네이밍이 적절한 상수로 선언하면 가독성과 유지보수성이 대폭 향상된다. const는 객체에도 사용할 수 있다. 물론 재할당은 금지된다. 12const obj = &#123; foo: 123 &#125;;obj = &#123; bar: 456 &#125;; // TypeError: Assignment to constant variable. 2.3 const와 객체 const는 재할당이 금지된다. 이는 const 변수의 값이 객체인 경우, 객체에 대한 참조의 변경을 금지한다는 것을 의미한다. 객체의 프로퍼티는 보호되지 않는다. 다시 말하자면 재할당을 불가능하지만 할당된 객체의 내용(property)은 변경할 수 있다. 1234567891011121314const user = &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125;&#125;;// const 변수는 재할당이 금지된다.// user = &#123;&#125;; // TypeError: Assignment to constant variable.// 프로퍼티 값의 재할당은 허용된다!user.name = 'Kim';console.log(user); // &#123; name: 'Kim', address: &#123; city: 'Seoul' &#125; &#125; 객체 타입 변수 선언에는 const를 사용하는 것이 좋다. 이유는 아래와 같다. 객체에 대한 참조는 변경될 필요가 없다. 즉, 재할당이 필요없다. 만일 새로운 객체에 대한 참조를 변수에 할당해야 한다면 새로운 변수를 사용하면 된다. const를 사용한다 하더라도 객체의 프로퍼티를 변경할 수 있다. 3. var vs. let vs. const 아래와 같이 var, let, const 사용하는 것을 추천한다. ES6를 사용한다면 var 키워드는 사용하지 않는다. 변경이 발생하지 않는(재할당이 필요없는) primitive형 변수와 객체형 변수에는 const를 사용한다. 재할당이 필요한 primitive형 변수에는 let를 사용한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","permalink":"http://yoursite.com/categories/JavaScript/ES6/"},{"name":"let & const","slug":"JavaScript/ES6/let-const","permalink":"http://yoursite.com/categories/JavaScript/ES6/let-const/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"let","slug":"let","permalink":"http://yoursite.com/tags/let/"},{"name":"const","slug":"const","permalink":"http://yoursite.com/tags/const/"}]},{"title":"JavaScript ES6 Class","slug":"js-study-es6-class","date":"2017-08-21T03:54:00.000Z","updated":"2017-11-16T09:05:18.000Z","comments":true,"path":"2017/08/21/js-study-es6-class/","link":"","permalink":"http://yoursite.com/2017/08/21/js-study-es6-class/","excerpt":"","text":"Javascript ES6 Class Javascript는 프로토타입 기반(prototype-based) 객체지향형 언어다. 프로토타입 기반 프로그래밍은 클래스가 필요없는(class-free) 객체지향 프로그래밍 스타일로 프로토타입 체인과 클로저 등으로 객체 지향 언어의 상속, 캡슐화(정보 은닉) 등의 개념을 구현할 수 있다. class는 함수 객체이다. 1234567891011121314151617181920// ES5var Person = (function () &#123; // Constructor function Person(name) &#123; this._name = name; &#125; // method Person.prototype.sayHi = function () &#123; console.log('Hi! ' + this._name); &#125;; // return constructor return Person;&#125;());var me = new Person('Lee');me.sayHi(); // Hi! Lee.console.log(me instanceof Person); // true ES6의 클래스가 새로운 객체지향 모델을 제공하는 것이 아니며 사실 클래스도 함수이고 기존 프로토타입 기반 패턴의 Syntactic sugar일 뿐이다. 1. 클래스 정의 (Class Definition) ES6 클래스는 class 키워드를 사용하여 정의한다. 위에서 살펴본 Person 생성자 함수를 Person 클래스로 정의해 보자. 1234567891011121314class Person &#123; constructor(name) &#123; // 생성자 함수 this._name = name; &#125; sayHi() &#123; console.log(`Hi! $&#123;this._name&#125;`); &#125;&#125;const me = new Person('Lee');me.sayHi(); // Hi! Leeconsole.log(me instanceof Person); // true property의 생성은 항상 constructor내부에서 해야한다. New 생성자를 붙여주지 않으면 error가 발생한다. _name의 의미는 private이라는 의미를 가진다. 123456const Foo = class MyClass &#123;&#125;;const foo = new Foo();console.log(foo); // MyClass &#123;&#125;new MyClass(); // ReferenceError: MyClass is not defined 표현식으로는 자주사용하지않기에 선언식 즉 위에것을 자주 사용한다. 2. 인스턴스의 생성 new 연산자를 사용하지 않고 인스턴스를 생성하면 에러가 발생한다. 123class Foo &#123;&#125;const foo = Foo(); // TypeError: Class constructor Foo cannot be invoked without 'new' 3. constructor constructor는 인스턴스를 생성하고 초기화하기 위한 특수한 메소드이다. property를 만드는 역활을 한다. constructor 메소드는 생략할 수 있다. constructor를 생략하면 constructor() {}를 포함한 것과 동일하게 동작하지만 객체의 생성과 동시에 초기화는 할 수 없다. 123456789101112131415class Foo &#123;&#125;const foo = new Foo();console.log(foo); // Foo &#123;&#125;foo.num = 1; // 동적 프로퍼티 추가console.log(foo); // Foo &#123; num: 1 &#125;class Bar &#123; constructor(num) &#123; this.num = num; &#125;&#125;console.log(new Bar(1)); // Bar &#123; num: 1 &#125; 4. 멤버 변수 클래스 바디에는 메소드만을 포함할 수 있다. 클래스 바디에 멤버 변수를 선언하면 SyntaxError가 발생한다. 12345class Foo &#123; let name = ''; // SyntaxError constructor() &#123;&#125;&#125; 따라서 멤버 변수의 선언과 초기화는 반드시 constructor 내부에서 실시한다. 1234567class Foo &#123; constructor(name) &#123; this.name = name; // OK &#125;&#125;console.log(new Foo('Lee')); // Foo &#123; name: 'Lee' &#125; constructor 내부에서 선언한 멤버 변수 name은 this(클래스의 인스턴스)에 바인딩되어 있으므로 언제나 public이다. _name과 다르다. 12345678class Foo &#123; constructor(name) &#123; this.name = name; // OK &#125;&#125;const foo = new Foo('Lee');console.log(foo.name); // Lee 5. 호이스팅 클래스는 let, const와 같이 호이스팅되지 않는 것처럼 동작한다. 즉 class 선언문 이전에 class를 참조하면 ReferenceError가 발생한다. 12const foo = new Foo(); // ReferenceError: Foo is not definedclass Foo &#123;&#125; 클래스는 스코프의 선두에서 class의 선언까지 일시적 사각지대(Temporal Dead Zone; TDZ)에 빠지게 되기 때문에 class 선언문 이전에 class를 참조하면 ReferenceError가 발생한다. 6. getter, setter6.1 getter getter는 어떤 프로퍼티에 접근할 때마다 프로퍼티를 조작하는 행위가 필요할 때 사용한다. 사용 방법은 아래와 같다 getter은 반드시 무언가를 반환하여야 한다.12345678910111213141516class Foo &#123; constructor(arr = []) &#123; this._arr = arr; &#125; // getter: firstElem은 프로퍼티 이름과 같이 사용된다. // getter는 반드시 무언가를 반환하여야 한다. get firstElem() &#123; if (this._arr.length === 0) &#123; return null; &#125; return this._arr[0]; &#125;&#125;const foo = new Foo([1, 2]);// 프로퍼티 firstElem에 접근하면 getter가 호출된다.console.log(foo.firstElem); // 1 6.2 setter setter는 어떤 프로퍼티에 값을 할당할 때마다 프로퍼티를 조작하는 행위가 필요할 때 사용한다. 사용 방법은 아래와 같다. 12345678910111213141516171819202122232425class Foo &#123; constructor(arr = []) &#123; this._arr = arr; &#125; // getter: firstElem은 프로퍼티 이름과 같이 사용된다. // getter는 반드시 무언가를 반환하여야 한다. get firstElem() &#123; if (this._arr.length === 0) &#123; return null; &#125; return this._arr[0]; &#125; // setter: firstElem은 프로퍼티 이름과 같이 사용된다. set firstElem(elem) &#123; // ...this._arr은 this._arr를 개별 요소로 분리한다 this._arr = [elem, ...this._arr]; &#125;&#125;const foo = new Foo([1, 2]);// 프로퍼티 lastElem에 값을 할당하면 setter가 호출된다.foo.firstElem = 100;console.log(foo.firstElem); // 100","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","permalink":"http://yoursite.com/categories/JavaScript/ES6/"},{"name":"Class","slug":"JavaScript/ES6/Class","permalink":"http://yoursite.com/categories/JavaScript/ES6/Class/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"Class","slug":"Class","permalink":"http://yoursite.com/tags/Class/"}]},{"title":"JavaScript jquery Ajax","slug":"js-study-jquery-ajax-json","date":"2017-08-15T03:54:00.000Z","updated":"2017-11-26T09:26:25.000Z","comments":true,"path":"2017/08/15/js-study-jquery-ajax-json/","link":"","permalink":"http://yoursite.com/2017/08/15/js-study-jquery-ajax-json/","excerpt":"","text":"Jq Ajax &amp; JSON 7. Ajax with jQuery jQuery는 Ajax 요청과 응답을 위해 유용한 메소드들을 제공한다. 7.1 Low-Level Interface settings는 Ajax 요청 설정 정보로서 key/value의 쌍으로 이루어진 객체이다. 모든 settings는 옵션이다. url 요청이 전송될 url method http 요청 방식 (default: ‘GET’) version added: 1.9.0 type method의 alias (default: ‘GET’) 1.9.0 이전 버전에서 사용 data 서버로 전달될 데이터 dataType 서버로부터 반환될 데이터의 type. default: Intelligent Guess (xml, json, jsonp, script, html) async 요청 시 동기화 여부. 기본은 비동기(asynchronous) 요청 (default: true) timeout 요청 제한 시간. 제한 시간 안에 요청이 완료되지 않으면 요청을 취소하거나 error 콜백을 호출. jsonpCallback JSONP 요청을 위한 콜백 함수 이름 success 요청 성공 이벤트 핸들러 error 요청 실패 이벤트 핸들러 complete 요청 완료 이벤트 핸들러 7.1.1 Load HTML123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"http://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='content'&gt;&lt;/div&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: \"data/data.html\", cache: false &#125;) .done(function(data, textStatus, jqXHR) &#123; $(\"#content\").html(data); &#125;) .fail(function(jqXHR, textStatus, errorThrown)&#123; console.log(\"fail: \", jqXHR); &#125;) .always(function(data, textStatus, jqXHR)&#123; console.log(\"always: \", data); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; promise로 통신의 여부를 확인하는데 done(성공), fail(실패), always(후속처리의미) 실시한다. data는 성공했을때 첫번째 요소로 들어온다. 7.1.2 Load JSON1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"http://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='content'&gt;&lt;/div&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: \"data/data.json\", dataType: \"json\" &#125;) .done(function(data) &#123; var newContent = ''; newContent += '&lt;div id=\"tours\"&gt;'; newContent += '&lt;h1&gt;Guided Tours&lt;/h1&gt;'; newContent += '&lt;ul&gt;'; for (var i = 0; i &lt; data.tours.length; i++) &#123; newContent += '&lt;li class=\"' + data.tours[i].region + ' tour\"&gt;'; newContent += '&lt;h2&gt;' + data.tours[i].location + '&lt;/h2&gt;'; newContent += '&lt;span class=\"details\"&gt;' + data.tours[i].details + '&lt;/span&gt;'; newContent += '&lt;button class=\"book\"&gt;Book Now&lt;/button&gt;'; newContent += '&lt;/li&gt;'; &#125; newContent += '&lt;/ul&gt;&lt;/div&gt;'; $(\"#content\").html(newContent); &#125;) .fail(function(jqXHR, textStatus, errorThrown)&#123; console.log(\"fail: \", jqXHR); &#125;) .always(function(data, textStatus, jqXHR)&#123; console.log(\"always: \", data); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 7.2 Shorthand Method7.2.1 jQuery.get() HTTP GET request를 사용하여 서버로부터 데이터를 로드한다. 1jQuery.get( url [, data ] [, success ] [, dataType ] ) // Returns: jqXHR 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"http://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='content'&gt;&lt;/div&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $.get(\"data/data.html\", function(data)&#123; $(\"#content\").html(data); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 7.2.2 jQuery.getJSON() HTTP GET request를 사용하여 서버로부터 JSON-encoded 데이터를 로드한다. 12345678910111213141516171819202122232425262728293031323334jQuery.getJSON( url [, data ] [, success ] ) // Returns: jqXHR&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"http://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='content'&gt;&lt;/div&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $.getJSON(\"data/data.json\", function(data)&#123; var newContent = ''; newContent += '&lt;div id=\"tours\"&gt;'; newContent += '&lt;h1&gt;Guided Tours&lt;/h1&gt;'; newContent += '&lt;ul&gt;'; for (var i = 0; i &lt; data.tours.length; i++) &#123; newContent += '&lt;li class=\"' + data.tours[i].region + ' tour\"&gt;'; newContent += '&lt;h2&gt;' + data.tours[i].location + '&lt;/h2&gt;'; newContent += '&lt;span class=\"details\"&gt;' + data.tours[i].details + '&lt;/span&gt;'; newContent += '&lt;button class=\"book\"&gt;Book Now&lt;/button&gt;'; newContent += '&lt;/li&gt;'; &#125; newContent += '&lt;/ul&gt;&lt;/div&gt;'; $(\"#content\").html(newContent); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 7.2.3 jQuery.getScript() HTTP GET request를 사용하여 서버로부터 JavaScript 파일을 로드한 후 실행한다. 1jQuery.getScript( url [, success ] ) // Returns: jqXHR 7.2.4 jQuery.post() HTTP GET request를 사용하여 서버로부터 데이터를 로드한다. 1jQuery.post( url [, data ] [, success ] [, dataType ] ) // Returns: jqXHR 7.2.5 .load() 서버로부터 HTML 데이터를 로드하고 매치드셋에 적용한다. 1.load( url [, data ] [, complete ] ) // Returns: jQuery 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"http://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='content'&gt;&lt;/div&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(\"#content\").load(\"data/data.html\", function()&#123; console.log(\"Load was performed.\"); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"jQuery","slug":"JavaScript/jQuery","permalink":"http://yoursite.com/categories/JavaScript/jQuery/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript jquery basic","slug":"js-study-jquery-basic","date":"2017-08-15T03:54:00.000Z","updated":"2017-11-26T09:25:54.000Z","comments":true,"path":"2017/08/15/js-study-jquery-basic/","link":"","permalink":"http://yoursite.com/2017/08/15/js-study-jquery-basic/","excerpt":"","text":"jQuery Basic1. Introduction jQuery는 존 레식이 2006년에 발표한 크로스 플랫폼을 지원하는 경량의 자바스크립트 라이브러리이다. jQuery의 특징 크로스 플랫폼을 지원하는 jQuery는 어떠한 브라우저에서도 동일하게 동작한다. 이것은 브라우저 호환성을 고려하여 대체 코드(Polyfill)를 작성할 필요가 없다는 것을 의미한다. 네이티브 DOM API(DOM Query, Traversing, Manipulation 등)보다 직관적이고 편리한 API를 제공한다. CSS 스타일의 selector를 사용할 수 있으며 조작 또한 강력하며 유연하다. 이벤트 처리, Ajax, Animation 효과를 쉽게 사용할 수 있다. 다양한 플러그인이 존재하며 다른 라이브러리들과 충돌을 일으키지 않는다. 2. jQuery의 설치 jQuery 1.x과 jQuery 2.x 두가지 버전이 존재한다. 두가지 버전 모두 동일한 API을 제공하지만 jQuery 2.x는 IE 8 이하를 지원하지 않으므로 주의가 필요하다. 2.1 npm download1$ npm install jquery 3.jQuery 함수 jQuery 객체를 생성하기 위해서는 jQuery 함수를 사용한다. 12jQuery() $() // 축약형 3.1 CSS 스타일의 selector를 인수로 전달받을 때 jQuery는 CSS 스타일의 selector를 이용하여 요소를 선택할 수 있다. 12jQuery('h1');$('h1'); jQuery() 함수는 선택자에 의해 선택된 요소들을 jQuery 객체를 반환한다 jQuery() 함수에 의해 생성된 객체를 Matched set 또는 jQuery selection이라 한다. 묵시적 반복(implicit iteration) 한다. 3.2 HTML을 인수로 전달받을 때 HTML 문자열을 인수로 받으면 새로운 HTML 요소를 생성한다. 1$('&lt;p id=\"test\"&gt;My &lt;em&gt;new&lt;/em&gt; text&lt;/p&gt;').appendTo('body'); 3.3 JavaScript 객체를 인수로 전달받을 때 JavaScript 객체(plain object, DOM element, array 등)를 인수로 받으면 그 객체를 jQuery 객체로 wrap한 객체를 반환한다. 1234567891011121314151617181920$('div.foo').click(function () &#123; $(this).slideUp();&#125;);// Define a plain objectvar foo = &#123; foo: 'bar', hello: 'world' &#125;;// Pass it to the jQuery functionvar $foo = $(foo);// Accessing property valuesvar test1 = $foo.prop('foo');console.log(test1); // bar// Setting property values$foo.prop('foo', 'foobar');// Accessing property valuesvar test2 = $foo.prop('foo');console.log(test2); // foobar 3.4 콜백함수를 인수로 전달받을 때12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id=\"main-heading\"&gt;What is jQuery?&lt;/h1&gt; &lt;p&gt;jQuery is the most popular JavaScript library.&lt;/p&gt; &lt;h1&gt;Why should you learn jQuery?&lt;/h1&gt; &lt;p class=\"note\"&gt;Note: jQuery functions use the DOM API (like &lt;code&gt;document.getElementById&lt;/code&gt;).&lt;/p&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(document.function()&#123; $('h1').text('Hello'); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 안전하게 DOM을 조작하기 위해서는 DOM이 완전히 로드된 후 자바스크립트가 실행되는 것이 바람직한데 이를 위해 이벤트 처리가 필요하다. 12345678910111213jQuery(document).ready(function () &#123; // Do something...&#125;);// Shorthand for jQuery(document).ready()$(document).ready(function () &#123; // Do something...&#125;);// Shorthand for $(document).ready()$(function () &#123; // Do something...&#125;); DOM이 사용될 준비가 되었을때 실행한다. 4. Selector jQuery는 CSS 스타일의 Selector를 이용하여 요소를 선택할 수 있다. 이것은 자바스크립트 DOM API보다 쉽고 강력하며 유연하다. 4.1 태그 / ID / Class 선택자 jQuery는 반복문 없이 해당하는 모든 요소에 접근/조작할 수 있다. 이를 묵시적 반복(implicit iteration)이라 한다. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Where do you want to go?&lt;/h1&gt; &lt;h2&gt;Travel Destinations&lt;/h2&gt; &lt;p&gt;Plan your next adventure.&lt;/p&gt; &lt;ul id=\"destinations\"&gt; &lt;li&gt;Rome&lt;/li&gt; &lt;li&gt;Paris&lt;/li&gt; &lt;li class=\"promo\"&gt;Rio&lt;/li&gt; &lt;/ul&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; console.log($('li')); // [li, li, li.promo, prevObject: n.fn.init(1), context: document, selector: \"li\"] $('li').text('Orlando'); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.2 후손 선택자 (Descendant Selector) id가 destinations인 ul 요소의 후손을 모두 선택한다. 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Where do you want to go?&lt;/h1&gt; &lt;h2&gt;Travel Destinations&lt;/h2&gt; &lt;p&gt;Plan your next adventure.&lt;/p&gt; &lt;ul id=\"destinations\"&gt; &lt;li&gt;Rome&lt;/li&gt; &lt;li&gt;Paris&lt;/li&gt; &lt;li class=\"promo\"&gt;Rio&lt;/li&gt; &lt;/ul&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $('#destinations .promo').text('Orlando'); // var el = document.querySelectorAll('#destinations .promo'); // for (var i = 0; i &lt; el.length; i++) &#123; // el[i].textContent = 'Orlando'; // &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.3 자식 선택자 (Child Selector) 자식 선택자를 사용하여 ul 요소의 자손 중에 li 요소를 선택한다. 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Where do you want to go?&lt;/h1&gt; &lt;h2&gt;Travel Destinations&lt;/h2&gt; &lt;p&gt;Plan your next adventure.&lt;/p&gt; &lt;ul id=\"destinations\"&gt; &lt;li&gt;Rome&lt;/li&gt; &lt;li&gt; &lt;ul id=\"france\"&gt; &lt;li&gt;Paris&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"promo\"&gt;Rio&lt;/li&gt; &lt;/ul&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $('#destinations &gt; li').text('Orlando').css('color', 'red'); // var el = document.querySelectorAll('#destinations &gt; li'); // for (var i = 0; i &lt; el.length; i++) &#123; // el[i].textContent = 'Orlando'; // el[i].style.color = 'red'; // &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.5 가상 클래스 선택자 (Pseudo-Class Selector)1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Where do you want to go?&lt;/h1&gt; &lt;h2&gt;Travel Destinations&lt;/h2&gt; &lt;p&gt;Plan your next adventure.&lt;/p&gt; &lt;ul id=\"destinations\"&gt;&lt;li&gt;Rome&lt;/li&gt;&lt;li&gt;Paris&lt;/li&gt;&lt;li class=\"promo\"&gt;Rio&lt;/li&gt;&lt;/ul&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $('#destinations li:first').css('color', 'red'); $('#destinations li:last').css('color', 'blue'); // $('#destinations li:odd').css('color', 'orange'); // $('#destinations li:even').css('color', 'purple'); // var el = document.getElementById('destinations'); // console.log(el.firstChild); // console.log(el.lastChild); // el.firstChild.style.color = 'red'; // el.lastChild.style.color = 'blue'; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5. Traversing Selector를 사용하여 matched set을 생성한 이후, matched set의 요소들과 관련있는 다른 요소에 접근할 수 있다. 이를 DOM 탐색(DOM Traversing)이라 한다. 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Where do you want to go?&lt;/h1&gt; &lt;h2&gt;Travel Destinations&lt;/h2&gt; &lt;p&gt;Plan your next adventure.&lt;/p&gt; &lt;ul id=\"destinations\"&gt; &lt;li&gt;Rome&lt;/li&gt; &lt;li&gt;Paris&lt;/li&gt; &lt;li class=\"promo\"&gt;Rio&lt;/li&gt; &lt;/ul&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; var el1 = $('#destinations li'); // Descendant Selector var el2 = $('#destinations').find('li'); // Traversing console.log(el1); // [li, li, li.promo, prevObject: n.fn.init(1), context: document, selector: \"#destinations li\"] console.log(el2); // [li, li, li.promo, prevObject: n.fn.init(1), context: document, selector: \"#destinations li\"] &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 위 두 코드는 결과적으로 ul 요소의 후손 중 li 요소를 모두 선택한다. 그러나 Traversing은 선택자 방식보다 더 빠르다. 6. Manipulation DOM에 새로운 요소를 추가/삭제, 복사, 속성 변경 등을 실시할 수 있다. 이를 DOM 조작(DOM Manipulation)이라 한다. 6.1. Appending HTML에 의해 생성된 DOM에 새로운 요소를 추가한다. 우선 jQuery 함수를 사용하여 추가할 요소를 생성한다. 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li class=\"vacation\"&gt; &lt;h2&gt;Hawaiian Vacation&lt;/h2&gt; &lt;button&gt;Get Price&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; var price = $('&lt;p&gt;From $399.99&lt;/p&gt;'); $('.vacation').append(price); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; DOM에 콘텐츠를 삽입할 때, 위치를 지정할 수 있다. 이때 사용할 수 있는 메소드는 4가지이다. append() : 선택 요소의 닫는 태그 앞에 콘텐츠를 삽입한다. prepend() : 선택 요소의 여는 태그 뒤에 콘텐츠를 삽입한다. after() : 선택 요소의 뒤에 콘텐츠를 삽입한다. before() : 선택 요소의 앞에 콘텐츠를 삽입한다. 6.2. Removing 요소의 제거는 remove() 메소드를 사용한다. 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li class=\"vacation\"&gt; &lt;h2&gt;Hawaiian Vacation&lt;/h2&gt; &lt;button&gt;Get Price&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; var price = $('&lt;p&gt;From $399.99&lt;/p&gt;'); $('.vacation').append(price); $('button').remove(); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 7. CSS / Attributes CSS와 요소의 속성에 관련된 메소드는 다음을 참조하기 바란다. HTML의 속성 : attribute, CSS,js의 속성(객체의 속성이라고도 한다.) : propertyid 어트리뷰트는 id 프로퍼티와 1:1매핑한다.class 어트리뷰트는 classList 프로퍼티로 변환된다. 8. Event 매치드셋에 이벤트를 바인딩하고 해당 이벤트가 발생했을 때 실행될 콜백 함수를 지정한다. 1.on( events [, selector ] [, data ], handler ) events 1개 또는 2개 이상의 공백으로 구분된 이벤트명 selector 이벤트를 바인딩할 매치드셋의 후손 선택자 data 이벤트핸들러에 전달할 데이터. 이벤트핸들러의 매개변수 event.data에 담겨 전달된다. handler 이벤트가 발생했을 때 실행될 함수. 첫번째 인자로 이벤트 객체가 암묵적으로 전달된다. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li class=\"vacation\"&gt; &lt;h2&gt;Hawaiian Vacation&lt;/h2&gt; &lt;button&gt;Get Price&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $('button').on('click', function (e) &#123; var price = $('&lt;p&gt;From $399.99&lt;/p&gt;'); $('.vacation').append(price); $('button').remove(); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 버튼 요소가 여러개 있을 경우, 모든 버튼 요소가 제거된다. 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li class=\"vacation\"&gt; &lt;h2&gt;Hawaiian Vacation&lt;/h2&gt; &lt;button&gt;Get Price&lt;/button&gt; &lt;/li&gt; &lt;li class=\"vacation\"&gt; &lt;h2&gt;Orlando&lt;/h2&gt; &lt;button&gt;Get Price&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $('button').on('click', function () &#123; var price = $('&lt;p&gt;From $399.99&lt;/p&gt;'); $('.vacation').append(price); $('button').remove(); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 이벤트를 발생시킨 버튼만을 제거하도록 수정한다. 이때 jQuery 함수를 사용하여 this를 jQuery 객체화하여야 한다. $(this)는 $(event.target)과 같다. 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li class=\"vacation\"&gt; &lt;h2&gt;Hawaiian Vacation&lt;/h2&gt; &lt;button&gt;Get Price&lt;/button&gt; &lt;/li&gt; &lt;li class=\"vacation\"&gt; &lt;h2&gt;Orlando&lt;/h2&gt; &lt;button&gt;Get Price&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $('button').on('click', function () &#123; var price = $('&lt;p&gt;From $399.99&lt;/p&gt;'); $('.vacation').append(price); $(this).remove(); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 이벤트를 발생 시킨 버튼만을 제거할 수 있도록 수정되었으나 가격은 아직도 정상적으로 동작하지 않는다. 이벤트를 발생 시킨 버튼이 제거된 이후 그곳에만 가격이 표시되도록 수정한다. 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li class=\"vacation\"&gt; &lt;h2&gt;Hawaiian Vacation&lt;/h2&gt; &lt;button&gt;Get Price&lt;/button&gt; &lt;/li&gt; &lt;li class=\"vacation\"&gt; &lt;h2&gt;Orlando&lt;/h2&gt; &lt;button&gt;Get Price&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $('button').on('click', function () &#123; var price = $('&lt;p&gt;From $399.99&lt;/p&gt;'); $(this).after(price); $(this).remove(); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 가격을 나타내는 p 요소를 버튼 요소와는 별도로 li 요소의 자식으로 추가하는 것이 안전하다. 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li class=\"vacation\"&gt; &lt;h2&gt;Hawaiian Vacation&lt;/h2&gt; &lt;button&gt;Get Price&lt;/button&gt; &lt;/li&gt; &lt;li class=\"vacation\"&gt; &lt;h2&gt;Orlando&lt;/h2&gt; &lt;button&gt;Get Price&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $('button').on('click', function () &#123; var price = $('&lt;p&gt;From $399.99&lt;/p&gt;'); $(this).closest('.vacation').append(price); $(this).remove(); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; closest() 메소드는 매치드셋과 가장 근접한 상위 요소를 반환한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"jQuery","slug":"JavaScript/jQuery","permalink":"http://yoursite.com/categories/JavaScript/jQuery/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript Ajax","slug":"js-study-ajax","date":"2017-08-14T03:54:00.000Z","updated":"2017-11-14T00:22:38.000Z","comments":true,"path":"2017/08/14/js-study-ajax/","link":"","permalink":"http://yoursite.com/2017/08/14/js-study-ajax/","excerpt":"","text":"JavaScript Ajax3. Ajax 요청 및 응답 처리 브라우저는 XMLHttpRequest 객체를 이용하여 Ajax 요청을 생성한다. 서버가 브라우저의 요청에 대해 응답을 반환하면 같은 XMLHttpRequest 객체가 그 결과를 처리한다. 요청 처리의 예이다. 123456// XMLHttpRequest 객체의 생성var req = new XMLHttpRequest();// 비동기 방식으로 Request를 오픈한다req.open('GET', 'data/test.json', true);// Request를 전송한다req.send(); 응답 처리의 예이다.(event로 처리한다.) 12345678910111213// XMLHttpRequest.readyState 프로퍼티가 변경(이벤트 발생)될 때마다 콜백함수(이벤트 핸들러)를 호출한다.req.onreadystatechange = function (e) &#123; // readyStates는 XMLHttpRequest의 상태(state)를 반환 // readyState: 4 =&gt; DONE(서버 응답 완료) if (req.readyState === XMLHttpRequest.DONE) &#123; // status는 response 상태 코드를 반환 : 200 =&gt; 정상 응답 if(req.status == 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(\"Error!\"); &#125; &#125;&#125;; XMLHttpRequest.readyState 서버의 state를 나타낸다. readXMLHttpRequest.readyState의 값은 아래와 같다 0 UNSENT XMLHttpRequest.open() 메소드 호출 이전 1 OPENED XMLHttpRequest.open() 메소드 호출 완료 2 HEADERS_RECEIVED XMLHttpRequest.send() 메소드 호출 완료 3 LOADING 서버 응답 중(XMLHttpRequest.responseText 미완성 상태) 4 DONE 서버 응답 완료 12345678910111213141516171819202122// XMLHttpRequest 객체의 생성var req = new XMLHttpRequest();// 비동기 방식으로 Request를 오픈한다req.open('GET', 'data/test.json', true);// Request를 전송한다req.send();// XMLHttpRequest.readyState 프로퍼티가 변경(이벤트 발생)될 때마다 콜백함수(이벤트 핸들러)를 호출한다.req.onreadystatechange = function (e) &#123; // 이 함수는 Response가 클라이언트에 도달하면 호출된다. // readyStates는 XMLHttpRequest의 상태(state)를 반환 // readyState: 4 =&gt; DONE(서버 응답 완료) if (req.readyState === XMLHttpRequest.DONE) &#123; // status는 response 상태 코드를 반환 : 200 =&gt; 정상 응답 if(req.status == 200) &#123; console.log(req.responseText); &#125; else &#123; console.log(\"Error!\"); &#125; &#125;&#125;; XMLHttpRequest의.readyState가 4인 경우, 서버 응답이 완료된 상태이므로 이후 XMLHttpRequest.status가 200(정상 응답)임을 확인하고 정상인 경우, XMLHttpRequest.responseText를 취득한다. 서버가 전송한 데이터는 XMLHttpRequest.responseText에 담겨있다. 4. JSON123456&#123; \"name\": \"Lee\", \"gender\": \"male\", \"age\": 20, \"alive\": true&#125; 반드시 &quot;&quot;를 붙여야한다. 여러개의 값을 보낼때는 배열로 보내야한다. JSON.stringify() 메소드는 객체를 JSON 형식의 문자열로 변환한다. 1234567891011121314var o = &#123; name: \"Lee\", gender: \"male\"&#125;;// 객체 =&gt; JSON 형식의 문자열var strObject = JSON.stringify(o);console.log(typeof strObject, strObject); // string '&#123;\"name\":\"Lee\",\"gender\":\"male\"&#125;'var arr = [1, 5, \"false\"];// 배열 객체 =&gt; 문자열var strArray = JSON.stringify(arr);console.log(typeof strArray, strArray); // string '[1, 5, \"false\"]' JSON.parse() 메소드는 JSON 데이터를 가진 문자열을 객체로 변환한다. 서버로부터 브라우저로 전송된 JSON 데이터는 문자열이다. 이 문자열을 객체화하여야 하는데 이를 역직렬화(Deserializing)이라 한다. 5. Web Server Express 서버 설치 123456## 데스크탑에 webserver-express 폴더가 생성된다.$ cd ~/Desktop$ git clone https://github.com/ungmo2/webserver-express.git$ cd webserver-express## install express$ npm i 6. Ajax6.1 Load HTML123456789101112131415161718192021222324252627282930313233343536&lt;!-- 루트 폴더(htdocs)/loadhtml.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"http://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script&gt; // XMLHttpRequest 객체의 생성 var req = new XMLHttpRequest(); // 비동기 방식으로 Request를 오픈한다 req.open('GET', 'data/data.html', true); // Request를 전송한다 req.send(); // Event Handler req.onreadystatechange = function () &#123; // 서버 응답 완료 &amp;&amp; 정상 응답 if (req.readyState === XMLHttpRequest.DONE) &#123; if (req.status == 200) &#123; // 정상응답 console.log(req.responseText); // 받은 데이터를 console에다가 찍는다. document.getElementById('content').innerHTML = req.responseText; // document.getElementById('content').insertAdjacentHTML('beforeend', req.responseText); &#125; else &#123; console.log('[' + req.status + ']: ' + req.statusText); &#125; &#125; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021&lt;!-- 루트 폴더(htdocs)/data/data.html --&gt;&lt;div id=\"tours\"&gt; &lt;h1&gt;Guided Tours&lt;/h1&gt; &lt;ul&gt; &lt;li class=\"usa tour\"&gt; &lt;h2&gt;New York, USA&lt;/h2&gt; &lt;span class=\"details\"&gt;$1,899 for 7 nights&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt; &lt;li class=\"europe tour\"&gt; &lt;h2&gt;Paris, France&lt;/h2&gt; &lt;span class=\"details\"&gt;$2,299 for 7 nights&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt; &lt;li class=\"asia tour\"&gt; &lt;h2&gt;Tokyo, Japan&lt;/h2&gt; &lt;span class=\"details\"&gt;$3,799 for 7 nights&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 6.2 Load JSON 서버로부터 브라우저로 전송된 JSON 데이터는 문자열이다. 이 문자열을 객체화하여야 하는데 이를 역직렬화(Deserializing)이라 한다. 역직렬화를 위해서 내장 객체 JSON의 static 메소드인 JSON.parse()를 사용한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- 루트 폴더(htdocs)/loadjson.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"http://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script&gt; // XMLHttpRequest 객체의 생성 var req = new XMLHttpRequest(); // 비동기 방식으로 Request를 오픈한다 req.open('GET', 'data/data.json', true); // Request를 전송한다 req.send(); req.onreadystatechange = function () &#123; // 서버 응답 완료 &amp;&amp; 정상 응답 if (req.readyState === XMLHttpRequest.DONE) &#123; if (req.status == 200) &#123; console.log(req.responseText); // Deserializing (String → Object) responseObject = JSON.parse(req.responseText); // JSON → HTML String var newContent = ''; newContent += '&lt;div id=\"tours\"&gt;'; newContent += '&lt;h1&gt;Guided Tours&lt;/h1&gt;'; newContent += '&lt;ul&gt;'; for (var i = 0; i &lt; responseObject.tours.length; i++) &#123; newContent += '&lt;li class=\"' + responseObject.tours[i].region + ' tour\"&gt;'; newContent += '&lt;h2&gt;' + responseObject.tours[i].location + '&lt;/h2&gt;'; newContent += '&lt;span class=\"details\"&gt;' + responseObject.tours[i].details + '&lt;/span&gt;'; newContent += '&lt;button class=\"book\"&gt;Book Now&lt;/button&gt;'; newContent += '&lt;/li&gt;'; &#125; newContent += '&lt;/ul&gt;&lt;/div&gt;'; document.getElementById('content').innerHTML = newContent; // document.getElementById('content').insertAdjacentHTML('beforeend', newContent); &#125; else &#123; console.log('[' + req.status + ']: ' + req.statusText); &#125; &#125; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819&#123; \"tours\": [ &#123; \"region\": \"usa\", \"location\": \"New York, USA\", \"details\": \"$1,899 for 7 nights\" &#125;, &#123; \"region\": \"europe\", \"location\": \"Paris, France\", \"details\": \"$2,299 for 7 nights\" &#125;, &#123; \"region\": \"asia\", \"location\": \"Tokyo, Japan\", \"details\": \"$3,799 for 7 nights\" &#125; ]&#125; 6.3 Load JSONP 동일출처원칙이란? 보안상의 이유로 다른 도메인(http와 https, 포트가 다르면 다른 도메인으로 간주한다)으로의 요청(크로스 도메인 요청)은 제한된다. 동일출처원칙(Same-origin policy) -&gt; json 파일로 받아오면 발생한다. 동일출처원칙을 우회하는 방법은 세가지가 있다. 웹서버의 프록시 파일서버에 원격 서버로부터 데이터를 수집하는 별도의 기능을 추가하는 것이다. 이를 프록시(Proxy)라 한다. 프록시가 원격 서버로부터 받은서 가진다음에 서버에게 넘겨주는 방식이다. JSONPscript 태그의 원본 주소에 대한 제약이 존재하지 않는데 이것을 이용하여 다른 도메인의 서버에서 데이터를 수집하는 방법이다. 자신의 서버에 함수를 정의하고 다른 도메인의 서버에 얻고자 하는 데이터를 인수로 하는 함수 호출문을 로드하는 것이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- 루트 폴더(htdocs)/loadjsonp.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"http://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='content'&gt;&lt;/div&gt; &lt;script&gt; function showTours(data) &#123; console.log(data); // data: object // JSON → HTML String var newContent = ''; newContent += '&lt;div id=\"tours\"&gt;'; newContent += '&lt;h1&gt;Guided Tours&lt;/h1&gt;'; newContent += '&lt;ul&gt;'; for (var i = 0; i &lt; data.tours.length; i++) &#123; newContent += '&lt;li class=\"' + data.tours[i].region + ' tour\"&gt;'; newContent += '&lt;h2&gt;' + data.tours[i].location + '&lt;/h2&gt;'; newContent += '&lt;span class=\"details\"&gt;' + data.tours[i].details + '&lt;/span&gt;'; newContent += '&lt;button class=\"book\"&gt;Book Now&lt;/button&gt;'; newContent += '&lt;/li&gt;'; &#125; newContent += '&lt;/ul&gt;&lt;/div&gt;'; document.getElementById('content').innerHTML = newContent; &#125; &lt;/script&gt; &lt;script src='http://poiemaweb.com/assets/data/data-jsonp.js'&gt;&lt;/script&gt; &lt;!-- &lt;script&gt; showTours(&#123; \"tours\": [ &#123; \"region\": \"usa\", \"location\": \"New York, USA\", \"details\": \"$1,899 for 7 nights\" &#125;, &#123; \"region\": \"europe\", \"location\": \"Paris, France\", \"details\": \"$2,299 for 7 nights\" &#125;, &#123; \"region\": \"asia\", \"location\": \"Tokyo, Japan\", \"details\": \"$3,799 for 7 nights\" &#125; ] &#125;); &lt;/script&gt; --&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920// http://poiemaweb.com/assets/data/data-jsonp.jsshowTours(&#123; \"tours\": [ &#123; \"region\": \"usa\", \"location\": \"New York, USA\", \"details\": \"$1,899 for 7 nights\" &#125;, &#123; \"region\": \"europe\", \"location\": \"Paris, France\", \"details\": \"$2,299 for 7 nights\" &#125;, &#123; \"region\": \"asia\", \"location\": \"Tokyo, Japan\", \"details\": \"$3,799 for 7 nights\" &#125; ]&#125;); Cross-Origin Resource SharingHTTP 헤더에 추가적으로 정보를 추가하여 브라우저와 서버가 서로 통신해야 한다는 사실을 알게하는 방법이다. W3C 명세에 포함되어 있지만 최신 브라우저에서만 동작하며 서버에 HTTP 헤더를 설정해 주어야 한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Ajax","slug":"JavaScript/Ajax","permalink":"http://yoursite.com/categories/JavaScript/Ajax/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"JavaScript Async","slug":"js-study-async","date":"2017-08-14T03:54:00.000Z","updated":"2017-11-14T00:23:25.000Z","comments":true,"path":"2017/08/14/js-study-async/","link":"","permalink":"http://yoursite.com/2017/08/14/js-study-async/","excerpt":"","text":"JavaScript Asynchronous processing model1. 브라우저의 동작 원리2. Ajax server에서 ajax를 통해서 데이터를 던지면 그것을 client가 받는 방식을 나타낸다. 전통적으로는 새로운 HTML을 불러와서 load부터 다시한다. 현재는 DOM Manipulation(조작)을 통하여서 ajax 통신을 한다. 서버가 존재해야한다. 3. 동기식 처리 모델 vs 비동기식 처리 모델 동기식 : 커피를 주문하고 커피가 나올때까지 대기한다. 직렬적으로 작업을 수행한다 즉 순차적으로 실행되며 작업이 수행중이면 다음 작업은 대기하게 된다. Blocking방식이다. 비동기식 : 커피를 주문하고 할일을 하고 있다가 커피를 받는다. 병렬적으로 작업을 수행한다 즉 작업이 종료되지 않은 상태라도 대기하지 않고 다음 작업을 실행한다는 의미이다. Non-Blocking방식이다. 123456789101112131415161718function func1() &#123; console.log('func1'); func2();&#125;function func2() &#123; setTimeout(function() &#123; console.log('func2'); &#125;, 0); func3();&#125;function func3() &#123; console.log('func3');&#125;func1(); setTimeout을 서버에 요청을 하고 바로 func3를 실행하기에 func1, func3, func2순서로 나온다. setTimeout은 모든 동기식이 실행된 후에 실행된다. 4. 이벤트 루프와 동시성(Concurrency) 브라우저는 단일 쓰레드(single-thread)에서 이벤트 드리븐(event-driven) 방식으로 동작한다. 자바스크립트의 동시성(Concurrency)을 지원하는 것이 바로 이벤트 루프(Event Loop)이다. js는 비동기를 못하지만 그것을 browser가 한다. thread란 컴퓨터가 일을 할때 한번에 일을 할 수 있는 정도를 나타낸다. 이벤트 드리븐(event-driven) 방식이란? 모든 application이 이벤트 방식으로 동작한다. 이벤트루프와 브라우저의 환경 Web API는 browser의 영역으로써 Ajax, DOM Events, Timer등이 있다. 구글의 V8을 비롯한 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 나뉜다. Call Stack(호출 스택) == 실행 컨텍스트 작업이 요청되면(함수가 실행되면) 요청된 작업은 순차적으로 Call Stack에 쌓이게 되고 순차적으로 실행된다. 자바스크립트는 단 하나의 Call Stack을 사용하기 때문에 해당 task가 종료하기 전까지는 다른 어떤 task도 수행될 수 없다. Heap 동적으로 생성된 객체 인스턴스가 할당되는 영역이다. 자바스크립트 엔진은 단순히 작업이 요청되면 요청된 작업을 Call Stack을 사용하여 순차적으로 실행할 뿐이다. 앞에서 언급한 동시성(Concurrency)을 지원하기 위해 필요한 비동기 요청(이벤트를 포함) 처리는 자바스크립트 엔진을 구동하는 환경 즉 브라우저(또는 Node.js)가 담당한다. Event Queue(Task Queue) 비동기 처리 함수의 콜백 함수, 비동기식 이벤트 핸들러, Timer 함수(setTimeout(), setInterval())가 보관되는 영역으로 이벤트 루프(Event Loop)에 의해 특정 시점(Call Stack이 비어졌을 때)에 순차적으로 Call Stack으로 이동되어 실행된다. Event Loop(이벤트 루프) Call Stack내에서 현재 실행중인 task가 있는지 그리고 Event Queue에 task가 있는지 반복하여 확인한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Async","slug":"JavaScript/Async","permalink":"http://yoursite.com/categories/JavaScript/Async/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Async","slug":"Async","permalink":"http://yoursite.com/tags/Async/"}]},{"title":"JavaScript Event","slug":"js-study-event","date":"2017-08-14T03:54:00.000Z","updated":"2017-11-14T00:25:52.000Z","comments":true,"path":"2017/08/14/js-study-event/","link":"","permalink":"http://yoursite.com/2017/08/14/js-study-event/","excerpt":"","text":"JavaScript Event1. Introduction2. 동기식 처리 모델 vs 비동기식 처리 모델 server에서 ajax를 통해서 데이터를 던지면 그것을 client가 받는 방식을 나타낸다. 전통적으로는 새로운 HTML을 불러와서 load부터 다시한다. 현재는 DOM Manipulation(조작)을 통하여서 ajax 통신을 한다. 서버가 존재해야한다. 동기식 : 커피를 주문하고 커피가 나올때까지 대기한다. 직렬적으로 작업을 수행한다 즉 순차적으로 실행되며 작업이 수행중이면 다음 작업은 대기하게 된다. Blocking방식이다. 비동기식 : 커피를 주문하고 할일을 하고 있다가 커피를 받는다. 병렬적으로 작업을 수행한다 즉 작업이 종료되지 않은 상태라도 대기하지 않고 다음 작업을 실행한다는 의미이다. Non-Blocking방식이다. 123456789101112131415161718function func1() &#123; console.log('func1'); func2();&#125;function func2() &#123; setTimeout(function() &#123; console.log('func2'); &#125;, 0); func3();&#125;function func3() &#123; console.log('func3');&#125;func1(); setTimeout을 서버에 요청을 하고 바로 func3를 실행하기에 func1, func3, func2순서로 나온다. setTimeout은 모든 동기식이 실행된 후에 실행된다. 3. 이벤트 루프(Event Loop)와 동시성(Concurrency) 브라우저는 단일 쓰레드(single-thread)에서 이벤트 드리븐(event-driven) 방식으로 동작한다. 자바스크립트의 동시성(Concurrency)을 지원하는 것이 바로 이벤트 루프(Event Loop)이다. js는 비동기를 못하지만 그것을 browser가 한다. thread란 컴퓨터가 일을 할때 한번에 일을 할 수 있는 정도를 나타낸다. 이벤트 드리븐(event-driven) 방식이란? 모든 application이 이벤트 방식으로 동작한다. 이벤트루프와 브라우저의 환경 Web API는 browser의 영역으로써 Ajax, DOM Events, Timer등이 있다. 구글의 V8을 비롯한 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 나뉜다. Call Stack(호출 스택) == 실행 컨텍스트 작업이 요청되면(함수가 실행되면) 요청된 작업은 순차적으로 Call Stack에 쌓이게 되고 순차적으로 실행된다. 자바스크립트는 단 하나의 Call Stack을 사용하기 때문에 해당 task가 종료하기 전까지는 다른 어떤 task도 수행될 수 없다. Heap 동적으로 생성된 객체 인스턴스가 할당되는 영역이다. 자바스크립트 엔진은 단순히 작업이 요청되면 요청된 작업을 Call Stack을 사용하여 순차적으로 실행할 뿐이다. 앞에서 언급한 동시성(Concurrency)을 지원하기 위해 필요한 비동기 요청(이벤트를 포함) 처리는 자바스크립트 엔진을 구동하는 환경 즉 브라우저(또는 Node.js)가 담당한다. Event Queue(Task Queue) 비동기 처리 함수의 콜백 함수, 비동기식 이벤트 핸들러, Timer 함수(setTimeout(), setInterval())가 보관되는 영역으로 이벤트 루프(Event Loop)에 의해 특정 시점(Call Stack이 비어졌을 때)에 순차적으로 Call Stack으로 이동되어 실행된다. Event Loop(이벤트 루프) Call Stack내에서 현재 실행중인 task가 있는지 그리고 Event Queue에 task가 있는지 반복하여 확인한다. 4. 이벤트의 종류4.1 UI Event 웹페이지가 로드될때 load 웹페이지의 로드가 완료되었을 때 unload 웹페이지가 언로드될 때(주로 새로운 페이지를 요청한 경우) error 브라우저가 자바스크립트 오류를 만났거나 요청한 자원이 존재하지 않는 경우 resize 브라우저 창의 크기를 조절했을 때 scroll 사용자가 페이지를 위아래로 스크롤할 때 select 텍스트를 선택했을 때 script문을 제일 하단에 써줘야하는 이유는 html이 전부다가 load되면 js를 실행하게 하기위해서이다. 4.2 Keyboard Event keydown 키를 누르고 있을 때 keyup 누르고 있던 키를 뗄 때 keypress 키를 누르고 뗏을 때 4.3 Mouse Event click 마우스 버튼을 클릭했을 때 dbclick 마우스 버튼을 더블 클릭했을 때 mousedown 마우스 버튼을 누르고 있을 때 mouseup 누르고 있던 마우스 버튼을 뗄 때 mousemove 마우스를 움직일 때 (터치스크린에서 동작하지 않는다) mouseover 마우스를 요소 위로 움직였를 때 (터치스크린에서 동작하지 않는다) // hover와 비슷 mouseout 마우스를 요소 밖으로 움직였를 때 (터치스크린에서 동작하지 않는다) 4.4 Focus Event focus/focusin 요소가 포커스를 얻었을 때 blur/foucusout 요소가 포커스를 잃었을 때 4.5 Form Event input input 또는 textarea 요소의 값이 변경되었을 때, contenteditable 어트리뷰트를 가진 요소의 값이 변경되었을 때 change select box, checkbox, radio button의 상태가 변경되었을 때 submit form을 submit할 때 (버튼 또는 키) reset reset 버튼을 클릭할 때 (최근에는 사용 안함) 4.6 Clipboard Event cut 콘텐츠를 잘라내기할 때 copy 콘텐츠를 복사할 때 paste 콘텐츠를 붙여넣기할 때 5. Event Binding5.1 HTML Event Handler HTML 요소의 이벤트 어트리뷰트에 이벤트 핸들러를 대응시키는 방법이다. 자주 사용되지 않는다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button onclick=\"myFunction()\"&gt;Click me&lt;/button&gt; &lt;script&gt; function myFunction() &#123; alert('Button clicked!'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.2 전통적(Traditional) DOM Event Handler HTML Event Handler처럼 HTML과 Javascript가 혼용되는 문제는 해결되었으나 이벤트 핸들러에 하나의 함수만을 바인딩할 수 있으며 함수에 인수를 전달할 수 없는 단점이 있다. 추천하는 방식이 아니다. EventHandler방식을 사용한다. 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;Click me&lt;/button&gt; &lt;script&gt; var btn = document.getElementById('btn'); // 첫번째 바인딩된 이벤트 핸들러 =&gt; 실행되지 않는다. btn.onclick = function () &#123; alert('Button clicked 1'); &#125;; // 두번째 바인딩된 이벤트 핸들러 btn.onclick = function () &#123; alert('Button clicked 2'); &#125;; // 첫번째 바인딩된 이벤트 핸들러 !!! 이것을 추천한다. btn.addEventListener('click', function () &#123; alert('Button clicked 1'); &#125;); // 두번째 바인딩된 이벤트 핸들러 btn.addEventListener('click', function () &#123; alert('Button clicked 2'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.3 DOM Level 2 Event Listener(최근 트렌드) addEventListener() 함수를 이용하여 대상 요소에 이벤트를 바인딩하고 해당 이벤트가 발생했을 때 실행될 콜백 함수를 지정한다. Bubbling은 event를 발생한 곳에서부터 위로 올라가는 방식이다. capturing은 처음부터 아래로 내려오는 방식이다. addEventListener()는 이전에 방식에 비해 보다 나은 장점을 갖는다. 하나의 이벤트에 대해 하나 이상의 핸들러를 추가할 수 있다. 캡처링과 버블링를 지원한다. HTML 요소뿐만아니라 모든 DOM 요소에 대해 동작한다. addEventListener() 함수는 IE9 이상에서 동작한다. IE 8 이하에서는 attachEvent() 함수를 사용한다. IE 버전에 대한 방어코드이다. 12345if (elem.addEventListener) &#123; // IE 9 ~ 존재여부 파악 elem.addEventListener('click', func); &#125; else if (elem.attachEvent) &#123; // ~ IE 8 elem.attachEvent('onclick', func);&#125; addEventListener()의 사용 예제를 살펴보자. 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; addEventListener('click', function() &#123; alert('Clicked!'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위와 같이 대상요소(target)를 지정하지 않으면 click 이벤트는 전역객체 window에 바인딩된다. scroll 잡을때 사용된다. 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;label for='username'&gt;User name &lt;/label&gt; &lt;input type='text' id='username'&gt; &lt;script&gt; var elem = document.getElementById('username'); elem.addEventListener('blur', function() &#123; // blur는 포커스가 빠질때 alert('blur event occurred!'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; addEventListener 안에 function의 호출이 없는데 브라우저에 의해서 실행이 된다. input 요소를 blur 이벤트에 바인딩하였다. 사용자 이름이 최소 2자 이상이야한다는 규칙을 세우고 이에 부합하는지 확인하는 처리를 한다. 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;label for=\"username\"&gt;User name &lt;/label&gt; &lt;input type=\"text\" id=\"username\"&gt; &lt;em id=\"message\"&gt;&lt;/em&gt; &lt;script&gt; var elem = document.getElementById('username'); var msg = document.getElementById('message'); elem.addEventListener('blur', function () &#123; if (elem.value.length &lt; 2) &#123; msg.innerHTML = '이름은 2자 이상 입력해 주세요'; &#125; else &#123; msg.innerHTML = ''; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; value(사용자에 의해 입력된 값)을 가져온다. 2자 이상이라는 규칙을 상수화하고 함수의 인수로 전달도록 수정하자. 이렇게 하면 규칙이 변경되어도 함수는 수정하지 않아도 된다. 12345function foo() &#123; alert('clicked!');&#125;// elem.addEventListener('click', foo()); // 이벤트 발생 시까지 대기하지 않고 바로 실행된다elem.addEventListener('click', foo); // 이벤트 발생 시까지 대기한다 // elem.addEventListener(‘click’, foo()); // 이벤트 발생 시까지 대기하지 않고 바로 실행된다. elem.addEventListener(&#39;click&#39;, foo); // 이벤트 발생 시까지 대기한다 이것을 사용해야하며 헷갈리지 않도록 조심해야한다. 문제점으로는 인수를 전달할 수 없는 문제가 발생한다. 아래의 방법으로 우회하며 중요하다. 12345678910111213141516var MIN_USER_NAME_LENGTH = 2; // 이름 최소 길이var elem = document.getElementById('username');var msg = document.getElementById('message');function checkUserNameLength(n) &#123; if(elem.value.length &lt; n) &#123; msg.innerHTML = '이름은 ' + n + '자 이상이어야 합니다'; &#125; else &#123; msg.innerHTML = ''; &#125;&#125;elem.addEventListener('blur', function() &#123; checkUserNameLength(MIN_USER_NAME_LENGTH);&#125;); 6. 핸들러 함수 내부의 this6.1 HTML Event Handler HTML Event Handler 방식의 경우, 이벤트 핸들러 내부의 this는 window를 가리킨다. 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button onclick=\"foo()\"&gt;Button&lt;/button&gt; &lt;script&gt; function foo () &#123; console.log(this); // window console.log(event.currentTarget); // &lt;button onclick=\"foo()\"&gt;Button&lt;/button&gt; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.2 전통적(Traditional) DOM Event Handler Traditional DOM Event Handler 방식에서 이벤트 핸들러 내부의 this는 이벤트에 바인딩된 요소를 가리킨다. 이것은 이벤트 객체의 currentTarget 프로퍼티와 같다. function이 method이기 때문이다.1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;Button&lt;/button&gt; &lt;script&gt; var btn = document.getElementById('btn'); btn.onclick = function() &#123; console.log(this); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(event.currentTarget); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(this === event.currentTarget); // true &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.3 DOM Level 2 Event Listener addEventListener() 함수에서 지정한 이벤트 핸들러 내부의 this는 이벤트 리스너에 바인딩된 요소(currentTarget)를 가리킨다. 이것은 이벤트 객체의 currentTarget 프로퍼티와 같다. 이것이 꼭 event를 발생시키는 것이아닌 발생시킬 수 도 있고 안시킬 수도 있다. 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;Button&lt;/button&gt; &lt;script&gt; var elem = document.getElementById('btn'); elem.addEventListener('click', function (event) &#123; console.log(this); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(event.currentTarget); // &lt;button id=\"btn\"&gt;Button&lt;/button&gt; console.log(this === event.currentTarget); // true &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7. Event Flow (이벤트의 흐름) (true) Cpature phase는 window부터 아래로 흘러갔다가 다시 window까지 올라온다. 기본값 (false) Bubbling phase는 event시점부터 window까지만 올라간다. DOM-Level-3-Event 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html &#123; border:1px solid red; padding:30px; text-align: center; &#125; body &#123; border:1px solid green; padding:30px; &#125; .top &#123; width: 300px; height: 300px; background-color: red; margin: auto; &#125; .middle &#123; width: 200px; height: 200px; background-color: blue; position: relative; top: 34px; left: 50px; &#125; .bottom &#123; width: 100px; height: 100px; background-color: yellow; position: relative; top: 34px; left: 50px; line-height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; body &lt;div class=\"top\"&gt;top &lt;div class=\"middle\"&gt;middle &lt;div class=\"bottom\"&gt;bottom&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // true: capturing / false: bubbling var useCature = true; var handler = function (event) &#123; var phases = ['capturing', 'target', 'bubbling']; var node = this.nodeName + (this.className ? '.' + this.className : ''); // eventPhase: 이벤트 흐름 상에서 어느 phase에 있는지를 반환한다. // 0 : 이벤트 없음 / 1 : 캡처링 단계 / 2 : 타깃 / 3 : 버블링 단계 console.log(node, phases[event.eventPhase - 1]); alert(node + ' : ' + phases[event.eventPhase - 1]); &#125; document.querySelector('html').addEventListener('click', handler, useCature); document.querySelector('body').addEventListener('click', handler, useCature); document.querySelector('div.top').addEventListener('click', handler, useCature); document.querySelector('div.middle').addEventListener('click', handler, useCature); document.querySelector('div.bottom').addEventListener('click', handler, useCature); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; capturing이 html, body, top, middle, bottom순으로 작동하며 bubbling은 반대로 작동한다. 단 capturing은 bottom에서 다시 html로 올라가지만 그것을 보여주지는 않는다. 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;A paragraph with a &lt;button&gt;button&lt;/button&gt;.&lt;/p&gt; &lt;script&gt; var body = document.querySelector('body'); var para = document.querySelector('p'); var button = document.querySelector('button'); // 버블링 body.addEventListener('mousedown', function() &#123; console.log('Handler for body.'); &#125;); // 버블링 para.addEventListener('mousedown', function() &#123; console.log('Handler for paragraph.'); &#125;); // 버블링 button.addEventListener('mousedown', function(event) &#123; console.log('Handler for button.'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3번째 인자를 주지않아서 default값이 false즉 bubbling이 발생한다. button을 눌렀다고 가정한다면 값을 실행하면 Handler for button. -&gt; Handler for paragraph. -&gt; Handler for body. 순으로 이벤트가 발생한다. bubbling이라서 발생한 곳에서 부터 위로 찍힌다. capturing은 위에서부터 이벤트가 발생한 곳 까지내려간다. 아래는 캡처링의 경우이다. 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;A paragraph with a &lt;button&gt;button&lt;/button&gt;.&lt;/p&gt; &lt;script&gt; var body = document.querySelector('body'); var para = document.querySelector('p'); var button = document.querySelector('button'); // 캡처링 body.addEventListener('mousedown', function() &#123; console.log('Handler for body.'); &#125;, true); // 캡처링 para.addEventListener('mousedown', function() &#123; console.log('Handler for paragraph.'); &#125;, true); // 캡처링 button.addEventListener('mousedown', function(event) &#123; console.log('Handler for button.'); &#125;, true); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; capturing이라서 누른곳까지 내려와서 한다. 이벤트가 발생하면 무조건 cpaturing으로 내려왔다가 bubbling으로 올라가는데 어떤 것을 선택할지 사용자들이 선택하는것이다. 다음은 캡처링과 버블링이 혼용되는 경우이다. 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;A paragraph with a &lt;button&gt;button&lt;/button&gt;.&lt;/p&gt; &lt;script&gt; var body = document.querySelector('body'); var para = document.querySelector('p'); var button = document.querySelector('button'); // 버블링 body.addEventListener('mousedown', function() &#123; console.log('Handler for body.'); &#125;); // 캡처링 para.addEventListener('mousedown', function() &#123; console.log('Handler for paragraph.'); &#125;, true); // 버블링 button.addEventListener('mousedown', function(event) &#123; console.log('Handler for button.'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이벤트가 발생한 시점의 function이 false인지 true인지 기준으로 bubling인지 capturing인지 결정된다. 8. Event 객체 이벤트가 발생하면 event 객체는 동적으로 생성되며 이벤트를 처리할 수 있는 이벤트 핸들러에 인자로 전달된다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;클릭하세요. 클릭한 곳의 좌표가 표시됩니다.&lt;/p&gt; &lt;em id=\"message\"&gt;&lt;/em&gt; &lt;script&gt; function showCoords(e) &#123; // e: event object var msg = document.getElementById('message'); msg.innerHTML = 'clientX value: ' + e.clientX + '&lt;br&gt;' + 'clientY value: ' + e.clientY; &#125; addEventListener('click', showCoords); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ‘click’은 첫번째 인자로 들어간다. 8.1 Event Property8.1.1 Event.target 이벤트를 발생시킨 요소를 가리킨다. this는 언제나 currentTarget과 일치한다. currentTarget은 이벤트를 실행할 수도 안할 수도 있다. 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button&gt;Hide me&lt;/button&gt; &lt;script&gt; function hide(e) &#123; e.target.style.visibility = 'hidden'; &#125; document.querySelector('button').addEventListener('click', hide); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8.1.2 Event.currentTarget 이벤트 리스너에 바인딩된 요소를 가리킨다. 이것이 this이다. 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; div &#123; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button&gt;배경색 변경&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function bluify(e) &#123; // this: 이벤트 리스너에 바인딩된 요소(div 요소) console.log('this: ', this); // target: 이벤트를 발생시킨 요소(button 요소 또는 div 요소) console.log('e.target:', e.target); // currentTarget: 이벤트 리스너에 바인딩된 요소(div 요소) console.log('e.currentTarget: ', e.currentTarget); // 언제나 true console.log(this === e.currentTarget); // currentTarget과 target이 같은 객체일 때 true console.log(this === e.target); // click 이벤트가 발생하면 이벤트를 발생시킨 요소(target)과는 상관없이 this(이벤트 리스너에 바인딩된 요소(div 요소))의 배경색이 변경된다. this.style.backgroundColor = '#A5D9F3'; &#125; // div 요소에 이벤트 핸들러가 바인딩되어 있다. // 자식 요소인 button이 발생시킨 이벤트가 버블링되어 div 요소에도 전파된다. // 따라서 div 요소에 이벤트 핸들러가 바인딩되어 있으면 자식 요소인 button이 발생시킨 이벤트를 div 요소에서도 핸들링할 수 있다. document.querySelector('div').addEventListener('click', bluify); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; div를 클릭하였을때 event가 발생하면 target과 this(current.target)은 div로 같다. button를 클릭하였을때 event가 발생하면 target은 button, this는 div이다. 8.1.3 Event.type 발생한 이벤트의 종류를 나타내는 문자열을 반환한다. 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;키를 입력하세요&lt;/p&gt; &lt;em id=\"message\"&gt;&lt;/em&gt; &lt;script&gt; function getEventType(e) &#123; console.log(e); // keycode는 어떤키가 입력되었는지를 받아온다. document.getElementById('message').innerHTML = e.type + ' : ' + e.keyCode; &#125; var body = document.querySelector('body'); body.addEventListener('keydown', getEventType); body.addEventListener('keyup', getEventType); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8.1.4 Event.cancelable 요소의 기본 동작을 취소시킬 수 있는지 여부(true/false)를 나타낸다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"poiemaweb.com\"&gt;Go to poiemaweb.com&lt;/a&gt; &lt;script&gt; var elem = document.querySelector('a'); elem.addEventListener('click', function (e) &#123; console.log(e.cancelable); // 기본 동작을 중단시킨다. e.preventDefault(); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; a 요소의 기본요소인 링크이동을 cancel할 수 있다. 취소할 수 있으면 true아니면 false가 나온다. 8.1.5 Event.eventPhase 이벤트 흐름(event flow) 상에서 어느 단계(event phase)에 있는지를 반환한다. 0 이벤트 없음 1 캡쳐링 단계 2 타깃 3 버블링 단계 캡쳐링 단계에서 event phase를 반환하면 1,2 번이나온다. 버블링 단계에서는 2,3번이 나온다. 8.2 Event Method8.2.1 Event.preventDefault() 이벤트의 기본 동작을 취소한다. 단 Event.cancelable가 true일 경우에 한한다. 8.2.2 Event.stopPropagation() 이벤트의 전파(propagation: 버블링, 캡처링)를 중단한다. 9. Event Delegation (이벤트 위임)12345678&lt;ul id=\"parent-list\"&gt; &lt;li id=\"post-1\"&gt;Item 1&lt;/li&gt; &lt;li id=\"post-2\"&gt;Item 2&lt;/li&gt; &lt;li id=\"post-3\"&gt;Item 3&lt;/li&gt; &lt;li id=\"post-4\"&gt;Item 4&lt;/li&gt; &lt;li id=\"post-5\"&gt;Item 5&lt;/li&gt; &lt;li id=\"post-6\"&gt;Item 6&lt;/li&gt;&lt;/ul&gt; 모든 li 요소가 클릭 이벤트에 반응하는 처리를 구현하고 싶은 경우 너무 많은 소요가 발생한다. 이벤트 위임(Event Delegation)은 다수의 자식 요소에 이벤트 핸들러를 바인딩하는 대신 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법이다. 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;ul id=\"parent-list\"&gt; &lt;li id=\"post-1\"&gt;Item 1&lt;/li&gt; &lt;li id=\"post-2\"&gt;Item 2&lt;/li&gt; &lt;li id=\"post-3\"&gt;Item 3&lt;/li&gt; &lt;li id=\"post-4\"&gt;Item 4&lt;/li&gt; &lt;li id=\"post-5\"&gt;Item 5&lt;/li&gt; &lt;li id=\"post-6\"&gt;Item 6&lt;/li&gt; &lt;/ul&gt; &lt;div id=\"msg\"&gt; &lt;script&gt; var msg = document.getElementById('msg'); document.getElementById('parent-list').addEventListener('click', function (e) &#123; console.log('[target]: ' + e.target); // nodeName 프로퍼티를 사용하여서 태그명을 찾아올수있다. console.log('[target.nodeName]: ' + e.target.nodeName); // list item이면 // e.target이 null이면 안되서 먼저 써준다. if (e.target &amp;&amp; e.target.nodeName == 'LI') &#123; msg.innerHTML = 'li#' + e.target.id + ' was clicked!'; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 10. 기본 동작의 변경 이벤트 객체는 요소의 기본 동작과 요소의 부모 요소들이 이벤트에 대응하는 방법을 변경하기 위한 메소드는 가지고 있다. 10.1 Event.preventDefault() 폼을 submit하거나 링크를 클릭하면 다른 페이지로 이동하게 된다. 이러한 요소가 가지고 있는 기본 동작을 중단시키기 위한 메소드가 preventDefault()이다. Ajax 통신을 하게될경우 submit의 기본동작을 중단시켜야한다 안할시 2번요청이간다. 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"http://www.google.com\"&gt;go&lt;/a&gt; &lt;script&gt; document.querySelector('a').addEventListener('click', function(e) &#123; console.log(e.target, e.target.nodeName); // a 요소의 기본 동작을 중단한다. e.preventDefault(); // 이밑에 ajax의 코드를 입력한다. &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 10.2 Event.stopPropagation() 부모 요소와 자식 요소의 이벤트를 각각 별도로 처리하기 위해 button 요소의 이벤트의 전파(버블링)를 중단시키기 위해서는 stopPropagation 메소드를 사용하여 이벤트 전파를 중단할 필요가 있다. 버블링을 중단하고 각자의 경우를 한번씩만 사용하고 싶을때 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body &#123; height: 100%;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;A paragraph with a &lt;button&gt;button&lt;/button&gt;.&lt;/p&gt; &lt;script&gt; var body = document.querySelector('body'); var para = document.querySelector('p'); var button = document.querySelector('button'); // 버블링 body.addEventListener('mousedown', function () &#123; console.log('Handler for body.'); &#125;); // 버블링 para.addEventListener('mousedown', function () &#123; console.log('Handler for paragraph.'); &#125;); // 버블링 button.addEventListener('mousedown', function (event) &#123; console.log('Handler for button.'); // 3번은 오른쪽을 뜻한다. mouse 오른쪽 버튼 클릭 시, 이벤트 전파를 중단한다. if (event.which === 3) event.stopPropagation(); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 10.3 preventDefault &amp; stopPropagation 기본 동작의 중단과 버블링 또는 캡처링의 중단을 동시에 실시하는 방법은 아래와 같다. 1return false; 단 이 방법은 jQuery를 사용할 때와 아래와 같이 사용할 때만 적용된다. 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; // onclick에 return을 써줘야한다. &lt;a href=\"http://www.google.com\" onclick='return handleEvent()'&gt;go&lt;/a&gt; &lt;script&gt; function handleEvent() &#123; return false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jquery에서의 사용법이다. 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"http://www.google.com\"&gt;go&lt;/a&gt; &lt;/div&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // within jQuery $('a').click(function (e) &#123; e.preventDefault(); // OK a link를 클릭해도 이동하지 않게된다. &#125;); $('a').click(function () &#123; return false; // OK --&gt; e.preventDefault() &amp; e.stopPropagation(). &#125;); // pure js document.querySelector('a').addEventListener('click', function(e) &#123; // e.preventDefault(); // OK return false; // NG!!!!! &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js에서 사용하고 싶다면 e.preventDefault(), e.stopPropagation()를 써야한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Event","slug":"JavaScript/Event","permalink":"http://yoursite.com/categories/JavaScript/Event/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Event","slug":"Event","permalink":"http://yoursite.com/tags/Event/"}]},{"title":"JavaScript RestAPI","slug":"js-study-restapi","date":"2017-08-14T03:54:00.000Z","updated":"2017-11-14T00:27:19.000Z","comments":true,"path":"2017/08/14/js-study-restapi/","link":"","permalink":"http://yoursite.com/2017/08/14/js-study-restapi/","excerpt":"","text":"JavaScript RestAPI REST의 기본 원칙을 성실히 지킨 서비스 디자인을 “RESTful”이라고 표현한다. 1. REST API 중심 규칙URI는 자원을 표현하는 데에 집중하고 행위에 대한 정의는 HTTP Method를 통해 하는 것이 REST한 API를 설계하는 중심 규칙이다. URI는 정보의 자원을 표현해야 한다.리소스명은 동사보다는 명사를 사용한다. URI는 자원을 표현하는데 중점을 두어야 한다. 12# goodGET /books/1 URI = 통합 자원 식별자(Uniform Resource Identifier, URI)는 인터넷에 있는 자원을 나타내는 유일한 주소이다. 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)으로 표현한다. 12# goodDELETE /books/1 2. HTTP Method Method Action 역할 GET index/retrieve 모든/특정 리소스를 조회 POST create 리소스를 생성 PUT update 리소스를 갱신 DELETE delete 리소스를 삭제 3. REST API의 구성REST API는 자원(Resource), 행위(Verb), 표현(Representations)의 3가지 요소로 구성된다. 구성 요소 내용 표현 방법 Resource HTTP URI Verb 자원에 대한 행위 HTTP Method Representations 자원에 대한 행위의 내용 HTTP Message Pay Load 4. Rest API의 Example4.1 PUTbooks 리소스에서 특정 책을 조회(retrieve)한다. 123var req = new XMLHttpRequest()req.open('GET', '/books/1')req.send() 4.2 POSTbooks 리소스에 책을 생성한다. 1234567var req = new XMLHttpRequest()req.open('POST', '/books')req.setRequestHeader('Content-type', 'application/json')req.send(JSON.stringify(&#123; title: \"ES6\", author: \"kim\"&#125;)) 4.3 PUTbooks 리소스의 책의 타이틀을 “ES6”에서 “ECMAScript6”로 갱신한다. 1234567var req = new XMLHttpRequest()req.open('PUT', 'books/1')req.setRequestHeader('Content-type', 'application/json')req.send(JSON.stringify(&#123; title:'ecamscript6', author:'kim'&#125;)) 4.4 DELETEbooks 리소스에서 책을 삭제한다. 123var req = new XMLHttpRequest()req.open('DELETE', 'books/1')req.send()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"RestAPI","slug":"JavaScript/RestAPI","permalink":"http://yoursite.com/categories/JavaScript/RestAPI/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"RestAPI","slug":"RestAPI","permalink":"http://yoursite.com/tags/RestAPI/"}]},{"title":"JavaScript Dom","slug":"js-study-dom","date":"2017-08-14T03:54:00.000Z","updated":"2017-11-14T00:24:31.000Z","comments":true,"path":"2017/08/14/js-study-dom/","link":"","permalink":"http://yoursite.com/2017/08/14/js-study-dom/","excerpt":"","text":"JavaScript Dom(Document Object Model)1. DOM(Document Object Model) 브라우저는 웹 문서(HTML, XML, SVG)를 로드하고 파싱하여 DOM(문서 객체 모델)을 생성한다. 브라우저 동작 원리 DOM이란? 브라우저의 렌더링 엔진은 웹 문서를 로드하고 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는 것을 나타낸다. 모든 요소와 요소의 어트리뷰트, 텍스트를 각각의 객체로 만들고 이들 객체를 부자 관계를 표현할 수 있는 트리 구조로 구성한 것이 DOM이다 DOM은 자바스크립트를 통해 동적으로 변경할 수 있으며 변경된 DOM은 렌더링에 반영된다. DOM API(Application Programming Interface)이란? 웹 문서의 동적 변경을 위해 DOM은 프로그래밍 언어가 자신에 접근하고 수정할 수 있는 방법을 제공하는데 일반적으로 프로퍼티와 메소드를 갖는 JavaScript 객체로 제공된다. 정적인 웹페이지에 접근하여 동적으로 웹페이지를 변경하기 위한 유일한 방법은 메모리 상에 존재하는 DOM을 변경하는 것이고, 이때 필요한 것이 DOM에 접근하고 변경하는 프로퍼티와 메소드의 집합인 DOM API이다. DOM의 2가지 기능 HTML 문서에 대한 모델 구성 : 브라우저는 HTML 문서를 로드한 후 해당 문서에 대한 모델을 메모리에 생성한다. 이때 모델은 객체의 트리로 구성되는데 이것을 DOM tree라 한다. HTML 문서 내의 각 요소에 접근 / 수정 : DOM은 모델 내의 각 객체에 접근하고 수정할 수 있는 프로퍼티와 메소드를 제공한다. DOM이 수정되면 브라우저를 통해 사용자가 보게 될 내용 또한 변경된다. 2. DOM tree DOM tree는 브라우저가 HTML 문서를 로드한 후 생성하는 모델을 의미하는데 객체의 트리로 구조화되어 있기 때문에 DOM tree라 부른다. 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .red &#123; color: #ff0000; &#125; .blue &#123; color: #0000ff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h1&gt;Cities&lt;/h1&gt; &lt;ul&gt; &lt;li id=\"one\" class=\"red\"&gt;Seoul&lt;/li&gt; &lt;li id=\"two\" class=\"red\"&gt;London&lt;/li&gt; &lt;li id=\"three\" class=\"red\"&gt;Newyork&lt;/li&gt; &lt;li id=\"four\"&gt;Tokyo&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; DOM tree DOM에서 모든 요소, 어트리뷰트, 텍스트는 하나의 객체이며 Document 객체의 자식이다. DOM tree의 4가지 노드 문서 노드(Document Node) : 트리의 최상위에 존재하며 각각 요소, 어트리뷰트, 텍스트 노드에 접근하려면 문서 노드를 통해야 한다. 즉 DOM tree에 접근하기 위한 시작점(entry point)이다. 요소 노드(Element Node) : 요소 노드는 HTML 요소를 표현한다. HTML 요소는 중첩에 의해 부자 관계를 가지며 이 부자 관계를 통해 정보를 구조화한다. 따라서 요소 노드는 문서의 구조를 서술한다고 말 할 수 있다. 어트리뷰트, 텍스트 노드에 접근하려면 먼저 요소 노드를 찾아 접근해야 한다. 모든 요소 노드는 요소별 특성을 표현하기 위해 HTMLElement 객체를 상속한 객체로 구성된다. (그림: DOM tree의 세부 구성 참고) 어트리뷰트 노드(Attribute Node) : 어트리뷰트 노드는 HTML 요소의 어트리뷰트를 표현한다. 어트리뷰트 노드는 해당 어트리뷰트가 지정된 요소의 자식이 아니라 해당 요소의 일부로 표현된다. 따라서 해당 요소 노드를 찾아 접근하면 어트리뷰트를 참조, 수정할 수 있다. 텍스트 노드(Text Node) : 텍스트 노드는 HTML 요소의 텍스트를 표현한다. 텍스트 노드는 요소 노드의 자식이며 자신의 자식 노드를 가질 수 없다. 즉 텍스트 노드는 DOM tree의 최종단이다. 모든 요소는 attribute, text가 올 수 도있고 안올 수 도있다. DOM tree에서 요소노드와 어트리뷰트노드는 형제이며 텍스트노드는 자식이다. DOM tree의 객체 구성 DOM을 통해 웹페이지를 조작(manipulate)하기 위해서는 다음과 같은 수순이 필요하다. 조작하고자하는 요소를 선택 또는 탐색한다. 선택된 요소의 콘텐츠 또는 어트리뷰트를 조작한다. JavaScript는 이것에 필요한 수단(API)을 제공한다. 3. DOM Query / Traversing(요소에의 접근)3.1 하나의 요소 노드 선택(DOM Query) document.getElementById(id) 요소의 id 어트리뷰트 값으로 해당 요소를 선택한다. 복수개가 선택된 경우, 첫번째 요소만 반환한다. Return: HTMLElement를 상속받은 객체 모든 브라우저에서 동작 12345678910// id로 하나의 요소를 선택한다.var elem = document.getElementById('one');// 클래스 어트리뷰트의 값을 변경한다.elem.className = 'blue';// 그림: DOM tree의 세부 구성 참고console.log(elem.__proto__); // HTMLLIElementconsole.log(elem.__proto__.__proto__); // HTMLElementconsole.log(elem.__proto__.__proto__.__proto__); // Elementconsole.log(elem.__proto__.__proto__.__proto__.__proto__); // Node onfocus focus가 들어가면 지정한 함수를 한다. document.querySelector(cssSelector) CSS 셀렉터를 이용해 요소를 선택한다. 복수개가 선택된 경우, 첫번째 요소만 반환한다. Return: HTMLElement를 상속받은 객체 IE8 이상의 브라우저에서 동작 1234// CSS 셀렉터를 이용해 요소를 선택한다var elem = document.querySelector('li.red');// 클래스 어트리뷰트의 값을 변경한다.elem.className = 'blue'; 3.2 여러개의 요소 노드 선택(DOM Query) document.getElementsByClassName(class) 지정된 class를 가지는 요소를 모두 선택한다. 공백으로 구분하여 여러개의 class를 지정할 수 있다. Return: HTMLCollection (live) IE9 이상의 브라우저에서 동작 1234567// HTMLCollection을 반환한다.var elems = document.getElementsByClassName('red'), i;for (i = 0; i &lt; elems.length; i++) &#123; // 클래스 어트리뷰트의 값을 변경한다. elems[i].className = 'blue';&#125; 위 예제를 실행해 보면 예상대로 동작하지 않는다. (두번째 요소만 클래스 변경이 되지 않는다.) getElementsByClassName 메소드의 반환값은 HTMLCollection이다. 이것은 반환값이 복수인 경우, HTMLElement의 리스트를 담아 반환하기 위한 객체로 배열과 비슷한 사용법을 가지고 있지만 배열은 아닌 유사배열(array-like object)이다. HTMLCollection은 실시간으로 Node의 상태 변경을 반영한다. (live HTMLCollection) 위 예제가 예상대로 동작하지 않은 이유를 알아보자. 1.i가 0일때, elems의 첫 요소(li#one.red)의 class 어트리뷰트 값이 className 프로퍼티에 의해 red에서 blue로 변경된다. 이때 첫째 요소는 class명이 변경됨으로 제외된다.(실시간으로 Node의 상태 변경을 반영한다.) 2.i가 1일때, elems에서 첫째 요소는 제거되었으므로 elems[1]은 3번째 요소(li#three.red)가 된다. li#three.red의 class 어트리뷰트 값이 blue로 변경되고 마찬가지로 HTMLCollection에서 제외된다. 3.i가 2일때, HTMLCOllection의 1,3번째 요소가 실시간으로 제거되었으므로 2번째 요소(li#two.red)만 남았다. elems[2]는 undefined이다. 해결책1. 반복문을 역방향으로 돌린다. 1234var elems = document.getElementsByClassName('red'), i;for (i = elems.length - 1; i &gt;= 0; i--) &#123; elems[i].className = 'blue';&#125; 해결책2. while 반복문을 사용한다. 이때 elems에 요소가 남아 있지 않을 때까지 무한반복하기 위해 index는 0으로 고정시킨다. 123456var elems = document.getElementsByClassName('red');var i = 0;while (elems.length &gt; i) &#123; // elems에 요소가 남아 있지 않을 때까지 무한반복 elems[i].className = 'blue'; // i++;&#125; 해결책3. HTMLCollection을 배열로 변경한다. 123456789101112var elems = document.getElementsByClassName('red'), i;// 유사배열을 배열로 변환var arr = [].slice.call(elems);console.log(arr); // [li#one.red, li#two.red, li#three.red]// 각 요소는 HTMLLIElementfor (i = 0; arr.length &gt; 0; i++) &#123; arr[i].className = 'blue';&#125; 해결책4. querySelectorAll 메소드를 사용하여 non-live NodeList를 반환하게 한다. 12345// Nodelist(non-live)를 반환한다. IE8+var elems = document.querySelectorAll('.red'), i;for (i = 0; i &lt; elems.length; i++) &#123; elems[i].className = 'blue';&#125; 해결책5. document.getElementsByTagName(tagName) 지정된 태그명을 가지는 요소를 모두 선택한다. Return: HTMLCollection (live) 모든 브라우저에서 동작 12345// HTMLCollection을 반환한다.var elems = document.getElementsByTagName('li'), i;for (i = 0; i &lt; elems.length; i++) &#123; elems[i].className = 'blue';&#125; Q. getElementByTagName도 live이면 유사배열 아닌가요?? 에러가나야하지 않나요?A. Tag가 변경될일이 없기때문에 에러가나지 않는다. document.querySelectorAll(selector) 지정된 CSS 선택자와 일치하는 요소를 모두 선택한다. Return: NodeList (non-live) IE8 이상의 브라우저에서 동작 12345// Nodelist를 반환한다.var elems = document.querySelectorAll('li.red'), i;for (i = 0; i &lt; elems.length; i++) &#123; elems[i].className = 'blue'; // color는 상속이되니 li도 blue를 가진다.&#125; 3.3 DOM Traversing(탐색) parentNode 부모 요소를 탐색한다. Return: HTMLElement를 상속받은 객체 모든 브라우저에서 동작 123var elem = document.getElementById('two');var parentNode = elem.parentNode;parentNode.className = 'blue'; firstChild, lastChild 자식 요소를 탐색한다. Return: HTMLElement를 상속받은 객체 IE9 이상의 브라우저에서 동작 권장하지 않는다. 공백이나 줄바꿈 문자를 텍스트 노드로 취급하기 때문이다. 123456var elem = document.getElementsByTagName('ul')[0];// first Childelem.firstChild.className = 'blue';// last Childelem.lastChild.className = 'blue'; 위 예제를 실행해 보면 예상대로 동작하지 않는다. 그 이유는 IE를 제외한 대부분의 브라우저들은 요소 사이의 공백 또는 줄바꿈 문자를 텍스트 노드로 취급하기 때문이다. 이것을 회피하기 위해서는 HTML에 공백을 제거하거나 jQuery: .prev()와 jQuery: .next()를 사용한다. 12345&lt;ul&gt;&lt;li id='one' class='red'&gt;Seoul&lt;/li&gt;&lt;li id='two' class='red'&gt;London&lt;/li&gt;&lt;li id='three' class='red'&gt;Newyork&lt;/li&gt;&lt;li id='four'&gt;Tokyo&lt;/li&gt;&lt;/ul&gt; hasChildNodes() 자식 노드가 있는지 확인하고 Boolean 값을 반환한다. Return: Boolean 값 모든 브라우저에서 동작 childNodes 자식 노드의 컬렉션을 반환한다. Return: NodeList (non-live) 모든 브라우저에서 동작 12345678var elem = document.querySelector('ul');console.log(elem); // ulif (elem.hasChildNodes()) &#123; console.log(elem.childNodes); // [text, li#one.red, text, li#two.red, text, li#three.red, text, li#four, text] text는 공백을 나타낸다. elem.childNodes[1].className = 'blue';&#125; previousSibling, nextSibling 형제 요소를 탐색한다. Return: HTMLElement를 상속받은 객체 IE9 이상의 브라우저에서 동작 12345678910var elem = document.getElementsByTagName('ul')[0];// first Childelem.firstChild.className = 'blue';// 2nd Childelem.firstChild.nextSibling.className = 'blue';// 3rd Childelem.lastChild.previousSibling.className = 'blue';// last Childelem.lastChild.className = 'blue'; 4. DOM Manipulation (조작)4.1 텍스트 노드에의 접근/수정 요소의 텍스트는 텍스트 노드에 저장되어 있다. 텍스트 노드에 접근하려면 아래와 같은 수순이 필요하다. 1.해당 텍스트 노드의 부모 요소 노드를 선택한다. 텍스트 노드는 요소 노드의 자식이다. 2.firstChild 프로퍼티를 사용하여 텍스트 노드를 탐색한다. 3.텍스트 노드의 유일한 프로퍼티(nodeValue)를 이용하여 텍스트를 취득한다. 4.nodeValue를 이용하여 텍스트를 수정한다. nodeValue 노드의 값을 반환한다. Return: 문자열 IE6 이상의 브라우저에서 동작한다. 123456789101112// 해당 텍스트 노드의 부모 요소 노드를 선택한다.var one = document.getElementById('one');console.dir(one); // HTMLLIElement: li#one.red// firstChild 프로퍼티를 사용하여 텍스트 노드를 탐색한다.var textNode = one.firstChild;// nodeValue 프로퍼티를 사용하여 노드의 값을 취득한다.console.log(textNode.nodeValue); // Seoul// nodeValue 프로퍼티를 이용하여 텍스트를 수정한다.textNode.nodeValue = 'Pusan'; nodeName, nodeType을 통해 노드의 정보를 취득할 수 있다. 4.2 어트리뷰트 노드에의 접근/수정 className class 어트리뷰트의 값을 취득 또는 변경한다. class 어트리뷰트가 존재하지 않으면 class 어트리뷰트를 생성하고 지정된 값을 설정한다. class 어트리뷰트의 값이 여러개일 경우, 공백으로 구분된 문자열이 반환되므로 String 메소드 split(&#39; &#39;)를 사용하여 배열로 변경하여 사용한다. 모든 브라우저에서 동작한다. 123456789101112var elems = document.getElementsByTagName('li');for (var i = elems.length - 1; i &gt;= 0; i--) &#123; // class 어트리뷰트의 값을 취득하여 확인 if (elems[i].className === 'red') &#123; // class 어트리뷰트의 값을 변경한다. elems[i].className = 'blue'; &#125; else &#123; // class 어트리뷰트의 값을 변경한다. elems[i].className = 'red'; &#125;&#125; id id 어트리뷰트의 값을 취득 또는 변경한다. id 어트리뷰트가 존재하지 않으면 id 어트리뷰트를 생성하고 지정된 값을 설정한다. 모든 브라우저에서 동작한다. 12345678// h1 태그 요소 중 첫번째 요소를 취득var heading = document.getElementsByTagName('h1')[0];console.dir(heading); // HTMLHeadingElement: h1console.log(heading.firstChild.nodeValue); // Cities// id 어트리뷰트의 값을 변경heading.id = 'heading';console.log(heading.id); // heading hasAttribute() 지정한 어트리뷰트를 가지고 있는지 검사한다. Return : Boolean IE8 이상의 브라우저에서 동작한다. getAttribute() 어트리뷰트의 값을 취득한다. Return : 문자열 모든 브라우저에서 동작한다. setAttribute() 어트리뷰트와 어트리뷰트의 값을 설정한다. Return : undefined 모든 브라우저에서 동작한다. removeAttribute() 지정한 어트리뷰트를 제거한다. Return : undefined 모든 브라우저에서 동작한다. 123456789101112131415161718var four = document.getElementById('four');// four에 class 어트리뷰트가 존재하지 않으면if (!four.hasAttribute('class')) &#123; // four에 name 어트리뷰트를 추가하고 값으로 'user'를 설정 four.setAttribute('class', 'blue');&#125; else &#123; // four에 class 어트리뷰트가 존재하면 four.className = 'blue';&#125;// four에 lang 어트리뷰트의 값을 취득console.log(four.getAttribute('class')); // blue// four에서 name 어트리뷰트를 제거four.removeAttribute('class');// inputUser에서 name 어트리뷰트의 존재를 확인console.log(four.hasAttribute('class')); // false 4.3 HTML 콘텐츠 조작(Manipulation) HTML 콘텐츠를 조작(Manipulation)하기 위해 아래의 프로퍼티 또는 메소드를 사용할 수 있다. 마크업이 포함된 콘텐츠를 추가하는 행위는 크로스 스크립팅 공격(XSS: Cross-Site Scripting Attacks)에 취약하므로 주의가 필요하다. content가 문자열로 이루어져있을때만 사용한다. textContent 요소의 텍스트 콘텐츠를 취득 또는 변경한다. 이때 마크업은 무시된다. textContent를 통해 요소에 새로운 텍스트를 할당하면 텍스트를 변경할 수 있다. 이때 순수한 텍스트만 지정해야 하며 마크업을 포함시키면 문자열로 인식되어 그대로 출력된다. IE9 이상의 브라우저에서 동작한다. 123456789101112131415161718192021222324252627var ul = document.getElementsByTagName('ul')[0];// 요소의 텍스트 취득console.log(ul.textContent);// IE를 제외한 대부분의 브라우저들은 요소 사이의 공백 또는 줄바꿈 문자를 텍스트 노드로 취급한다/* Seoul London Newyork Tokyo*/var one = document.getElementById('one');// 요소의 텍스트 취득console.log(one.textContent); // Seoul// 요소의 텍스트 변경one.textContent += ', Korea';console.log(one.textContent); // Seoul, Korea// 요소의 마크업이 포함된 콘텐츠 변경.one.textContent = '&lt;h1&gt;Heading&lt;/h1&gt;';// 마크업이 문자열로 표시된다.console.log(one.textContent); // &lt;h1&gt;Heading&lt;/h1&gt; innerText innerText 프로퍼티를 사용하여도 요소의 텍스트 콘텐츠에만 접근할 수 있다. 하지만 아래의 이유로 사용하지 않는 것이 좋다. 비표준이다. CSS에 순종적이다. 예를 들어 CSS에 의해 비표시(visibility: hidden;)로 지정되어 있다면 텍스트가 반환되지 않는다. CSS를 고려해야 하므로 textContent 프로퍼티보다 느리다 innerHTML innerHTML 프로퍼티를 사용하면 해당 요소의 모든 자식 요소를 포함하는 모든 콘텐츠를 하나의 문자열로 취득할 수 있다. 이 문자열은 마크업을 포함한다. 1234567891011var ul = document.getElementsByTagName('ul')[0];// innerHTML 프로퍼티는 모든 자식 요소를 포함하는 모든 콘텐츠를 하나의 문자열로 취득할 수 있다. 이 문자열은 마크업을 포함한다.console.log(ul.innerHTML);// IE를 제외한 대부분의 브라우저들은 요소 사이의 공백 또는 줄바꿈 문자를 텍스트 노드로 취급한다/* &lt;li id=\"one\" class=\"red\"&gt;Seoul&lt;/li&gt; &lt;li id=\"two\" class=\"red\"&gt;London&lt;/li&gt; &lt;li id=\"three\" class=\"red\"&gt;Newyork&lt;/li&gt; &lt;li id=\"four\"&gt;Tokyo&lt;/li&gt;*/ innerHTML 프로퍼티를 사용하여 마크업이 포함된 새로운 콘텐츠를 지정하면 새로운 요소를 DOM에 추가할 수 있다. 12345678910var one = document.getElementById('one');// 마크업이 포함된 콘텐츠 취득console.log(one.innerHTML); // Seoul// 마크업이 포함된 콘텐츠 변경one.innerHTML += '&lt;em class=\"blue\"&gt;, Korea&lt;/em&gt;';// 마크업이 포함된 콘텐츠 취득console.log(one.innerHTML); // Seoul &lt;em class=\"blue\"&gt;, Korea&lt;/em&gt; 위와 같이 마크업이 포함된 콘텐츠를 추가하는 것은 크로스 스크립팅 공격(XSS: Cross-Site Scripting Attacks)에 취약하다. 123456789// 크로스 스크립팅 공격 사례// 스크립트 태그를 추가하여 자바스크립트가 실행되도록 한다.// HTML5에서 innserHTML로 삽입된 &lt;script&gt; 코드는 실행되지 않는다.// 크롬, 파이어폭스 등의 브라우저나 최신 브라우저 환경에서는 작동하지 않을 수도 있다.elem.innerHTML = '&lt;script&gt;alert(\"XSS!\")&lt;/script&gt;';// 에러 이벤트를 발생시켜 스크립트가 실행되도록 한다.one.innerHTML = '&lt;img src=\"#\" onerror=\"alert('XSS')\"&gt;'; 4.4 DOM 조작 방식 innerHTML 프로퍼티를 사용하지 않고 새로운 콘텐츠를 추가할 수 있는 방법은 DOM을 직접 조작하는 것이다. 한개의 요소를 추가하는 경우 사용한다. 이 방법은 다음의 수순에 따라 진행한다. 1.요소 노드 생성createElement() 메소드를 사용하여 새로운 요소 노드를 생성한다. createElement() 메소드의 인자으로 태그 이름을 전달한다. 2.텍스트 노드 생성createTextNode() 메소드를 사용하여 새로운 텍스트 노드를 생성한다. 경우에 따라 생략될 수 있지만 생략하는 경우, 콘텐츠가 비어 있는 요소가 된다. 3.생성된 요소를 DOM에 추가appendChild() 메소드를 사용하여 생성된 노드를 DOM tree에 추가한다. 또는 removeChild() 네서드를 사용하여 DOM tree에서 노드를 삭제할 수도 있다. createElement(tagName) 태그이름을 인자로 전달하여 요소를 생성한다. Return: HTMLElement를 상속받은 객체 모든 브라우저에서 동작한다. createTextNode(text) 텍스트를 인자로 전달하여 텍스트 노드를 생성한다. Return: Text 객체 모든 브라우저에서 동작한다. appendChild(Node) 인자로 전달한 노드를 자식 요소로 DOM 트리에 추가한다. Return: 추가한 노드 모든 브라우저에서 동작한다. removeChild(Node) 인자로 전달한 노드를 DOM 트리에 제거한다. Return: 추가한 노드 모든 브라우저에서 동작한다. 1234567891011121314151617181920// 태그이름을 인자로 전달하여 요소를 생성var newElem = document.createElement('li');// var newElem = document.createElement('&lt;li&gt;test&lt;/li&gt;');// Uncaught DOMException: Failed to execute 'createElement' on 'Document': The tag name provided ('&lt;li&gt;test&lt;/li&gt;') is not a valid name.// 텍스트 노드를 생성var newText = document.createTextNode('Beijing');// 텍스트 노드를 newElem 자식으로 DOM 트리에 추가newElem.appendChild(newText);var container = document.getElementsByTagName('ul')[0];// newElem을 container의 자식으로 DOM 트리에 추가container.appendChild(newElem);var removeElem = document.getElementById('one');// container의 자식인 removeElem 요소를 DOM 트리에 제거한다.container.removeChild(removeElem); 4.5 insertAdjacentHTML() insertAdjacentHTML() 인자로 전달한 텍스트를 HTML로 파싱하고 그 결과로 생성된 노드를 DOM 트리의 지정된 위치에 삽입한다. 첫번째 인자는 삽입 위치, 두번째 인자는 삽입할 요소를 표현한 문자열이다. 첫번째 인자로 올 수 있는 값은 아래와 같다. ‘beforebegin’ ‘afterbegin’ ‘beforeend’ ‘afterend’ 모든 브라우저에서 동작한다. 1234var one = document.getElementById('one');// 마크업이 포함된 요소 추가one.insertAdjacentHTML('beforeend', '&lt;em class=\"blue\"&gt;, Korea&lt;/em&gt;'); 4.6 innerHTML vs. DOM 조작 방식 vs. insertAdjacentHTML() innerHTML 장점 DOM 조작 방식에 비해 빠르고 간편하다. 간편하게 문자열로 정의 여러 요소를 DOM에 추가할 수 있다. 해당 요소의 내용을 덮어 쓴다. 즉 HTML을 로드하고 다시 파싱한다. 이것은 비효율적이다. 콘텐츠를 취득할 수 있다. 단점 XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은 콘텐츠(untrusted data: 댓글, 사용자 이름등)를 추가할 때 사용해서는 않된다. DOM 조작 방식 장점 특정 노드 한개(노드, 텍스트, 데이터 등)를 DOM에 추가할 때 적합하다. 단점 innerHTML보다 느리고 더 많은 코드가 필요하다. insertAdjacentHTML() 장점 간편하게 문자열로 정의된 여러 요소를 DOM에 추가할 수 있다. 삽입되는 위치를 선정할 수 있다. 단점 XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은 콘텐츠(untrusted data: 댓글, 사용자 이름등)를 추가할 때 사용해서는 않된다. 결론 innerHTML과 insertAdjacentHTML()은 크로스 스크립팅 공격(XSS: Cross-Site Scripting Attacks)에 취약하다. 따라서 untrusted data의 경우, 주의하여야 한다. 텍스트를 추가 또는 변경시에는 textContent, 새로운 요소의 추가 또는 삭제시에는 DOM 조작 방식을 사용하도록 한다. 5. style style 프로퍼티를 사용하면 inline 스타일 선언을 생성한다. 특정 요소에 inline 스타일을 지정하는 경우 사용한다. 1234567var four = document.getElementById('four');// inline 스타일 선언을 생성four.style.color = 'blue';// font-size와 같이 '-'으로 구분되는 프로퍼티는 카멜케이스로 변환하여 사용한다.four.style.fontSize = '2em';","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Dom","slug":"JavaScript/Dom","permalink":"http://yoursite.com/categories/JavaScript/Dom/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Dom","slug":"Dom","permalink":"http://yoursite.com/tags/Dom/"}]},{"title":"JavaScript String","slug":"js-study-string","date":"2017-08-09T03:54:00.000Z","updated":"2017-11-14T00:21:40.000Z","comments":true,"path":"2017/08/09/js-study-string/","link":"","permalink":"http://yoursite.com/2017/08/09/js-study-string/","excerpt":"","text":"JavaScript String 1. String Constructor String 객체는 String() 생성자 함수를 통해 생성할 수 있다. 이때 전달된 인자는 모두 문자열로 변환된다. new를 넣지 않는다면 그냥 문자로만 변환한다. 12345678var x = 'Lee';var y = new String('Lee');console.log(x == y); // trueconsole.log(x === y); // falseconsole.log(typeof x); // stringconsole.log(typeof y); // object 2. String Property2.1 String.length 문자열 내의 문자 갯수를 반환한다. 12345var str = 'Hello';console.log(str.length); // 5str = '안녕하세요';console.log(str.length); // 5 3. String Method3.1 String.prototype.charAt() 매개변수로 전달한 index 번호에 해당하는 위치의 문자를 반환한다. index 번호는 0 ~ (문자열 길이 - 1) 사이의 정수이다. 123456789101112131415str.charAt(index)var str = 'Hello';console.log(str.charAt(0)); // Hconsole.log(str.charAt(1)); // econsole.log(str.charAt(2)); // lconsole.log(str.charAt(3)); // lconsole.log(str.charAt(4)); // o// 지정한 index가 범위(0 ~ str.length-1)를 벗어난 경우 빈문자열을 반환한다.console.log(str.charAt(5)); // ''for (var i = 0; i &lt; str.length; i++) &#123; console.log(str.charAt(i));&#125; 3.2 String.prototype.indexOf() 문자열 내에 매개변수로 전달된 문자 또는 문자열이 처음 발견된 곳의 index를 반환한다. 발견하지 못한 경우 -1을 반환한다. 123456789str.indexOf(searchValue[, fromIndex])// searchValue: 검색할 문자 또는 문자열// fromIndex : 검색 시작 index (생략할 경우, 0)var str = 'Hello World';console.log(str.indexOf('l')); // 2console.log(str.indexOf('or')); // 7console.log(str.indexOf('or' , 8)); // -1 3.3 String.prototype.lastIndexOf() 문자열 내에 매개변수로 전달된 문자 또는 문자열이 마지막으로 발견된 곳의 index를 반환한다. 발견하지 못한 경우 -1을 반환한다. 2번째 인수(fromIndex)가 전달되면 검색 시작 위치를 fromIndex으로 이동하여 역방향으로 검색을 시작한다. 이때 검색 범위는 0 ~ fromIndex이다. 1234567891011var str = 'Hello World';console.log(str.lastIndexOf('World')); // 6console.log(str.lastIndexOf('l')); // 9console.log(str.lastIndexOf('o', 5)); // 4console.log(str.lastIndexOf('o', 8)); // 7console.log(str.lastIndexOf('l', 10)); // 9console.log(str.lastIndexOf('H', 0)); // 0console.log(str.lastIndexOf('W', 5)); // -1console.log(str.lastIndexOf('x', 8)); // -1 3.4 String.prototype.replace() 첫번째 인수로 전달된 문자열 또는 정규표현식을 대상 문자열에서 검색하여 두번째 인수로 전달된 문자열로 대체한다. 검색된 문자열이 복수 존재할 경우 첫번째로 검색된 문자열만 대체된다. 기본자료형이라서 원본은 변경되지 않는다. 123456789var str = 'Hello Hello';var replacedStr = str.replace('Hello', 'Lee');console.log(replacedStr); // Lee Helloconsole.log(str); // Hello HelloreplacedStr = str.replace(/hello/gi, 'Lee'); // 정규표현식console.log(replacedStr); // Lee Leeconsole.log(str); // Hello Hello /hello/의 패턴을 검색하는데 (g반복해서 계속) (i 대소문자를 구분하지 말라)해서 찾는다. 3.5 String.prototype.split() 첫번째 인수로 전달된 문자열 또는 정규표현식을 대상 문자열에서 검색하여 문자열을 구분한 후 분리된 각 문자열로 이루어진 배열을 반환한다. 인수가 없는 경우, 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다. 1234567891011121314151617181920str.split([separator[, limit]])// separator: 구분 대상 문자열 또는 정규표현식// limit: 구분 대상수의 한계를 나타내는 정수var str = 'How are you doing?';var splitStr = str.split(' ');console.log(splitStr); // [ 'How', 'are', 'you', 'doing?' ]splitStr = str.split();console.log(splitStr); // [ 'How are you doing?' ]splitStr = str.split('');console.log(splitStr); // [ 'H','o','w',' ','a','r','e',' ','y','o','u',' ','d','o','i','n','g','?' ]splitStr = str.split(' ', 3); // 앞에서 부터 3개만 가져와.console.log(splitStr); // [ 'How', 'are', 'you' ]splitStr = str.split('o');console.log(splitStr); // [ 'H', 'w are y', 'u d', 'ing?' ] 3.6 String.prototype.substring() 첫번째 인수로 전달된 index에 해당하는 문자부터 두번째 인수로 전달된 index에 해당하는 문자의 바로 이전 문자까지를 모두 반환한다. 이때 첫번째 인수 &lt; 두번째 인수의 관계가 성립된다. 첫번째 인수 &gt; 두번째 인수 : 두 인수는 교환된다. ex) 4,1이면 1,4로 변경된다. 두번째 인수가 생략된 경우 : 해당 문자열의 끝까지 반환한다. 인수 &lt; 0 또는 NaN인 경우 : 0으로 취급된다. ex) -2를 주면 전체를 애기한다. 인수 &gt; 문자열의 길이(str.length) : 인수는 문자열의 길이(str.length)으로 취급된다. 빈문자를 출력한다. 1234567891011121314151617181920212223242526272829303132var str = 'Hello World'; // str.length == 11var res = str.substring(1, 4);console.log(res); // ell// 첫번째 인수 &gt; 두번째 인수 : 두 인수는 교환된다.res = str.substring(4, 1);console.log(res); // ell// 두번째 인수가 생략된 경우 : 해당 문자열의 끝까지 반환한다.res = str.substring(4);console.log(res); // o World// 인수 &lt; 0 또는 NaN인 경우 : 0으로 취급된다.res = str.substring(-2);console.log(res); // Hello World// 인수 &gt; 문자열의 길이(str.length) : 인수는 문자열의 길이(str.length)으로 취급된다.res = str.substring(1, 12);console.log(res); // ello Worldres = str.substring(11);console.log(res); // ''res = str.substring(20);console.log(res); // ''res = str.substring(0, str.indexOf(' '));console.log(res); // 'Hello'res = str.substring(str.indexOf(' ') + 1, str.length);console.log(res); // 'World' 3.7 String.prototype.toLowerCase() 문자열의 문자를 모두 소문자로 변경한다. 3.8 String.prototype.toUpperCase() 문자열의 문자를 모두 대문자로 변경한다. 3.9 String.prototype.trim() 문자열 양쪽 끝에 있는 공백 문자를 제거한 문자열을 반환한다. 1234var str = ' foo ';var trimmedStr = str.trim();console.log(trimmedStr);console.log(str); 이때 해당 문자열 자신은 변경되지 않는다. 문자열은 변경 불가능한 값(immutable value)이기 때문이다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"String","slug":"JavaScript/String","permalink":"http://yoursite.com/categories/JavaScript/String/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"JavaScript Regexp","slug":"js-study-regexp","date":"2017-08-09T03:54:00.000Z","updated":"2017-11-14T00:18:42.000Z","comments":true,"path":"2017/08/09/js-study-regexp/","link":"","permalink":"http://yoursite.com/2017/08/09/js-study-regexp/","excerpt":"","text":"JavaScript Regexp 1. 정규표현식 (Regulat Expression) 정규표현식(Regular Expression)은 문자열에서 특정 내용을 찾거나 대체 또는 발췌하는데 사용한다. 12345var tel = '0101234567팔';var myRegExp = /^[0-9]+$/;console.log(myRegExp.test(tel)); // false 1var myRegExp = /regexr/i; regexr = 패턴(pattern), i = 플래그(Flag) 1.2 플래그 플래그는 여러가지 종류가 있다. i Ignore Case 대소문자를 구별하지 않고 검색한다. g Global 문자열 내의 모든 패턴을 검색한다. m Multi Line 문자열의 행이 바뀌더라도 검색을 계속한다. 12345678var targetStr = 'Is this all there is?';var regexr = /is/;console.log(targetStr.match(regexr)); // [ 'is', index: 5, input: 'Is this all there is?' ]regexr = /is/ig;console.log(targetStr.match(regexr)); // [ 'Is', 'is', 'is' ] match() method를 사용하면 배열로 반영한다. test() method를 통하여 있는지 없는지를 찾아내기만 한다. 1.2 패턴 패턴에는 찾고자 하는 대상을 문자열로 지정한다. 패턴은 특별한 의미를 가지는 메타문자(Metacharacter) 또는 기호로 표현할 수 있다. 123var targetStr = 'AA BB Aa Bb';// 임의의 문자 3개var regexr = /.../; .를 3개 연속하여 패턴을 생성하였으므로 패턴과 일치하는 3자리 문자를 추출한다. 반복하기 위해서는 플래그 g를 사용한다. 1234var targetStr = 'AA BB Aa Bb';// 임의의 문자 3개를 반복하여 검색var regexr = /.../g;console.log(targetStr.match(regexr)); // [ 'AA ', 'BB ', 'Aa ' ] 대소문자를 구별하지 않게 하려면 플래그 i를 사용한다. 1234var targetStr = 'AA BB Aa Bb';// 'A'를 대소문자 구분없이 반복 검색var regexr = /A/ig;console.log(targetStr.match(regexr)); // [ 'A', 'A', 'A', 'a' ] 앞선 패턴을 최소 한번 반복하려면 앞선 패턴 뒤에 +를 붙인다. 1234var targetStr = 'AA AAA BB Aa Bb';// 'A'가 한번이상 반복되는 문자열을 반복 검색 / 1번도 대상이다.var regexr = /A+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'AAA', 'A' ] |를 사용하면 or의 의미를 가지게 된다. 1234var targetStr = 'AA BB Aa Bb';// 'A' 또는 'B'를 반복 검색var regexr = /A|B/g;console.log(targetStr.match(regexr)); // [ 'A', 'A', 'B', 'B', 'A', 'B' ] 분해되지 않은 단어 레벨로 추출하기 위해서는 +를 같이 사용하면 된다. 1234var targetStr = 'AA AAA BB Aa Bb';// 'A' 또는 'B'가 한번이상 반복되는 문자열을 반복 검색var regexr = /A+|B+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'AAA', 'BB', 'A', 'B' ] []내의 문자는 or로 동작한다 위의 | 와 같다. 1234var targetStr = 'AA BB Aa Bb';// 'A' 또는 'B'가 한번이상 반복되는 문자열을 반복 검색var regexr = /[AB]+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'A', 'B' ] 범위를 지정하려면 []내에 -를 사용한다. 아래의 경우 대문자 알파벳을 추출한다범. 1234var targetStr = 'AA BB ZZ Aa Bb';// 'A' ~ 'Z'가 한번이상 반복되는 문자열을 반복 검색var regexr = /[A-Z]+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'ZZ', 'A', 'B' ] 대소문자를 구별하지 않고 알파벳을 추출하려면 아래와 같이 한다. 1234var targetStr = 'AA BB Aa Bb';// 'A' ~ 'Z' 또는 'a' ~ 'z'가 한번이상 반복되는 문자열을 반복 검색var regexr = /[A-Za-z]+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'Aa', 'Bb' ] 숫자를 추출하는 방법이다. 1234var targetStr = 'AA BB Aa Bb 24,000';// '0' ~ '9'가 한번이상 반복되는 문자열을 반복 검색var regexr = /[0-9]+/g;console.log(targetStr.match(regexr)); // [ '24', '000' ] 컴마 때문에 결과가 분리되므로 패턴에 포함시킨다. 1234var targetStr = 'AA BB Aa Bb 24,000';// '0' ~ '9' 또는 ','가 한번이상 반복되는 문자열을 반복 검색var regexr = /[0-9,]+/g;console.log(targetStr.match(regexr)); // [ '24,000' ] \\d는 숫자를 의미한다. \\D는 \\d와 반대로 동작한다. \\D는 숫자말고 다른 것을 다 포함한다. 12345678var targetStr = 'AA BB Aa Bb 24,000';// '0' ~ '9' 또는 ','가 한번이상 반복되는 문자열을 반복 검색var regexr = /[\\d,]+/g;console.log(targetStr.match(regexr)); // [ '24,000' ]// '0' ~ '9'가 아닌 문자(숫자가 아닌 문자) 또는 ','가 한번이상 반복되는 문자열을 반복 검색var regexr = /[\\D,]+/g;console.log(targetStr.match(regexr)); // [ 'AA BB Aa Bb ', ',' ] \\w는 알파벳과 숫자를 의미한다. \\W는 \\w와 반대로 동작한다. \\W는 알파벳과 숫자가 아닌것을 찾는다. 12345678var targetStr = 'AA BB Aa Bb 24,000';// 알파벳과 숫자 또는 ','가 한번이상 반복되는 문자열을 반복 검색var regexr = /[\\w,]+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'Aa', 'Bb', '24,000' ]// 알파벳과 숫자가 아닌 문자 또는 ','가 한번이상 반복되는 문자열을 반복 검색var regexr = /[\\W,]+/g;console.log(targetStr.match(regexr)); // [ ' ', ' ', ' ', ' ', ',' ] 1.3 자주 사용하는 정규표현식 특정 단어로 시작하는지 검사한다. ^를 사용한다. 1234var targetStr = 'abcdef';// 'abc'로 시작하지 검사var regexr = /^abc/;console.log(regexr.test(targetStr)); // true 특정 단어로 끝나는지 검사한다. $를 사용한다. 1234var targetStr = 'abcdef';// 'ef'로 끝나는지 검사var regexr = /ef$/;console.log(regexr.test(targetStr)); // true 숫자인지 검사한다. /^\\d+$/를 사용한다. 1234var targetStr = '12345';// 모두 숫자인지 검사var regexr = /^\\d+$/;console.log(regexr.test(targetStr)); // true 공백으로 시작하는지 검사한다. ^[\\s]+/; 를 사용한다. 1234var targetStr = ' Hi!';// 1개 이상의 공백으로 시작하는지 검사var regexr = /^[\\s]+/;console.log(regexr.test(targetStr)); // true 아이디로 사용 가능한지 검사한다. (영문자, 숫자만 허용, 4~10자리) /^[A-Za-z0-9]{4,10}$/ 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4 ~10자리인지 검사의 조건을 사용한다. 1234var targetStr = 'abc123';// 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4 ~10자리인지 검사 var regexr = /^[A-Za-z0-9]&#123;4,10&#125;$/console.log(regexr.test(targetStr)); // true 메일 주소 형식에 맞는지 검사한다. /^[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*\\.[a-zA-Z]{2,3}$/i;를 사용한다.123var targetStr = 'ungmo2@gmail.com';var regexr = /^[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*\\.[a-zA-Z]&#123;2,3&#125;$/i;console.log(regexr.test(targetStr)); // true 핸드폰 번호 형식에 맞는지 검사한다. /^\\d{3}-\\d{3,4}-\\d{4}$/;를 사용한다. 123var targetStr = '010-1234-5678';var regexr = /^\\d&#123;3&#125;-\\d&#123;3,4&#125;-\\d&#123;4&#125;$/;console.log(regexr.test(targetStr)); // true 특수 문자 포함 여부를 검사한다. /[{}[]\\/?.,;:|)*~`!^-_+&lt;&gt;@#$%&amp;\\\\=(\\’\\”]/gi 를 사용한다. 특수문자가 있으면 true 없으면 false이다.123var targetStr = 'abc#123';var regexr = /[\\&#123;\\&#125;\\[\\]\\/?.,;:|\\)*~`!^\\-_+&lt;&gt;@\\#$%&amp;\\\\\\=\\(\\'\\\"]/giconsole.log(regexr.test(targetStr)); // true 2. Javascript Regular Expression2.1 RegExp Constructor RegExp 객체를 생성하기 위해서는 리터럴 방식과 RegExp 생성자 함수를 사용할 수 있다. 일반적인 방법은 리터럴 방식이다. 12345678// 정규식 리터럴var myRegExp = /ab+c/i;var myRegExp = new RegExp('ab+c', 'i');var myRegExp = new RegExp(/ab+c/, 'i');var myRegExp = new RegExp(/ab+c/i); // ECMAScript 6 2.2 RegExp Method2.2.1 RegExp.prototype.exec() 문자열을 검색하여 매칭 결과를 반환한다. 반환값은 배열 또는 null이다. 12345var target = 'Is this all there is?';var regExp = /is/;var res = regExp.exec(target);console.log(res); // [ 'is', index: 5, input: 'Is this all there is?' ] 2.2.2 RegExp.prototype.test() 문자열을 검색하여 매칭 결과를 반환한다. 반환값은 true 또는 false이다. 12345var target = 'Is this all there is?';var regExp = /is/;var res = regExp.test(target);console.log(res); // true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Regexp","slug":"JavaScript/Regexp","permalink":"http://yoursite.com/categories/JavaScript/Regexp/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Regexp","slug":"Regexp","permalink":"http://yoursite.com/tags/Regexp/"}]},{"title":"JavaScript Array","slug":"js-study-array","date":"2017-08-09T03:54:00.000Z","updated":"2017-11-14T00:16:09.000Z","comments":true,"path":"2017/08/09/js-study-array/","link":"","permalink":"http://yoursite.com/2017/08/09/js-study-array/","excerpt":"","text":"JavaScript Array1. 배열의 생성1var arr = [1,2,3]; // 리터럴 방식으로 만들수 있다. 프로퍼티가 없고 값만 존재한다. index를 사용하여서 순회가 가능하다. Array() // Array 생성자로 생성하며 prototype관계가 성립한다. 주의: Array는 object type이다. 1.1 배열 리터럴123456789101112var emptyArr = []; // 빈배열var numbersArr = [ 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];console.log(emptyArr[1]); // undefinedconsole.log(numbersArr[1]); // 'one'console.log(emptyArr.length); // 0console.log(numbersArr.length); // 10console.log(typeof numbersArr); // object 요소(element)에는 모든 값이 올 수 있다.(배열, 객체, undefined 등등) 배열은 무조건 []로 표현하며 안의 값으로는 index가 들어간다. 아래는 유사배열 객체이다. 123456var numbersObject = &#123; '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine'&#125;; 유사배열객체의 단점 유사배열객체는 접근이 힘들다. 순서가 보장되지 않는다. for-in문으로 돌리면 우리가 원하는 동작을 할 수 없다. 배열 리터럴은 객체 리터럴과 달리 프로퍼티명이 없고 각 요소(element)의 값만이 존재한다. 배열 리터럴은 인덱스를 가지고 있다. 두 객체의 근본적 차이는 numbersArr는 Array.prototype을 상속받았으나 numbersObject는 Object.prototype을 상속 받았다는 것이다. 대부분의 언어에서 배열의 요소들은 모두 같은 데이터 타입이어야 하지만, 자바스크립트 배열은 어떤 데이터 타입의 조합이라도 포함할 수 있다. 12345var misc = [ 'string', 98.6, true, false, null, undefined, ['nested', 'array'], &#123;object: true&#125;, NaN, Infinity];misc.length // 10 1.2 Array() 생성자 함수 Array() 생성자 함수는 매개변수의 갯수에 따라 다르게 동작한다. new를 꼭 붙여야한다. literal 방식으로 만드는 것이 더 좋다. 1new Array(arrayLength) 매개변수로 전달된 숫자를 length 값으로 가지는 빈 배열 생성 값이 안들어 간곳에는 undefined가 된다. 2. 배열 요소의 추가와 삭제2.1 배열 요소의 추가 객체가 동적으로 프로퍼티를 추가할 수 있는 것처럼 배열도 동적으로 요소를 추가할 수 있다. 순서에 맞게 값을 저장할 필요는 없고 필요한 인덱스 위치에 값을 저장할 수 있다. 값이 할당되지 않은 인덱스 위치의 요소의 값은 undefined가 되고 배열의 길이(length)는 최종 인덱스 위치의 기준으로 산정된다. 123456789var arr = [];console.log(arr[0]); // undefinedarr[0] = 'one';arr[3] = 'three';arr[7] = 'seven';console.log(arr); // [\"one\", undefined × 2, \"three\", undefined × 3, \"seven\"]console.log(arr.length) // 8 2.2 배열 요소의 삭제 배열은 객체이기 때문에 배열의 요소를 삭제하기 위해 delete 연산자를 사용할 수 있다. 해당 요소가 삭제되는 것이 아니라 요소 값이 삭제되어 undefined가 된다. 해당 요소를 완전히 삭제하기 위해서는 Array.prototype.splice() 메소드를 사용한다. 123456789var numbersArr = ['zero', 'one', 'two', 'three'];// 요소의 값만 삭제된다delete numbersArr[2]; // ['zero', 'one', undefined, 'three']console.log(numbersArr);// 요소 일부를 삭제 (배열 시작점, 삭제할 요소수)numbersArr.splice(2, 1); // ['zero', 'one', 'three'] 2번째에서 1개 지워라.console.log(numbersArr); splice(2,1)를 사용하면 2번째 인덱스부터 1개를 지우고 지운 뒤에는 index값들이 자동으로 바뀐다. 3. 배열 요소의 열거 일반 for 문을 사용하여서 열거를 할 수 있다. 123456789101112var numbersArr = ['zero', 'one', 'two', 'three'];numbersArr.foo = 10;for (var prop in numbersArr) &#123; console.log(prop, numbersArr[prop]); // 0 zero / 1 one / 2 two / 3 three / foo 10&#125;for (var i = 0; i &lt; numbersArr.length; i++) &#123; console.log(i, numbersArr[i]); // 0 'zero' / 1 'one' / 2 'two' / 3 'three'&#125; for in 문은 property까지 다가져온다. 그래서 for문과 다르게 foo 10이 나온다. ES6에서는 유사배열을 돌리는 for of문을 사용한다. 4. Array Property4.1 Array.length 순회가능한 것에는 length가 필요하다 1234567var myArray = [];console.log(myArray.length); // 0myArray[1000] = true; // [ undefined, undefined, ... , true ]console.log(myArray.length); // 1001console.log(myArray[0]); // undefined 1000번째 인덱스에 값이 들어왔으니 0~999까지는 undefined가 채워지기에 length는 1000+1 = 1001이다. length 프로퍼티는 명시적으로 값을 변경할 수 있다. length 프로퍼티의 값을 현재 보다 작게 설정하면 설정한 값보다 크거나 같은 인덱스에 해당하는 요소는 모두 삭제된다. 123456789101112131415var arr = [ 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];// 배열 길이의 명시적 설정arr.length = 3; // [ 'zero', 'one', 'two' ]// 배열 끝에 새 요소 추가arr[arr.length] = 'san'; // [ 'zero', 'one', 'two', 'san' ]arr.length = 5; // [ 'zero', 'one', 'two', 'san', undefined ]// 배열 끝에 새 요소 추가arr.push('go'); // [ 'zero', 'one', 'two', 'san', undefined, 'go' ] push() method는 마지막 인덱스 위치에 값을 할당한 것과 같다. push보다 arr.length에다가 추가하는것이 속도적으로 더빠르다. 5. Array Method5.1 Array.isArray() static method이다 객체가 배열이면 true, 배열이 아니면 false를 반환한다. 일반 method는 호출시 object명.method명, static은 생성자함수명.method명 을 사용한다.static의 생성자함수의 method는 new가 필요없이 GO에 이미 값이 올라가 있다. 1234567891011121314// trueArray.isArray([]); //trueArray.isArray([1, 2]); // trueArray.isArray(new Array()); // true// falseArray.isArray(); Array.isArray(&#123;&#125;);Array.isArray(null);Array.isArray(undefined);Array.isArray(1);Array.isArray('Array');Array.isArray(true);Array.isArray(false); 5.2 Array.prototype.indexOf() 배열에서 인수로 지정된 요소를 검색하여 인덱스를 반환한다 중복되는 요소가 있는 경우 첫번째 인덱스만 반환된다. 만일 해당하는 요소가 없는 경우, -1을 반환한다. 123var arr = [1, 2, 2, 3];arr.indexOf(2); // 1arr.indexOf(4); // -1 반환 값이 -1이면 실패했다는 처리를 해줘야한다. 5.3 Array.prototype.concat(item…) 인수로 넘어온 값들(배열 또는 값)을 자신의 복사본에 요소로 추가하고 복사본을 반환한다. 이때 원본 배열은 변경되지 않는다. 1234567891011121314var a = ['a', 'b', 'c'];var b = ['x', 'y', 'z'];var c = a.concat(b);console.log(c); // ['a', 'b', 'c', 'x', 'y', 'z']var d = a.concat('String');console.log(d); // ['a', 'b', 'c', 'String']var e = a.concat(b, true);console.log(e); // ['a', 'b', 'c', 'x', 'y', 'z', true]// 원본 배열은 변하지 않는다.console.log(a); // [ 'a', 'b', 'c' ] 5.4 Array.prototype.join() 배열 요소 전체를 연결하여 문자열을 만든다. 기본구분자는 ‘,’이다. option으로 원하는 값을 넣을 수 있다. Array.prototype.join() 메소드는 + 연산자보다 빠르다. 123456789101112str = arr.join([separator = ','])var arr = ['a', 'b', 'c', 'd'];var x = arr.join();console.log(x); // 'a,b,c,d';var y = arr.join(''); // 다붙인다.console.log(y); // 'abcd'var z = arr.join(':');console.log(z); // 'a:b:c:d' 5.5 Array.prototype.pop() pop은 push와 함께 배열을 스택(LIFO: Last In First Out)처럼 동작하게 한다.(후입 선출) pop 메소드는 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. 빈 배열일 경우 undefined를 반환한다. 123456var a = ['a', 'b', 'c'];var c = a.pop();// 원본 배열이 변경된다.console.log(a); // a --&gt; ['a', 'b']console.log(c); // c --&gt; 'c' 5.6 Array.prototype.push(item…) 인수로 넘어온 항목을 배열의 끝에 추가한다. concat 메소드와 다르게 배열 자체를 변경하여 넘어온 인수 전체를 배열에 추가한다. 반환값은 배열의 새로운 length 값이다. 12345678910var a = ['a', 'b', 'c'];var b = ['x', 'y', 'z'];// push는 원본 배열을 직접 변경하고 변경된 배열의 length를 반환한다.var c = a.push(b, true);console.log(a); // a --&gt; ['a', 'b', 'c', ['x', 'y', 'z'], true]console.log(c); // c --&gt; 5;// concat은 원본 배열을 직접 변경하지 않고 복사본을 반환한다.console.log([1, 2].concat([3, 4])); // [ 1, 2, 3, 4 ] 요소로 배열이 들어올 수 있다. 배열의 마지막에 값을 추가 할 때는 Array.prototype.push(), 선두에 추가 할 때는 Array.prototype.unshift(), 중간에 추가할 때는 Array.prototype.splice() 메소드를 사용한다. push, unshift 메소드는 사용하기 간편하나 performance 면에서는 좋은 방법은 아니다. 1234567var arr = [1, 2, 3, 4, 5];arr.push(6);arr[arr.length] = 6; // 43% faster in Chrome 47.0.2526.106 on Mac OS X 10.11.1arr.unshift(0);[0].concat(arr); // 98% faster in Chrome 47.0.2526.106 on Mac OS X 10.11.1 5.7 Array.prototype.reverse() 배열 요소의 순서를 반대로 변경한다. 이때 원본 배열이 변경된다. 반환값은 변경된 배열이다. 123456var a = ['a', 'b', 'c'];var b = a.reverse();// 원본 배열이 변경된다console.log(a); // [ 'c', 'b', 'a' ]console.log(b); // [ 'c', 'b', 'a' ] 5.8 Array.prototype.shift() shift는 push와 함께 배열을 큐(FIFO: First In First Out)처럼 동작하게 한다. 배열에서 첫요소를 제거하고 제거한 요소를 반환한다. 만약 빈 배열일 경우 undefined를 반환한다. 123456var a = ['a', 'b', 'c'];var c = a.shift();// 원본 배열이 변경된다.console.log(a); // a --&gt; [ 'b', 'c' ]console.log(c); // c --&gt; 'a' 5.9 Array.prototype.slice(start, end) 배열의 특정 부분에 대한 복사본을 생성한다. 원본을 건드리지 않는다. 첫번째 매개변수 start에 해당하는 인덱스를 갖는 요소부터 매개변수 end에 해당하는 인덱스를 가진 요소 전까지 복사된다. 123456789101112131415161718192021222324var items = ['a', 'b', 'c'];// items[0]부터 items[1] 이전(items[1] 미포함)까지 반환var res1 = items.slice(0, 1);console.log(res1); // [ 'a' ]// items[1]부터 items[2] 이전(items[2] 미포함)까지 반환var res2 = items.slice(1, 2);console.log(res2); // [ 'b' ]// items[1]부터 이후의 모든 요소 반환var res3 = items.slice(1);console.log(res3); // [ 'b', 'c' ]// 인자가 음수인 경우 배열의 끝에서 2개의 요소를 반환var res4 = items.slice(-2);console.log(res4); // [ 'b', 'c' ]// 모든 요소를 반환var res5 = items.slice();console.log(res5); // [ 'a', 'b', 'c' ]// slice는 복사본을 반환한다. 원본은 변경되지 않는다.console.log(items); // [ 'a', 'b', 'c' ] 5.10 Array.prototype.splice(start, deleteCount, item…) 기존의 배열의 요소를 제거하고 그 위치에 새로운 요소를 추가한다. 배열 중간에 새로운 요소를 추가할 때도 사용된다. start : 배열에서의 시작 위치이다 deleteCount : 시작 위치(start)부터 제거할 요소의 수이다. item : 삭제한 위치에 추가될 요소들이다. (옵션) 12345678910111213141516171819202122232425262728293031323334353637383940var items = ['one', 'two', 'three', 'four'];// items[1]부터 2개의 요소를 제거하고 제거된 요소를 배열로 반환var res = items.splice(1, 2);// 원본 배열이 변경된다.console.log(items); // [ 'one', 'four' ]// 제거한 요소가 배열로 반환된다.console.log(res); // [ 'two', 'three' ]var items = ['one', 'two', 'three', 'four'];// items[1]부터 2개의 요소를 제거하고 그자리에 새로운 요소를 추가한다. 제거된 요소가 반환된다.var res = items.splice(1, 2, 'x', 'y');// 원본 배열이 변경된다.console.log(items); // [ 'one', 'x', 'y', 'four' ]// 제거한 요소가 배열로 반환된다.console.log(res); // [ 'two', 'three' ]var items = ['one', 'two', 'three', 'four'];// items[1]부터 0개의 요소를 제거하고 그자리(items[1])에 새로운 요소를 추가한다. 제거된 요소가 반환된다.var res = items.splice(1, 0, 'x');// 원본 배열이 변경된다.console.log(items); // [ 'one', 'x', 'two', 'three', 'four' ]// 제거한 요소가 배열로 반환된다.console.log(res); // [ ]var items = ['one', 'four'];// items[1]부터 0개의 요소를 제거하고 그자리(items[1])에 새로운 배열를 추가한다. 제거된 요소가 반환된다.// var res = items.splice(1, 0, ['two', 'three']); // [ 'one', [ 'two', 'three' ], 'four' ]var res = Array.prototype.splice.apply(items, [1, 0].concat(['two', 'three']));// ES6// var res = items.splice(1, 0, ...['two', 'three']);console.log(items); // [ 'one', 'two', 'three', 'four' ]console.log(res); // [ ] [‘two’,’three’]가 배열로 되어있어서 apply를 사용하여서 배열을 풀어서 넣는다 ES6에서는 …을 사용하여서 해결한다. 5.11 Array.prototype.sort(comparefunc) 배열의 내용을 적절하게 정렬한다. 수를 정렬할때 인자로 callback함수를 주어야한다. 원본이 변경이 된다. 1234567891011121314151617181920212223242526272829303132var fruits = ['Banana', 'Orange', 'Apple', 'Mango'];// ascending(오름차순)fruits.sort();console.log(fruits); // [ 'Apple', 'Banana', 'Mango', 'Orange' ]// descending(내림차순)fruits.reverse();console.log(fruits); // [ 'Orange', 'Mango', 'Banana', 'Apple' ]var points = [40, 100, 1, 5, 25, 10];points.sort();console.log(points); // [ 1, 10, 100, 25, 40, 5 ]// Syntax : array.sort(compareFunction)// 숫자 배열 오름차순 정렬// compareFunction의 반환값이 0보다 작은 경우, a를 우선한다.points.sort(function (a, b) &#123; return a - b; &#125;);console.log(points); // [ 1, 5, 10, 25, 40, 100 ]// 숫자 배열에서 최소값 취득console.log(points[0]); // 1// 숫자 배열 내림차순 정렬// compareFunction의 반환값이 0보다 큰 경우, b를 우선한다.points.sort(function (a, b) &#123; return b - a; &#125;);console.log(points); // [ 100, 40, 25, 10, 5, 1 ]// 숫자 배열에서 최대값 취득console.log(points[0]); // 100 5.12 Array.prototype.map() 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수를 실행하고 그 결과가 반영된 새로운 배열을 반환한다. 1번째 인자로 콜백함수의 인자로 요소값, 요소 인덱스, 순회할 배열을 전달할 수 있다. 1234var numbers = [1, 4, 9];// 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수를 실행var roots = numbers.map(Math.sqrt);console.log(roots); // [ 1, 2, 3 ] 2번째 인자로 this를 전달할 수 있다. 12345678910111213141516function Prefixer(prefix) &#123; this.prefix = prefix;&#125;Prefixer.prototype.prefixArray = function (arr) &#123; // 콜백함수의 인자로 요소값, 요소 인덱스, 순회할 배열을 전달할 수 있다. return arr.map(function (x) &#123; // x는 요소값이다. return this.prefix + x; // 2번째 인자 this를 전달하지 않으면 this === window &#125;, this);&#125;;var pre = new Prefixer('-webkit-');var preArr = pre.prefixArray(['linear-gradient', 'border-radius']);console.log(preArr);// [ '-webkit-linear-gradient', '-webkit-border-radius' ] x는 map함수가 기본적으로 세팅하는 값은 순서대로 요소값을 나타내며 그 뒤에 값을 더 넣어주는 순서대로, 요소 인덱스, 순회할 배열을 전달할 수 있다. Es6의 Arrow function를 사용하면 this를 생략하여도 동일한 동작을 한다. 순회하는 함수들은 2번째 인자로 this를 넣어줄수 있다 그래서 this가 전역이 되는 것을 막아준다.만약 2번째 인자로 사용하지 않는다면 that을 생성하여서 that을 넣어주면 된다. 5.13 Array.prototype.forEach() 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수를 실행한다. 콜백함수의 인자로 요소값, 요소 인덱스, 순회할 배열을 전달할 수 있다. 일반 for 구문에 비해 성능이 좋지는 않다. 12345678var total = 0;[1, 3, 5, 7, 9].forEach(function (element, index, array) &#123; console.log('[' + index + '] = ' + element); total += element;&#125;);console.log(total); 2번째 인자로 this를 전달할 수 있다. 12345678910111213141516function Counter() &#123; this.sum = 0; this.count = 0;&#125;Counter.prototype.add = function (array) &#123; // entry는 array의 요소값 array.forEach(function (entry) &#123; this.sum += entry; // 2번째 인자 this를 전달하지 않으면 this === window this.count++; &#125;, this);&#125;;var obj = new Counter();obj.add([2, 5, 9]);console.log(obj.count); // 3console.log(obj.sum); // 16 Es6의 Arrow function를 사용하면 this를 생략하여도 동일한 동작을 한다. 5.14 Array.prototype.filter() 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수의 실행 결과가 true인 요소값만을 모은 새로운 배열을 반환한다. 배열에서 특정 케이스만 필터링 조건으로 추출하여 새로운 배열을 만들고 싶을 때 사용한다. 콜백함수의 인자로 요소값, 요소 인덱스, 순회할 배열을 전달할 수 있다. 123456var result = [1, 2, 3, 4, 5].filter(function (element, index, array) &#123; console.log('[' + index + '] = ' + element); return element % 2; // 홀수만을 필터링한다 (1은 true로 평가된다)&#125;);console.log(result); 5.15 Array.prototype.reduce() 배열을 순회하며 각 요소에 대하여 이전의 콜백함수 실행 반환값을 전달하여 콜백함수를 실행하고 그 결과를 반환한다. previousValue: 이전 콜백의 반환값, currentValue : 요소값, currentIndex : 인덱스, array : 순회할 배열를 인자로 가진다. 12345678910111213141516171819/*previousValue: 이전 콜백의 반환값currentValue : 요소값currentIndex : 인덱스array : 순회할 배열*/var result = [1, 2, 3, 4, 5].reduce(function (previousValue, currentValue, currentIndex, array) &#123; console.log(previousValue + '+' + currentValue + '=' + (previousValue + currentValue)); return previousValue + currentValue; // 결과는 다음 콜백의 첫번째 인자로 전달된다&#125;);console.log(result); // 15: 1~5까지의 합/*1: 1+2=32: 3+3=63: 6+4=104: 10+5=1515*/ 1번 시작시 (1,2) / 2번 시작시 (1+2,3) / 3번 시작시 (1+2+3,4) / 4번 시작시 (1+2+3+4, 5) Array.prototype.reduce() 5.16 Array.prototype.find() ES6에서 새롭게 도입된 메소드로 Internet Explorer에서는 지원하지 않는다. 배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수를 실행하여 그 결과가 참인 첫번째 요소를 반환한다. 콜백함수의 인자로 요소값, 요소 인덱스, 순회할 배열을 전달할 수 있다. 123456789101112131415var array = [ &#123; id: 1, name: 'Lee' &#125;, &#123; id: 2, name: 'Kim' &#125;, &#123; id: 2, name: 'Choi' &#125;, &#123; id: 3, name: 'Park' &#125;];var result = array.find(function (element) &#123; return element.id === 2; // 조건&#125;);// ES6// const result = array.find(element =&gt; element.id === 2;);console.log(result); // &#123; id: 2, name: 'Kim' &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Array","slug":"JavaScript/Array","permalink":"http://yoursite.com/categories/JavaScript/Array/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"}]},{"title":"JavaScript Date","slug":"js-study-date","date":"2017-08-09T03:54:00.000Z","updated":"2017-11-14T00:18:01.000Z","comments":true,"path":"2017/08/09/js-study-date/","link":"","permalink":"http://yoursite.com/2017/08/09/js-study-date/","excerpt":"","text":"JavaScript Date 생성자 함수로 반드시 생성해야한다 리터럴 방식이 없다. 1. Date Constructor Date 생성자를 사용하여 날짜와 시간을 가지는 인스턴스를 생성한다. 1234new Date()new Date(milliseconds)new Date(dateString)new Date(year, month[, day, hour, minute, second, millisecond]) Date() 생성자 함수를 new 연산자없이 사용하면 Date 객체를 반환하지 않고 결과값을 문자열로 반환한다. 1234567var date = new Date();console.log(typeof date, date); //object Thu May 12 2016 00:51:36 GMT+0900 (KST)date = Date();console.log(typeof date, date); // string Thu May 12 2016 00:51:36 GMT+0900 (KST)console.dir(Date); 1.1 new Date() 매개변수가 없는 경우 현재 날짜와 시간을 가지는 인스턴스를 반환한다. 12var d = new Date();console.log(d); // Thu May 12 2016 15:38:39 GMT+0900 (KST) 1.2 new Date(milliseconds) 매개변수에 밀리초를 전달하면 1970년 1월 1일 00:00(UTC)을 기점으로 전달된 밀리초만큼 경과한 날짜와 시간을 가지는 인스턴스를 반환한다. 12345var d = new Date(0);console.log(d); // Fri Jan 01 1970 09:00:00 GMT+0900 (KST)var d = new Date(86400000);console.log(d); // Fri Jan 02 1970 09:00:00 GMT+0900 (KST) 86400000ms는 1day를 의미한다. 1.3 new Date(dateString) 매개변수에 날짜와 시간을 나타내는 문자열을 전달하면 지정된 날짜와 시간을 가지는 인스턴스를 반환한다. 문자열로 나타내진다. 12var d = new Date('2017/08/08/20:00:00');console.log(d); // Tue Aug 08 2017 20:00:00 GMT+0900 (KST) 1.4 new Date(year, month[, day, hour, minute, second, millisecond]) 매개변수에 년, 월, 일, 시, 분, 초, 밀리초를 의미하는 숫자를 전달하면 지정된 날짜와 시간을 가지는 인스턴스를 반환한다. 이때 년, 월을 반드시 지정하여야 한다. 숫자로 나타내진다. year 1900년 이후의 년 month 월을 나타내는 0 ~ 11까지의 정수 (주의: 0부터 시작, 0 = 1월) day 일을 나타내는 1 ~ 31까지의 정수 hour 시를 나타내는 0 ~ 23까지의 정수 minute 분을 나타내는 0 ~ 59까지의 정수 second 초를 나타내는 0 ~ 59까지의 정수 millisecond 밀리초를 나타내는 0 ~ 999까지의 정수 1234567891011var d = new Date(1999);console.log(d); // Thu Jan 01 1999 09:00:01 GMT+0900 (KST)var d = new Date(1999, 10, 3, 11, 33, 30, 0);console.log(d); // Wed Nov 03 1999 11:33:30 GMT+0900 (KST)var d = new Date(1999, 10);console.log(d); // Mon Nov 01 1999 00:00:00 GMT+0900 (KST)var d = new Date('1999/10/3/11:33:00:00');console.log(d); // Mon Nov 01 1999 00:00:00 GMT+0900 (KST) 2. Date Method2.1 Date.now() 1970년 1월 1일 00:00:00(UTC)을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환한다. 12var n = Date.now();console.log(n); 2.2 Date.parse() 1970년 1월 1일 00:00:00(UTC)을 기점으로 매개변수로 전달된 지정 시간(new Date(dateString)의 인수와 동일한 형식)까지의 밀리초를 숫자로 반환한다. UTC로 지정을 안해주면 컴퓨터의 로컬을 기준으로 반영한다. 12345678var d = Date.parse('Jan 2, 1970 00:00:00 UTC'); // UTCconsole.log(d); // 86400000var d = Date.parse('Jan 2, 1970 09:00:00'); // KSTconsole.log(d); // 86400000var d = Date.parse('1970/01/02/09:00:00'); // KSTconsole.log(d); // 86400000 2.3 Date.UTC() 1970년 1월 1일 00:00:00(UTC)을 기점으로 매개변수로 전달된 지정 시간(new Date(year, month[, day, hour, minute, second, millisecond]))의 인수와 동일한 형식)까지의 밀리초를 숫자로 반환한다. UTC() 메소드는 new Date(year, month[, day, hour, minute, second, millisecond])와 같은 형식의 인수를 사용한다. 하지만 UTC() 메소드의 인수는 local time(KST)가 아닌 UTC로 인식된다. 12345var d = Date.UTC(1970, 0, 2);console.log(d); // 86400000var d = Date.UTC('1970/1/2');console.log(d); // NaN 2.4 Date.prototype.getFullYear() 해당 연도를 나타내는 4자리 숫자를 반환한다. 12345var today = new Date();var year = today.getFullYear();console.log(today); // Tue Aug 08 2017 20:53:24 GMT+0900 (KST)console.log(year); // 2017 2.5 Date.prototype.setFullYear() 해당 연도를 나타내는 4자리 숫자를 설정한다. 연도 이외 월, 일도 설정할 수 있다. 123456789101112131415dateObj.setFullYear(yearValue[, monthValue[, dayValue]])var today = new Date();today.setFullYear(2000);var year = today.getFullYear();console.log(today); // Tue Aug 08 2000 20:54:21 GMT+0900 (KST)console.log(year); // 2000today.setFullYear(1900, 0, 1);year = today.getFullYear();console.log(today); // Mon Jan 01 1900 20:54:21 GMT+0900 (KST)console.log(year); // 1900 2.6 Date.prototype.getMonth() 해당 월을 나타내는 0 ~ 11의 정수를 반환한다. 1월은 0, 12월은 11이다. 2.7 Date.prototype.setMonth() 해당 월을 나타내는 0 ~ 11의 정수를 설정한다. 1월은 0, 12월은 11이다. 월 이외 일도 설정할 수 있다. 2.8 Date.prototype.getDate() 해당 날짜(1 ~ 31)를 나타내는 정수를 반환한다. 2.9 Date.prototype.setDate() 해당 날짜(1 ~ 31)를 나타내는 정수를 설정한다. ###2.10 Date.prototype.getDay() 해당 요일(0 ~ 6)를 나타내는 정수를 반환한다. 반환값은 아래와 같다. 0은 일요일 6은 토요일이다. 12345var today = new Date();var day = today.getDay();console.log(today); // Tue Aug 08 2017 20:58:22 GMT+0900 (KST)console.log(day); // 2 2.11 Date.prototype.getHours() 해당 시간(0 ~ 23)를 나타내는 정수를 반환한다. 2.12 Date.prototype.setHours() 해당 시간(0 ~ 23)를 나타내는 정수를 설정한다. 시간 이외 분, 초, 밀리초도 설정할 수 있다. 2.13 Date.prototype.getMinutes() 해당 분(0 ~ 59)를 나타내는 정수를 반환한다. 2.14 Date.prototype.setMinutes() 해당 분(0 ~ 59)를 나타내는 정수를 설정한다. 분 이외 초, 밀리초도 설정할 수 있다. 2.15 Date.prototype.getSeconds() 해당 초(0 ~ 59)를 나타내는 정수를 반환한다. 2.16 Date.prototype.setSeconds() 해당 초(0 ~ 59)를 나타내는 정수를 설정한다. 초 이외 밀리초도 설정할 수 있다. 2.17 Date.prototype.getMilliseconds() 해당 밀리초(0 ~ 999)를 나타내는 정수를 반환한다. 2.18 Date.prototype.setMilliseconds() 해당 밀리초(0 ~ 999)를 나타내는 정수를 설정한다. 2.19 Date.prototype.getTime() 1970년 1월 1일 00:00:00(UTC)를 기점으로 현재 시간까지 경과된 밀리초를 반환한다. 2.20 Date.prototype.setTime() 1970년 1월 1일 00:00:00(UTC)를 기점으로 현재 시간까지 경과된 밀리초를 설정한다. 2.21 Date.prototype.getTimezoneOffset() UTC와 지정 로케일(Locale) 시간과의 차이를 분단위로 반환한다. 2.22 Date.prototype.toDateString() 사람이 읽을 수 있는 형식의 문자열로 날짜를 반환한다. 1234var d = new Date('1988/8/17/13:30');console.log(d.toString()); // Sat Sep 17 1988 13:30:00 GMT+1000 (KDT)console.log(d.toDateString()); // Sat Sep 17 1988 2.23 Date.prototype.toTimeString() 사람이 읽을 수 있는 형식의 문자열로 시간을 반환한다. 1234var d = new Date('1988/8/17/13:30');console.log(d.toString()); // Wed Aug 17 1988 13:30:00 GMT+1000 (KDT)console.log(d.toTimeString()); // 13:30:00 GMT+1000 (KDT) 3. Date Example 현재 날짜와 시간을 초단위로 반복 출력하는 예제이다. 12345678910111213141516171819202122232425262728(function printNow() &#123; var today = new Date(); var dayNames = ['(일요일)', '(월요일)', '(화요일)', '(수요일)', '(목요일)', '(금요일)', '(토요일)']; // getDay: 해당 요일(0 ~ 6)를 나타내는 정수를 반환한다. var day = dayNames[today.getDay()]; var year = today.getFullYear(), month = today.getMonth() + 1, date = today.getDate(), hour = today.getHours(), minute = today.getMinutes(), second = today.getSeconds(); ampm = hour &gt;= 12 ? 'PM' : 'AM'; // 12시간제로 변경 hour = hour % 12; hour = hour ? hour : 12; // 0 =&gt; 12 // 10미만인 분과 초를 2자리로 변경 minute = minute &lt; 10 ? '0' + minute : minute; second = second &lt; 10 ? '0' + second : second; var now = year + '년 ' + month + '월 ' + date + '일 ' + day + ' ' + hour + ':' + minute + ':' + second + ' ' + ampm; console.log(now); setTimeout(printNow, 1000);&#125;());","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Date","slug":"JavaScript/Date","permalink":"http://yoursite.com/categories/JavaScript/Date/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Date","slug":"Date","permalink":"http://yoursite.com/tags/Date/"}]},{"title":"JavaScript Built In Object","slug":"js-study-built-in-object","date":"2017-08-08T03:54:00.000Z","updated":"2017-11-13T00:51:14.000Z","comments":true,"path":"2017/08/08/js-study-built-in-object/","link":"","permalink":"http://yoursite.com/2017/08/08/js-study-built-in-object/","excerpt":"","text":"JavaScript Built In ObjectBuilt-in Object(내장 객체)는 웹페이지 등을 표현하기 위한 공통의 기능을 제공한다. Standard Built-in Objects (or Global Objects) 기본적으로 적용되어있는 객체들 (string, array 등등) BOM (Browser Object Model) size, history 함수 등등 DOM (Document Object Model) render tree 등등 Standard Built-in Objects(표준 빌트인 객체)를 제외한 BOM과 DOM을 Native Object라고 분류하기도 한다. 또한 사용자가 생성한 객체를 Host Object(사용자 정의 객체)라 한다. 1. Standard Built-in Objects (or Global Objects) javascript가 제공하며 기본적으로 대문자로 시작한다. 전역 객체의 프로퍼티이다. Global Object는 전역객체를 뜻한다. Global Objects랑 의미가 다르다. 2. BOM (Browser Object Model) client side에서 최상위 객체는 window이다. BOM 객체 자세한 내용은 window 객체 참조를 참조하기 바란다. 3. DOM (Document Object Model) DOM은 browser가 만든다. 최상위 객체는 document 객체로 전체 문서를 표현한다. DOM 객체","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Built In Object","slug":"JavaScript/Built-In-Object","permalink":"http://yoursite.com/categories/JavaScript/Built-In-Object/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Built In Object","slug":"Built-In-Object","permalink":"http://yoursite.com/tags/Built-In-Object/"}]},{"title":"JavaScript Number","slug":"js-study-Number","date":"2017-08-08T03:54:00.000Z","updated":"2017-11-13T00:54:07.000Z","comments":true,"path":"2017/08/08/js-study-Number/","link":"","permalink":"http://yoursite.com/2017/08/08/js-study-Number/","excerpt":"","text":"JavaScript Number 1. Number Constructor Number 객체는 Number() 생성자 함수를 통해 생성할 수 있다. 123456789new Number(value);var x = new Number(123);var y = new Number('123');var z = new Number('str');console.log(x); // 123console.log(y); // 123console.log(z); // NaN new와 함께 사용하지 않는다면 형변환을 한다. 123456789101112var x = Number('123');console.log(typeof x, x); // number 123var x = 123; // type이 number이다.var y = new Number(123); // type이 object이다.console.log(x == y); // trueconsole.log(x === y); // false 형과 값을 본다.console.log(typeof x); // numberconsole.log(typeof y); // object 2. Number Property2.1 Number.EPSILON Number.EPSILON은 JavaScript에서 표현할 수 있는 가장 작은 수이다. 2진수의 형태로다저장되기에 모든 부동소수점은 산술 연산 비교는 정확한 값을 기대하기 어렵다. 부동소수점의 비교는 Number.EPSILON을 사용하여 비교 기능을 갖는 함수를 작성하여야 한다. ex) 0.1와 0.1보다 가장작은 것과의 차이가 EPSILON이다.12345678910console.log(0.1 + 0.2); // 0.30000000000000004console.log(0.1 + 0.2 == 0.3); // false!!!function isEqual(a, b)&#123; // Math.abs는 절대값을 반환한다. // 즉 a와 b의 차이가 JavaScript에서 표현할 수 있는 가장 작은 수인 Number.EPSILON보다 작으면 같은 수로 인정할 수 있다. return Math.abs(a - b) &lt; Number.EPSILON;&#125;console.log(isEqual(0.1 + 0.2, 0.3)); 2.2 Number.MAX_VALUE 자바스크립트에서 사용 가능한 가장 큰 숫자(1.7976931348623157e+308)를 반환한다. MAX_VALUE보다 큰 숫자는 Infinity이다. 123456Number.MAX_VALUE; // 1.7976931348623157e+308var num = 10;num.MAX_VALUE; // undefinedconsole.log(Infinity &gt; Number.MAX_VALUE); // true 2.3 Number.MIN_VALUE 자바스크립트에서 사용 가능한 가장 작은 숫자(5e-324)를 반환한다. MIN_VALUE는 0에 가장 가까운 양수 값이다. MIN_VALUE보다 작은 숫자는 0으로 변환된다. 123456Number.MIN_VALUE; // 5e-324var num = 10;num.MIN_VALUE; // undefinedconsole.log(Number.MIN_VALUE &gt; 0); // true 2.4 Number.POSITIVE_INFINITY 양의 무한대 Infinity를 반환한다. 1234Number.POSITIVE_INFINITY // Infinityvar num = 10;num.POSITIVE_INFINITY; // undefined 2.5 Number.NEGATIVE_INFINITY 음의 무한대 -Infinity를 반환한다. 1234Number.NEGATIVE_INFINITY // -Infinityvar num = 10;num.NEGATIVE_INFINITY; // undefined 2.6 Number.NaN 숫자가 아님(Not-a-Number)을 나타내는 숫자값이다. Number.NaN 프로퍼티는 NaN 프로퍼티와 같다. 123console.log(Number('xyz')); // NaNconsole.log(1 * 'string'); // NaNconsole.log(typeof NaN); // number 3. Number Method Number 안에 Method들은 형변환을 하지 않는다. 3.1 Number.isFinite() 매개변수를 통해 전달된 값이 유한수인지, 정상적인 수인지를 검사하여 그 결과를 Boolean으로 반환한다. Number 생성자 함수의 property들이다.(static method 정적) 12345678Number.isFinite(Infinity) // falseNumber.isFinite(NaN) // falseNumber.isFinite('Hello') // falseNumber.isFinite('2005/12/12') // falseNumber.isFinite(0) // trueNumber.isFinite(2e64) // trueNumber.isFinite(null) // false. isFinite(null) =&gt; true 3.2 Number.isInteger() 매개변수를 통해 전달된 값이 정수(Integer)인지 검사하여 그 결과를 Boolean으로 반환한다. 검사전에 인수를 숫자로 변환하지 않는다. Number 생성자 함수의 property들이다.(static method 정적) 123456789101112Number.isInteger(testValue)// testValue: 검사 대상 값Number.isInteger(123) //trueNumber.isInteger(-123) //trueNumber.isInteger(5-2) //trueNumber.isInteger(0) //trueNumber.isInteger(0.5) //falseNumber.isInteger('123') //falseNumber.isInteger(false) //falseNumber.isInteger(Infinity) //falseNumber.isInteger(-Infinity) //falseNumber.isInteger(0 / 0) //false 3.3 Number.isNaN() 매개변수를 통해 전달된 값이 NaN인지를 검사하여 그 결과를 Boolean으로 반환한다. Number 생성자 함수의 property들이다.(static method 정적) 12345678910111213141516Number.isNaN(testValue)// testValue: 검사 대상 값Number.isNaN(NaN) // trueNumber.isNaN(undefined) // false. undefined-&gt;NaN. isNaN(undefined) -&gt; true.Number.isNaN(&#123;&#125;) // false. &#123;&#125;-&gt;NaN. isNaN(&#123;&#125;) -&gt; true.Number.isNaN('blabla') // false. 'blabla'-&gt;NaN. isNaN('blabla') -&gt; true.Number.isNaN(true) // falseNumber.isNaN(null) // falseNumber.isNaN(37) // falseNumber.isNaN('37'); // falseNumber.isNaN('37.37'); // falseNumber.isNaN(''); // falseNumber.isNaN(' '); // falseNumber.isNaN(new Date()) // falseNumber.isNaN(new Date().toString()) // false. String-&gt;NaN. isNaN(String) -&gt; true. NaN이 아니면 전부다 false이다. 3.4 Number.isSafeInteger() javascript로 표현할 수 있는 정수 범위 안에 있는가? 매개변수를 통해 전달된 값이 안전한(safe) 정수값인지 검사하여 그 결과를 Boolean으로 반환한다. 검사전에 인수를 숫자로 변환하지 않는다. Number 생성자 함수의 property들이다.(static method 정적) 1234567891011121314Number.isSafeInteger(testValue)// testValue: 검사 대상 값Number.isSafeInteger(123) //trueNumber.isSafeInteger(-123) //trueNumber.isSafeInteger(5-2) //trueNumber.isSafeInteger(0) //trueNumber.isSafeInteger(1000000000000000) // trueNumber.isSafeInteger(10000000000000001) // falseNumber.isSafeInteger(0.5) //falseNumber.isSafeInteger('123') //falseNumber.isSafeInteger(false) //falseNumber.isSafeInteger(Infinity) //falseNumber.isSafeInteger(-Infinity) //falseNumber.isSafeInteger(0 / 0) //false 3.5 Number.prototype.toExponential() 대상을 지수 표기법으로 변환하여 문자열로 반환한다. 객체에 대해서 호출한다. 123456789numObj.toExponential([fractionDigits])// fractionDigits: 0~20 사이의 정수값으로 소숫점 이하의 자릿수를 나타낸다. 옵션으로 생략 가능하다. var numObj = 77.1234;console.log(numObj.toExponential()); // logs 7.71234e+1console.log(numObj.toExponential(4)); // logs 7.7123e+1 소수점 이하 4자리를 표시하라console.log(numObj.toExponential(2)); // logs 7.71e+1console.log((77.1234).toExponential()); // logs 7.71234e+1console.log(77 .toExponential()); // logs 7.7e+1 스페이스를 띄어야지 된다. 3.6 Number.prototype.toFixed() 매개변수로 지정된 소숫점자리를 반올림하여 문자열로 반환한다. 12345678910111213numObj.toFixed([digits])// digits: 0~20 사이의 정수값으로 소숫점 이하 자릿수를 나타낸다. 기본값은 0이며 옵션으로 생략 가능하다.var numObj = 12345.6789;numObj.toFixed(); // '12346': 소수점 이하를 반올림numObj.toFixed(1); // '12345.7' 소수점 1자리를 유지numObj.toFixed(6); // '12345.678900' 소수점 6자리를 유지(1.23e+20).toFixed(2); // '123000000000000000000.00'(1.23e-10).toFixed(2); // '0.00': 0.00000001의 소수점 2자리 이후를 반올림2.34.toFixed(1); // '2.3'2.35.toFixed(1); // '2.4'. Note that it rounds up in this case.-2.34.toFixed(1); // -2.3: 가로 안에 음수를 넣어두지 않으면 문자열을 반환하지 않는다(-2.34).toFixed(1); // '-2.3' 3.7 Number.prototype.toPrecision() 매개변수로 지정된 전체 자릿수까지 유효하도록 나머지 자릿수를 반올림하여 문자열로 반환한다. 지정된 전체 자릿수로 표현할 수 없는 경우 지수 표기법으로 결과를 반환한다. 12345678910numObj.toPrecision([precision])// precision: 1~21 사이의 정수값으로 전체 자릿수를 나타낸다. 옵션으로 생략 가능하다.var numObj = 5.123456;numObj.toPrecision() // '5.123456'numObj.toPrecision(5) // '5.1235' // 전체 자리수를 나타낸다.numObj.toPrecision(2) // '5.1'numObj.toPrecision(1) // '5'(1234.5).toPrecision(2) // `1.2e+3` 3.8 Number.prototype.toString() 숫자를 문자열로 변환하여 반환한다. 12345678910111213141516numObj.toString([radix])// radix: 2~36 사이의 정수값으로 진법을 나타낸다. 옵션으로 생략 가능하다.var count = 10;console.log(count.toString()); // '10'console.log((17).toString()); // '17'console.log(17 .toString()); // '17'console.log((17.2).toString()); // '17.2'var x = 16;console.log(x.toString(2)); // '10000' 2진수console.log(x.toString(8)); // '20' 8진수console.log(x.toString(16)); // '10' 16진수로console.log((254).toString(16)); // 'fe'console.log((-10).toString(2)); // '-1010'console.log((-0xff).toString(2)); // '-11111111' 3.9 Number.prototype.valueOf() Number 객체의 기본자료형 값(primitive value)을 반환한다. 123456789numObj.valueOf()var numObj = new Number(10);console.log(typeof numObj); // objectvar num = numObj.valueOf();console.log(num); // 10console.log(typeof num); // number Number를 String로 바꾸는 방법 1.’’+num 2.toString사용 3.String(num) new를 사용하지않고 만든다. 쓰지말것. String을 Number로 바꾸는 방법 1.1 str ex) 1‘12’ 단 str이 숫자로 변환될 수 있다는 전재 2.parseInt 3.Number(str)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Number","slug":"JavaScript/Number","permalink":"http://yoursite.com/categories/JavaScript/Number/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Number","slug":"Number","permalink":"http://yoursite.com/tags/Number/"}]},{"title":"JavaScript Object Oriented Programming","slug":"js-study-OOP","date":"2017-08-08T03:54:00.000Z","updated":"2017-11-13T00:57:52.000Z","comments":true,"path":"2017/08/08/js-study-OOP/","link":"","permalink":"http://yoursite.com/2017/08/08/js-study-OOP/","excerpt":"","text":"JavaScript Object Oriented Programming1. 객체지향 프로그래밍(Object-Oriented Programming) 개요 객체지향형이란? 객체의 핵심적인 개념 또는 기능만을 추출하는 추상화(abstraction)를 통해 모델링하려는 프로그래밍 패러다임을 말한다. 프로퍼티를 통해서 확인한다. 객체는 데이터(멤버변수)와 행위(method)를 가지고 있다고 표현한다. 사물을 인식할때 특성을 구분하고 그 특성에 값을 매긴것처럼 객체도 이렇게 만든다. 상속을 통하여 비교하려는 대상중 큰 대상에게 작은 대상을 포함시킨다. 동물에 사람이 포함된다. 상속은 유지보수 및 성능 향상에 도움이 된다. 캡슐화를 통해서 비공개를 할 정보를 감춘다. this는 method, 생성자 함수에서만 사용하는 것이 좋다. 2. 클래스 기반 vs. 프로토타입 기반2.1 클래스 기반 언어 클래스 기반언어는 클래스로 객체의 자료구조와 기능을 정의하고 생성자를 통해 인스턴스를 생성한다. 객체를 생성한 이후에 프로퍼티를 변경할 수 없다. 2.2 프로토타입 기반 언어 자바스크립트는 명령형(절차적), 함수형, 프로토타입 기반 객체지향 언어이다. 자바스크립트는 클래스 개념이 없고 별도의 객체 생성 방법이 존재한다. 객체 리터럴 object() 생성자함수 생성자 함수 객체를 생성한 이후에도 프로퍼티를 변경할 수 있다. 익숙한 클래스 기반의 언어를 사용할 수 없다. ES6로 클래스형으로 만들고 바벨이라는 것으로 ES5으로 변경하면된다. 123456789101112// 객체 리터럴var obj1 = &#123;&#125;;obj1.name = 'Lee';// Object() 생성자 함수var obj2 = new Object();obj2.name = 'Lee';// 생성자 함수function F() &#123;&#125;var obj3 = new F();obj3.name = 'Lee'; 자바스크립트는 객체가 생성된 이후에 인스턴스(프로퍼티)를 동적으로 변경할 수 있다. 3. 생성자 함수와 인스턴스의 생성1234567891011121314151617181920212223// 생성자 함수(Constructor)function Person(name) &#123; // 프로퍼티 =&gt; this는 생성자 함수가 생성하는 객체를 가리킨다. this.name = name; // 메소드 this.setName = function (name) &#123; this.name = name; &#125;; // 메소드 this.getName = function () &#123; return this.name; &#125;;&#125;// 인스턴스의 생성var me = new Person('Lee');console.log(me.getName()); // Lee// 메소드 호출me.setName('Kim');console.log(me.getName()); // Kim 이렇게 생성하면 안되고 메소드를 프로토타입에다가 생성해야한다. 4. 프로토타입 체인과 메소드의 정의123456789101112131415161718192021222324function Person(name) &#123; this.name = name;&#125;// 프로토타입 객체에 메소드 정의Person.prototype.setName = function (name) &#123; this.name = name;&#125;;// 프로토타입 객체에 메소드 정의Person.prototype.getName = function () &#123; return this.name;&#125;;var me = new Person('Lee');var you = new Person('Kim');var him = new Person('choi');console.log(Person.prototype); // Person &#123; setName: [Function], getName: [Function] &#125;console.log(me); // Person &#123; name: 'Lee' &#125;console.log(you); // Person &#123; name: 'Kim' &#125;console.log(him); // Person &#123; name: 'choi' &#125; 프로포타입 체인과 메소드의 정의 Person.prototype위치에 새로운것을 같다가 바꿔보는것에 대해서 상속패턴이 나왔으며 상속패턴의 문제점은 밑에서 설명한다. 더글라스 크락포드가 제안한 프로토타입 객체에 메소드를 추가하는 방식이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 모든 생성자 함수의 프로토타입은 Function.prototype이다. 따라서 모든 생성자 함수는 Function.prototype.method()에 접근할 수 있다. * @method Function.prototype.method * @param (&#123;string&#125;) (name) - (메소드 이름) * @param (&#123;function&#125;) (func) - (추가할 메소드 본체) */Function.prototype.method = function (name, func) &#123; // 생성자함수의 프로토타입에 동일한 이름의 메소드가 없으면 생성자함수의 프로토타입에 메소드를 추가 // this: 생성자함수 if (!this.prototype[name]) &#123; this.prototype[name] = func; &#125;&#125;;/** * 생성자 함수 */function Person(name) &#123; this.name = name;&#125;/** * 생성자함수 Person의 프로토타입에 메소드 setName을 추가 */Person.method('setName', function (name) &#123; this.name = name;&#125;);/** * 생성자함수 Person의 프로토타입에 메소드 getName을 추가 */Person.method('getName', function () &#123; return this.name;&#125;);var me = new Person('Lee');var you = new Person('Kim');var him = new Person('choi');console.log(Person.prototype);// Person &#123; setName: [Function], getName: [Function] &#125;console.log(me); // Person &#123; name: 'Lee' &#125;console.log(you); // Person &#123; name: 'Kim' &#125;console.log(him); // Person &#123; name: 'choi' &#125; 5. 상속(Inheritance) 이것은 프로토타입을 통해 객체가 다른 객체로 직접 상속된다는 의미이다. 5.1 의사 클래스 패턴 상속 (Pseudo-classical Inheritance) 문제가 발생하여서 프로토타입 패턴 상속 (Prototypal Inheritance)을 사용한다. 의사 클래스 패턴은 자식 생성자 함수의 prototype 프로퍼티를 부모 생성자 함수의 인스턴스로 교체하여 상속을 구현하는 방법이다. 부모와 자식 모두 생성자 함수를 정의하여야 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 부모 생성자 함수var Parent = (function () &#123; // Constructor function Parent(name) &#123; this.name = name; &#125; // method Parent.prototype.sayHi = function () &#123; console.log('Hi! ' + this.name); &#125;; // return constructor return Parent;&#125;());// 자식 생성자 함수var Child = (function () &#123; // Constructor function Child(name) &#123; this.name = name; &#125; // 자식 생성자 함수의 프로토타입 객체를 부모 생성자 함수의 인스턴스로 교체. Child.prototype = new Parent(); // ② // 메소드 오버라이드 Child.prototype.sayHi = function () &#123; console.log('안녕하세요! ' + this.name); &#125;; // sayBye 메소드는 Parent 생성자함수의 인스턴스에 위치된다 Child.prototype.sayBye = function () &#123; console.log('안녕히가세요! ' + this.name); &#125;; // return constructor return Child;&#125;());var child = new Child('child'); // ①console.log(child); // Parent &#123; name: 'child' &#125;console.log(Child.prototype); // Parent &#123; name: undefined, sayHi: [Function], sayBye: [Function] &#125;child.sayHi(); // 안녕하세요! childchild.sayBye(); // 안녕히가세요! childconsole.log(child instanceof Parent); // trueconsole.log(child instanceof Child); // true.log(child instanceof Parent); // true 부작용 발생 3가지 1.new 연산자를 통해 인스턴스를 생성한다. 2.생성자 링크의 파괴 child객체의 constructor가 Parent가 나온다. why? new Parent()라서 prototype이 아니라서 consturctor가 없어서 Parent.prototype을 가서 실행하기 때문이다. 3.객체리터럴 객체 의사 클래스 패턴은 자체가 안된다. why? object.prototype을 교체하면 전체가 영향을 받기때문에 변경할 수 없다. 즉시실행함수는 어떤값을 return하는지를 먼저 봐야한다. 의사 클래스 패턴 상속 5.2 프로토타입 패턴 상속 (Prototypal Inheritance) 프로토타입 패턴 상속은 Object.create 함수를 사용하여 객체에서 다른 객체로 직접 상속을 구현하는 방식이다. object.create(proto[, propertiesOnject]) =&gt; 부모로 지정할 것을 써준다. var child = Object.create(Parent.prototype); 의사 클래스 패턴 상속의 부작용을 다 방지한다. 바벨로 만들어 줄 수 있다. 1234567891011121314151617181920212223// 부모 생성자 함수var Parent = (function () &#123; // Constructor function Parent(name) &#123; this.name = name; &#125; // method Parent.prototype.sayHi = function () &#123; console.log('Hi! ' + this.name); &#125;; // return constructor return Parent;&#125;());// create 함수의 인수는 프로토타입이다. var child = Object.create(Parent.prototype);child.name = 'child';child.sayHi(); // Hi! childconsole.log(child instanceof Parent); // true 프로토타입 패턴상속: 생성자 함수 객체리터럴 패턴으로 생성한 객체에도 프로토타입 패턴 상속을 사용할 수 있다. var child = Object.create(parent); 1234567891011121314151617var parent = &#123; name: 'parent', sayHi: function() &#123; console.log('Hi! ' + this.name); &#125;&#125;;// create 함수의 인자는 객체이다. var child = Object.create(parent);child.name = 'child';// var child = Object.create(parent, &#123;name: &#123;value: 'child'&#125;&#125;);parent.sayHi(); // Hi! parentchild.sayHi(); // Hi! childconsole.log(parent.isPrototypeOf(child)); // true 프로토타입 패턴상속: 객체 리터럴 IE9이상에서만 Object.create명령어가 된다. 밑에 버전을 대응하기 위해서 방어코드를 통하여 만들어야한다. 12345678// Object.create 함수의 폴리필if (!Object.create) &#123; Object.create = function (o) &#123; function F() &#123;&#125; // 1 빈객체를 반환하는 생성자 함수 F.prototype = o; // 2 생성자 함수가 생성할 객체의 prototype에 o를 넣는다. return new F(); // 3 &#125;;&#125; 위 폴리필은 프로토타입 패턴 상속의 핵심을 담고 있다. 1.비어있는 생성자 함수 F를 생성한다. 2.생성자 함수 F의 prototype 프로퍼티에 매개변수로 전달받은 객체를 할당한다. 3.생성자 함수 F를 생성자로 하여 새로운 객채를 생성하고 반환한다. Object.create 함수의 폴리필 프레임워크를 사용해서 상속을 지정해주겠지만 기본적으로 javascript의 상속구조를 이해하기위해서 공부를 해야한다. 6. 캡슐화(Encapsulation)와 모듈 패턴(Module Pattern) 공개할 프로퍼티는 공개하고 비공개적인 프로퍼티를 감추기 위해서 캡슐화를한다. this로 묶이면 기본적으로 public이며 var로 묶이면 private처럼 사용된다. 12345678910111213141516171819202122var Person = function(arg) &#123; var name = arg ? arg : ''; // ① this.getName = function() &#123; return name; &#125;; this.setName = function(arg) &#123; name = arg; &#125;;&#125;var me = new Person('Lee');var name = me.getName();console.log(name);me.setName('Kim');name = me.getName();console.log(name); 모듈 패턴 클로저를 사용하여서 생성자함수가아닌 함수로 만들어낸다. 필요한 메소드만 담아서 return으로 넘긴다. 즉 공개하고 싶은것만 넘기고 아닌것은 외부함수가 위치한 곳에 작성한다. 1234567891011121314151617181920212223var person = function(arg) &#123; var name = arg ? arg : ''; // 외부함수 return &#123; // 객체시작 getName: function() &#123; return name; &#125;, setName: function(arg) &#123; name = arg; // 내부함수 -&gt; 내부함수가 외부함수보다 오래유지된다 클로저이다. &#125; &#125; // 객체 끝&#125;var me = person('Lee'); /* or var me = new person('Lee'); */var name = me.getName();console.log(name);me.setName('Kim');name = me.getName();console.log(name); 모듈 패턴의 문제점1 : private 멤버가 객체나 배열일 경우, 반환된 해당 멤버의 변경이 가능하다. 객체는 참조형이라서 외부에 반환이 될때 그 객체를 수정을하면 객체가 변경되는 문제이다. 123456789101112131415161718192021var person = function (personInfo) &#123; var o = personInfo; return &#123; getPersonInfo: function() &#123; return o; &#125; &#125;;&#125;;var me = person(&#123; name: 'Lee', gender: 'male' &#125;);var myInfo = me.getPersonInfo();console.log('myInfo: ', myInfo);// myInfo: &#123; name: 'Lee', gender: 'male' &#125;myInfo.name = 'Kim';myInfo = me.getPersonInfo();console.log('myInfo: ', myInfo);// myInfo: &#123; name: 'Kim', gender: 'male' &#125; 반환하는 값을 copy해서 사용되게한다. json이나 object.assign을 사용해서 해결한다. 객체를 반환하는 경우 반환값은 얕은 복사(shallow copy)로 private 멤버의 참조값을 반환하게 된다. object.assign을 통하여 깊은 복사를 하여서 반환한다 (찾아보기) 모듈 패턴의 문제점2 : 상속이 안된다. 함수를 return해줘야지 상속문제가 해결이된다. 상속을 사용하는 모듈패턴에서 가장 바른방법이다. 123456789101112131415161718192021222324var Person = function() &#123; var name; var F = function(arg) &#123; name = arg ? arg : ''; &#125;; F.prototype = &#123; getName: function() &#123; return name; &#125;, setName: function(arg) &#123; name = arg; &#125; &#125;; return F;&#125;();var me = new Person('Lee');console.log(Person.prototype === me.__proto__);console.log(me.getName());me.setName('Kim')console.log(me.getName()); 과연 모듈패턴이 올바른방법 인가에 대한 생각이 든다. ES6를 사용하여서 바벨을 사용하여라.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"OOP","slug":"JavaScript/OOP","permalink":"http://yoursite.com/categories/JavaScript/OOP/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"OOP","slug":"OOP","permalink":"http://yoursite.com/tags/OOP/"}]},{"title":"JavaScript Standard Built In Object","slug":"js-study-standard-built-in-object","date":"2017-08-08T03:54:00.000Z","updated":"2017-11-13T00:59:02.000Z","comments":true,"path":"2017/08/08/js-study-standard-built-in-object/","link":"","permalink":"http://yoursite.com/2017/08/08/js-study-standard-built-in-object/","excerpt":"","text":"JavaScript Standard Built In Object 1. Global Object 전역 객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window, Server-side(Node.js)에서는 global 객체를 의미한다. 123456// in browser consolethis === window // true// in Terminalnodethis === global // true 전역 객체는 실행 컨텍스트에 컨트롤이 들어가기 이전에 생성이 되며 constructor가 없기 때문에 new 연산자를 이용하여 새롭게 생성할 수 없다. 즉, 개발자가 전역 객체를 생성하는 것은 불가능하다. 전역 객체는 전역 스코프(Global Scope)를 갖게 된다. 전역 객체의 자식 객체를 사용할 때 전역 객체의 기술은 생략할 수 있다. 예를 들어 document 객체는 전역 객체 window의 자식 객체로서 window.document…와 같이 기술하여도 좋으나 일반적으로 전역 객체의 기술은 생략한다. 12document.getElementById('foo').style.display = 'none';// window.document.getElementById('foo').style.display = 'none'; 그러나 사용자가 정의한 변수와 전역 객체의 자식 객체 이름이 충돌할 때 명확히 명확히 전역 객체를 기술하여 혼동을 방지할 수 있다. 1234567function moveTo(url) &#123; var location = &#123;'href':'move to '&#125;; alert(location.href + url); // location.href = url; window.location.href = url; // BOM에 들어 있는 location이다.&#125;moveTo('http://www.google.com'); 전역 객체는 전역 변수(Global variable)를 프로퍼티로 가지게 된다. 123var ga = 'Global variable';console.log(ga);console.log(window.ga); 글로벌 영역에 선언한 함수도 전역 객체의 프로퍼티로 접근할 수 있다. 1234function foo() &#123; console.log('invoked!');&#125;window.foo(); Standard Built-in Objects(표준 빌트인 객체)도 역시 전역 객체의 자식 객체이다. 전역 객체의 자식 객체를 사용할 때 전역 객체의 기술은 생략할 수 있으므로 표준 빌트인 객체도 전역 객체의 기술을 생략할 수 있다. 12// window.alert('Hello world!');;alert('Hello world!'); 1.1 Global property (전역 프로퍼티)1.1.1 Infinity 양/음의 무한대를 나타내는 숫자값이다. 1234console.log(3/0); // Infinityconsole.log(-3/0); // -Infinityconsole.log(Number.MAX_VALUE * 2); // 1.7976931348623157e+308 * 2 // Infinity로 나온다.console.log(typeof Infinity); // number 1.1.2 NaN 숫자가 아님(Not-a-Number)을 나타내는 숫자값이다. 전역개체의 NaN 프로퍼티는 Number.NaN 프로퍼티와 같다. 123console.log(Number('xyz')); // NaNconsole.log(1 * 'string'); // NaNconsole.log(typeof NaN); // number 1.1.3 undefined 변수에 값이 대입되지 않았음을 나타내는 값이다. 초기값은 기본 자료형(primitive data type) undefined이다. 123var foo;console.log(foo); // undefinedconsole.log(typeof undefined); // undefined 1.2 Global function (전역 함수) Global function(전역 함수)는 전역에서 호출할 수 있으며 호출한 곳(caller)으로 결과값을 반환한다. Global function(전역 함수)는 모두 Global Object(전역 객체)의 함수 프로퍼티이다. 1.2.1 eval() 사용자로 부터 입력받은 Contents(untrusted data)를 eval()로 실행하는 것은 보안에 매우 취약하다. 1234567eval(string)// string: code 또는 표현식을 나타내는 문자열. 표현식은 존재하는 객체들의 프로퍼티들과 변수들을 포함할 수 있다.var foo = eval('2 + 2');var x = 5, y = 4;console.log(foo); // 4console.log(eval('x * y')); // 20 1.2.2 isFinite() 매개변수(parameter)로 전달된 값이 유한수인지, 정상적인 수인지를 검사하여 그 결과를 Boolean으로 반환한다. 매개변수가 숫자가 아닌 경우, 숫자로 변환한 후 검사를 수행한다. 12345678910111213isFinite(testValue)// testValue: 검사 대상 값console.log(isFinite(Infinity)); // falseconsole.log(isFinite(NaN)); // falseconsole.log(isFinite('Hello')); // falseconsole.log(isFinite('2005/12/12')); // falseconsole.log(isFinite(0)); // trueconsole.log(isFinite(2e64)); // trueconsole.log(isFinite(null)); // true: null-&gt;0Number(null) // 0 null을 Number로 형변환 시도Boolean(null) // false null을 Boolean로 형변환 시도 숫자가 아닌놈이 오면 무조건 false이다. 상태를 알려주는 녀석은 is를 사용한다. 1.2.3 isNaN() NaN이 들어오면 true, 아니면 false이다. 1234567891011121314151617181920isNaN(testValue)// testValue: 검사 대상 값isNaN(NaN) // trueisNaN(undefined) // true: undefined -&gt; NaNisNaN(&#123;&#125;) // true: &#123;&#125; -&gt; NaNisNaN('blabla') // true: 'blabla' -&gt; NaNisNaN(true) // false: true -&gt; 1isNaN(null) // false: null -&gt; 0isNaN(37) // false// stringsisNaN('37') // false: '37' -&gt; 37isNaN('37.37') // false: '37.37' -&gt; 37.37isNaN('') // false: '' -&gt; 0isNaN(' ') // false: ' ' -&gt; 0// datesisNaN(new Date()) // false: new Date() -&gt; NumberisNaN(new Date().toString()) // true: String -&gt; NaN 두수를 비교를 할 때 수인지 아닌지 isNaN으로 비교해준다. 1.2.4 parseFloat() 매개변수(parameter)로 전달된 문자열을 부동소수점숫자(floating point number)로 변환하여 반환한다. 12345678parseFloat(string)// string: 변환 대상 문자열parseFloat('3.14'); // 3.14parseFloat('10.00'); // 10parseFloat('34 45 66'); // 34parseFloat(' 60 '); // 60parseFloat('40 years'); // 40parseFloat('He was 40') // NaN 매개변수 문자열의 첫 숫자만 반환되며 전후 공백은 무시된다. 그리고 첫문자를 숫자로 변환할 수 없다면 NaN을 반환한다. 1.2.5 parseInt() 매개변수(parameter)로 전달된 문자열을 정수형 숫자(Integer)로 변환하여 반환한다. 1234567891011121314parseInt(string, radix);// string: 변환 대상 문자열// radix: 진법을 나타내는 기수(2 ~ 36, 기본값 10)parseInt('10'); // 10parseInt('10.33'); // 10parseInt('34 45 66'); // 34parseInt(' 60 '); // 60parseInt('40 years'); // 40parseInt('He was 40') // NaNparseInt('0x20'); // 32parseInt('10', 16); // 16 parseInt('10', 8); // 8 1.2.6 encodeURI() / decodeURI() encodeURI()은 매개변수로 전달된 URI(Uniform Resource Identifier)를 인코딩한다. 1234567891011encodeURI(URI)// URI: 완전한 URIdecodeURI(encodedURI)// encodedURI: 인코딩된 완전한 URIvar uri = 'http://www.test.com/자바스크립트/test.php?who=나&amp;target=너#전역 객체';var enc = encodeURI(uri);var dec = decodeURI(enc);console.log(enc);// http://www.test.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/test.php?who=%EB%82%98&amp;target=%EB%84%88#%EC%A0%84%EC%97%AD%20%EA%B0%9D%EC%B2%B4console.log(dec);// http://www.test.com/자바스크립트/test.php?who=나&amp;target=너#전역 객체 1.2.7 encodeURIComponent() / decodeURIComponent() encodeURIComponent()은 매개변수로 전달된 URI(Uniform Resource Identifier) component(구성 요소)를 인코딩한다. 일부분만 띄어서 encode한다. 단 아래의 문자는 이스케이프 처리에서 제외된다. 알파벳, 0~9의 숫자, - _ . ! ~ * ‘ ( ) encodeURIComponent()는 인수를 쿼리스트링의 일부라고 간주한다. 따라서 =, ?, &amp;를 인코딩한다. 반면 encodeURI()는 인수를 URI 전체라고 간주하며 파라미터 구분자인 =, ?, &amp;를 인코딩하지 않는다. 1234567891011encodeURIComponent(URI)// URI: URI component(구성 요소)decodeURIComponent(encodedURI)// encodedURI: 인코딩된 URI component(구성 요소)var uriComp = 'who=나&amp;target=너#전역 객체';var enc = encodeURIComponent(uriComp);var dec = decodeURIComponent(enc);console.log(enc);// who=%EB%82%98&amp;target=%EB%84%88#%EC%A0%84%EC%97%AD%20%EA%B0%9D%EC%B2%B4console.log(dec);// who=나&amp;target=너#전역 객체 2. Standard Built-in Objects (Global objects) Javascript는 프로그램 전체의 영역에서 공통적으로 필요한 기능을 사용자 각자가 일일히 작성하는 수고를 줄이기 위해 Standard Built-in Objects(표준 빌트인 객체)를 제공한다. 2.1 Object 객체 생성자(Object constructor)는 레퍼(wrapper) 객체를 생성한다. 만약 생성자 인수값이 null이거나 undefined이면 빈 객체를 반환한다. 123456789// 변수 o에 빈 객체를 저장한다var o = new Object();console.log(typeof o + ': ', o);o = new Object(undefined); // 빈객체 생성console.log(typeof o + ': ', o);o = new Object(null); // 빈객체 생성console.log(typeof o + ': ', o); 생성자 함수의 인수값에 따라 강제 형변환된 객체가 반환된다. 123456789101112131415161718192021222324// String 객체를 반환한다// var o = new String('String');과 동치이다var obj = new Object('String');console.log(typeof obj + ': ', obj);console.dir(obj);var strObj = new String('String');console.log(typeof strObj + ': ', strObj);// Number 객체를 반환한다// var o = new Number(123);과 동치이다var obj = new Object(123);console.log(typeof obj + ': ', obj);var numObj = new Number(123);console.log(typeof numObj + ': ', numObj);// Boolean 객체를 반환한다.// var o = new Boolean(true);과 동치이다var obj = new Object(true);console.log(typeof obj + ': ', obj);var boolObj = new Boolean(123);console.log(typeof boolObj + ': ', boolObj); 객체를 생성할 경우 특수한 상황이 아니라면 객체리터럴 방식을 사용하는 것이 일반적이다. var o = {}; 2.2 Function 자바스크립트의 모든 함수는 Function 객체이다. 다른 모든 객체들처럼 Function 객체는 new 연산자을 사용해 생성할 수 있다. 2.3 Boolean Boolean 객체는 기본자료형 boolean을 위한 레퍼(wrapper) 객체이다. Boolean 생성자 함수로 Boolean 객체를 생성할 수 있다. 1234var x = new Boolean(false);if (x) &#123; // x는 객체로서 존재한다. 따라서 참으로 간주된다. // . . . 이 코드는 실행된다.&#125; x자체가 false라는 값을 가지는 객체가 생성되기에 코드가 실행된다. 2.4 Number Number 2.5 Math Math 2.6 Date Date 2.7 String String 2.8 RegExp RegExp 2.9 Array Array 2.10 Error Error 생성자는 error 객체를 생성한다. error 객체의 인스턴스는 런타임 에러가 발생하였을 때 throw된다. 123456try &#123; // foo(); throw new Error('Whoops!');&#125; catch (e) &#123; console.log(e.name + ': ' + e.message);&#125; 요청의 실패할경우 에러메세지를 사전에 약속을 해둬야한다. Error 이외에 Error에 관련한 객체는 아래와 같다. EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError 2.11 Symbol Symbol은 ECMAScript 6(Javascript 2015) 에서 추가된 유일하고 변경 불가능한(immutable) 기본자료형으로 Symbol 객체는 기본자료형 Symbol을 위한 레퍼(wrapper) 객체를 생성한다. 3. 기본자료형과 래퍼객체 (Wrapper Object) Standard Built-in Object는 각자의 프로퍼티와 메소드를 가진다. 정적(static) 프로퍼티, 메소드는 해당 인스턴스를 생성하지 않아도 사용할 수 있고 prototype에 속해있는 메소드는 해당 prototype을 상속받은 인스턴스가 있어야만 사용할 수 있다. 그런데 기본자료형의 값에 대해 Standard Built-in Object의 메소드를 호출하면 정상적으로 작동한다. 123456var str = 'Hello world!';var res = str.toUpperCase();console.log(res); // 'HELLO WORLD!'var num = 1.5;console.log(num.toFixed()); // 2 기본자료형의 값에 대해 Standard Built-in Object의 메소드를 호출할 때, 기본자료형의 값은 연관된 객체(Wrapper 객체)로 일시 변환 되기 때문에 가능한 것이다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Built In Object","slug":"JavaScript/Built-In-Object","permalink":"http://yoursite.com/categories/JavaScript/Built-In-Object/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Built In Object","slug":"Built-In-Object","permalink":"http://yoursite.com/tags/Built-In-Object/"}]},{"title":"JavaScript Math","slug":"js-study-Math","date":"2017-08-08T03:54:00.000Z","updated":"2017-11-13T00:53:05.000Z","comments":true,"path":"2017/08/08/js-study-Math/","link":"","permalink":"http://yoursite.com/2017/08/08/js-study-Math/","excerpt":"","text":"JavaScript Math 1. Math Property 정적(static) 프로퍼티로 Math 객체를 생성할 필요없이 Math.propertyName의 형태로 사용한다. 대문자로 써져있으면 상수이다 즉 변하면 안되는 값이다. Math는 생성자 함수가 아닌 객체이다. 객체라서 prototype이 존재하지 않는다. 1.1 Math,PI PI 값(π ≈ 3.141592653589793)을 반환한다. 1PI 값(π ≈ 3.141592653589793)을 반환한다. 2. Math Method2.1 Math.abs() 절대값을 반환한다. 12345Math.abs('-1'); // 1Math.abs(-2); // 2Math.abs(null); // 0Math.abs('string'); // NaNMath.abs(); // NaN 2.2 Math.round() 숫자를 가장 인접한 정수로 반올림한다. 12345678910111213var x;// Returns the value 20x = Math.round(20.49);// Returns the value 21x = Math.round(20.5);// Returns the value -20x = Math.round(-20.5);// Returns the value -21x = Math.round(-20.51); 2.3 Math.sqrt() 양의 제곱근을 반환한다. 1Math.sqrt(9); // 3 2.4 Math.ceil() 지정된 숫자를 자신보다 큰, 가장 가까운 정수로 올림한다. 1Math.ceil(1.4); // 2 2.5 Math.floor() 지정된 숫자를 자신보다 작은, 가장 가까운 정수로 내림한다. 1Math.floor(1.6); // 1 2.6 Math.random() 0과 1 사이의 임의의 숫자를 반환한다. 이때 0은 포함되지만 1은 포함되지 않는다. 1234Math.random();var randomNum = Math.floor((Math.random() * 10) + 1); // 1 ~ 10console.log(randomNum); 2.7 Math.pow() 첫번째 인수를 밑(base), 두번째 인수를 지수(exponent)로하여 거듭제곱을 반환한다. 123Math.pow(7, 2); // 49Math.pow(7, 3); // 343Math.pow(2, 10); // 1024 2.8 Math.max() 숫자 중 가장 최대수를 반환한다. 중요하게 사용된다. 1234567Math.max( 1, 2, 3 ); // 3var arr = [1, 2, 3];var max = Math.max.apply(null, arr); // 3 // ES6var max = Math.max(...arr); // 3 apply는 this의 호출 패턴으로써 사용된다. func.apply(thisArg, [argsArray])// thisArg: 함수 내부의 this에 바인딩할 객체// argsArray: 함수에 전달할 인자 배열 …은 spread연산자로써 array의 요소값을 (1,2,3)으로 풀어준다. 2.9 Math.min() 숫자 중 가장 최소수를 반환한다. 1234567Math.min( 1, 2, 3 ); // 1var arr = [1, 2, 3];var min = Math.min.apply(null, arr); // 1// ES6var min = Math.min(...arr); // 1","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Math","slug":"JavaScript/Math","permalink":"http://yoursite.com/categories/JavaScript/Math/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"JavaScript Closure","slug":"js-study-closure","date":"2017-08-07T03:54:00.000Z","updated":"2017-11-12T12:05:55.000Z","comments":true,"path":"2017/08/07/js-study-closure/","link":"","permalink":"http://yoursite.com/2017/08/07/js-study-closure/","excerpt":"","text":"Javascript Closure1. 클로저의 개념 클로저는 자바스크립트 고유의 개념이 아니라 함수를 일급 객체로 취급하는 함수형 언어(Functional language: Python, Haskell, Erlang, Perl, D, R…)에서 사용되는 중요한 특성이다. 클로저는 내부함수를 위한 외부함수의 지역변수가 외부함수에 의해 내부함수가 반환된 이후에도 life-cycle이 유지되는 것을 의미한다. 1234567function outerFunc() &#123; var x = 10; var innerFunc = function () &#123; console.log(x); &#125;; innerFunc();&#125;outerFunc(); 중첩된 함수의 scope 레퍼런스를 차례대로 저장하고 있는 Scope-chain을 자바스크립트 엔진이 검색하였기에 가능한 것이다 1.innerFunc 함수 내에서 변수 x를 검색한다. 검색이 실패하였다. 2.innerFunc 함수를 포함하는 외부 함수 outerFunc에서 변수 x를 검색한다. 검색이 성공하였다. 12345678function outerFunc() &#123; var x = 10; var innerFunc = function () &#123; console.log(x); &#125;; return innerFunc;&#125;var inner = outerFunc(); // 클로저의 형성inner(); // 10 클로저란? 위의 예제는 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우인데 이때 내부함수가 외부함수의 지역변수에 접근 할 수 있고, 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며 내부함수에 의해서 소멸하게 되는 특성을 나타낸다. 클로저에 의해 참조되는 외부함수의 변수 즉 outerFunc 함수의 변수 x를 자유변수(Free variable)라고 부른다. 클로저라는 이름은 자유변수에 함수가 닫혀있다(closed)라는 의미로 의역하면 자유변수에 엮여있는 함수라는 뜻이다. 실행 컨텍스트의 관점에 설명하면, 내부함수가 유효한 상태에서 외부함수가 종료하여 외부함수의 실행 컨텍스트가 반환되어도, 외부함수 실행 컨텍스트 내의 Activation object(변수, 함수정의 등의 정보를 가지고 있다)는 유효하여 내부함수가 Scope-chain을 통해 참조할 수 있는 것을 의미한다. 실행 컨텍스트의 Activation object와 클로저 2. 클로저의 활용 클로저는 자바스크립트의 강력한 기능이기는 하나 성능적인 면과 자원적인 면에서 손해를 볼 수 있다. 2.1 전역 변수의 사용 억제 클로저의 필요성을 이해하기 위해서, 버튼이 클릭될 때마다 클릭한 횟수가 누적되어 화면에 표시되는 코드를 만들어보자. 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;전역 변수를 사용한 Counting&lt;/p&gt; &lt;button type=\"button\" onclick=\"myFunction()\"&gt;Count!&lt;/button&gt; &lt;p id=\"demo\"&gt;0&lt;/p&gt; &lt;script&gt; var counter = 0; function add() &#123; return counter += 1; &#125; function myFunction()&#123; document.getElementById('demo').innerHTML = add(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 코드는 잘 동작한다. 하지만 add 함수만을 위한 전역 변수 counter를 사용하고 있다. 전역 변수는 누구나 접근할 수 있어 의도하지 않게 변수명이 중복되거나 값이 변경되었을 때 문제가 될 수 있다. 그럼 전역 변수 counter를 add 함수의 지역 변수로 바꾸어보자. 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;지역 변수를 사용한 Counting&lt;/p&gt; &lt;button type=\"button\" onclick=\"myFunction()\"&gt;Count!&lt;/button&gt; &lt;p id=\"demo\"&gt;0&lt;/p&gt; &lt;script&gt; function add() &#123; var counter = 0; return counter += 1; &#125; function myFunction()&#123; document.getElementById('demo').innerHTML = add(); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 클로저를 통한 문제해결코드 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;p&gt;클로저를 사용한 Counting&lt;/p&gt; &lt;button type=\"button\" onclick=\"myFunction()\"&gt;Count!&lt;/button&gt; &lt;p id=\"demo\"&gt;0&lt;/p&gt; &lt;script&gt; var add = (function () &#123; var counter = 0; return function () &#123; return counter += 1; &#125; &#125;)(); function myFunction()&#123; document.getElementById('demo').innerHTML = add(); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 변수 add에는 즉시실행함수(immediately-invoked function expression)가 호출되어 그 결과 무명함수 function () {return counter += 1;}반환된다. 즉시실행함수는 한번만 실행되므로 add에 담겨있는 함수가 호출될 때마다 변수 counter가 재차 초기화될 일은 없을 것이다 중요한 것은 add에 담겨있는 함수는 변수 counter에 접근할 수 있고 변수 counter는 add에 담겨있는 함수가 소멸될 때가지 유지된다는 것이다. 이것이 바로 클로저이다. 변수 counter는 외부에서 직접 접근할 수 없는 private 변수이므로 전역 변수를 사용했을 때와 같이 의도되지 않은 변경을 걱정할 필요도 없다. 2.2 setTimeout()의 콜백 함수 setTimeout() 함수는 첫번째 parameter에 콜백 함수를 전달하고, 두번째 parameter에 시간 간격(ms: 1000분의 1초)을 지정한다. 즉 지정된 시간 간격으로 콜백 함수를 호출한다. 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;새로고침으로 다시 실행해 보세요&lt;/p&gt; &lt;script&gt; var fade = function (node) &#123; // 자유변수 var level = 1; // ② var step = function() &#123; var hex = level.toString(16); // ④ // hex: '1' ~ 'f' node.style.backgroundColor = '#ff' + hex; // ⑤ if(level &lt; 15) &#123; // ⑥ level += 1; setTimeout(step, 100); // ⑦ &#125; &#125;; // setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다. // 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다. setTimeout(step, 100); // ③ &#125;; fade(document.body); // ① &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ① 함수 fade는 document.body를 인자로 전달받아 호출된다. ② 함수 fade의 지역변수 level은 1로 초기화되어 있다. 함수 step은 내부함수이며 외부함수 fade의 지역변수 level을 사용한다. level은 자유변수이다. ③ setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다. 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다. ④ 함수 step은 지역변수 hex을 갖는다. 이것은 16진수 문자열을 값으로 갖는다. ⑤ 함수 fade의 매개변수 node(document.body)의 배경색을 변경한다. ⑥ 변수 level이 15(f)보다 작은지 다시말해 16진수 범위 내(1~f)인지 확인한다. ⑦ level을 1 증가시키고 다시 함수 step을 호출하여 같은 작업을 반복한다. 2.3 자주 발생하는 실수1234567891011var arr = [];for (var i = 0; i &lt; 5; i++) &#123; arr[i] = function () &#123; return i; &#125;;&#125;for (var index = 0; index &lt; arr.length; index++) &#123; console.log(arr[index]());&#125; 배열 arr에 5개의 함수가 할당되고 각각의 함수는 순차적으로 0, 1, 2, 3, 4를 반환할 것으로 기대하겠지만 결과는 그렇지않다. 이유는 변수 i는 외부함수의 변수가 아닌 전역 변수이기 때문이다. 바르게 동작하는 코드는 아래와 같다. 12345678910111213var arr = [];for (var i = 0; i &lt; 5; i++)&#123; arr[i] = (function (id) &#123; // ② return function () &#123; return id; // ③ &#125;; &#125;)(i); // ①&#125;for (var index = 0; index &lt; arr.length; index++) &#123; console.log(arr[index]());&#125; ① 배열 arr에는 즉시실행함수에 의해 함수가 반환된다. ② 이때 즉시실행함수는 i를 인자로 전달받고 매개변수 id에 할당한 후 내부 함수를 반환하고 life-cycle이 종료된다. 매개변수 id는 자유변수가 된다. ③ 배열 arr에 할당된 함수는 id를 반환한다. 이때 id는 상위 스코프의 자유변수이므로 그 값이 유지된다. 위 예제는 자바스크립트의 함수 레벨 스코프 특성으로 인해 for 루프의 초기문에서 사용된 변수의 스코프가 전역이 되기 때문에 발생하는 현상이다. ES6의 let 키워드를 사용하면 이와 같은 문제는 말끔히 해결된다. 1234567891011const arr = [];for (let i = 0; i &lt; 5; i++) &#123; arr[i] = function () &#123; return i; &#125;;&#125;for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]());&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Closure","slug":"JavaScript/Closure","permalink":"http://yoursite.com/categories/JavaScript/Closure/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Closure","slug":"Closure","permalink":"http://yoursite.com/tags/Closure/"}]},{"title":"JavaScript Excution Context","slug":"js-study-excution-context","date":"2017-08-07T03:54:00.000Z","updated":"2017-11-12T12:08:35.000Z","comments":true,"path":"2017/08/07/js-study-excution-context/","link":"","permalink":"http://yoursite.com/2017/08/07/js-study-excution-context/","excerpt":"","text":"Javascript Excution-Context1. 실행 컨텍스트 실행 컨텍스트는 실행 가능한 코드 블럭이 실행되는 환경이라고 말할수 있다. Global Code : 전역 영역에 존재하는 코드 Eval Code : Eval 함수로 실행되는 코드 Function Code : 함수 내에 존재하는 코드 실행 컨텍스트 : 실행에 필요한 여러가지 정보(실행 환경)를 관리하기 위한 객체 실행에 필요한 정보 변수 : 함수 내부에서만 접근할 수 있는 지역변수, 메소드에서 this를 통해 접근할 수 있는 객체의 프로퍼티 매개변수(parameter) 함수 선언 변수의 유효범위(Scope) this 123456789101112var x = 'xxx';function foo () &#123; var y = 'yyy'; function bar () &#123; var z = 'zzz'; console.log(x + y + z); &#125; bar();&#125;foo(); global 변수는 Data영역에 저장이된다. local 변수 stack영역에 저장되며 호출이 끝나면 사라진다.(함수와 다르다.) 컨트롤이 실행 가능한 코드로 이동하면 논리적 스택(Stack) 구조를 가지는 새로운 실행 컨텍스트 스택이 생성된다. 스택은 LIFO(Last In First Out, 후입 선출)의 구조를 가지는 나열 구조이다. Global code(전역 코드)로 컨트롤이 들어가면 전역 실행 컨텍스트가 실행 컨텍스트 스택에 쌓인다. 전역 실행 컨텍스트는 애플리케이션이 종료될 때(웹 페이지에서 나가거나 브라우저를 닫을 때)까지 유지된다. 함수를 호출하면 해당 함수의 실행 컨택스트가 생성되며 직전에 실행된 코드블럭의 실행 컨텍스트 위에 쌓인다. 함수 실행이 끝나면 해당 함수의 실행 컨텍스트를 파기하고 직전의 실행 컨텍스트에 컨트롤을 반환한다. 2. 실행 컨텍스트 객체의 프로퍼티 실행 컨텍스트(Excution context)는 객체이며 아래의 3가지 프로퍼티를 소유한다. Variable object : {vars, function declarations, arguments} Scope chain : [Variable object + all parent scopes] thisValue : Context object 2.1 Variable Object (VO / 변수객체) Variable Object(VO/변수 객체) : 실행 컨텍스트가 생성되면 자바스크립트 엔진은 실행에 필요한 여러 정보들을 담을 객체 Variable Object는 코드가 실행될 때 엔진에 의해 참조되며 코드에서는 접근할 수 없다. Variable Object의 정보 변수 매개변수(parameter)와 인수(argument), 함수 선언(함수 표현식은 제외) Variable Object가 가리키는 객체는 아래와 같다. 전역 컨텍스트의 경우Variable Object는 유일하며 최상위에 위치하고 모든 전역 변수, 전역 함수 등을 포함하는 전역 객체(GO)를 가리킨다. 전역 객체는 전역에 선언된 전역 변수와 전역 함수를 프로퍼티로 소유한다. 함수 컨텍스트의 경우Variable Object는 Activation Object(AO / 활성 객체)를 가리키며 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 객체인 arguments object가 추가된다. Q. 여기서 bar는 funxtion foo(){ bar(); }를 나타내는건가요? 2.2 Scope Chain(SC) Scope Chain은 일종의 리스트로서 중첩된 함수의 스코프의 레퍼런스를 차례로 저장하고 있는 개념이다. Scope Chain는 현재 실행 컨텍스트의 Activation Object를 선두로하여 순차적으로 상위 컨텍스트의 Activation Object를 가리키며 마지막 리스트는 전역 객체를 가리킨다. 함수 내의 코드에서 변수를 참조하면 엔진은 Scope Chain의 첫번째 리스트가 가리키는 AO에 접근하여 변수를 검색한다. 만일 검색에 실패하면 다음 리스트가 가리키는 Activation Object(또는 전역 객체)를 검색한다. 이와 같이 순차적으로 Scope Chain에서 변수를 검색하는데 결국 검색에 실패하면 정의되지 않은 변수에 접근하는 것으로 판단하여 Reference 에러를 발생시킨다. 스코프 체인은 [[scope]] 프로퍼티로 참조할 수 있다. Q. 1은 상위 scope를 가리키는건가요? 왜 global에서는 화살표가 가운데로가나요?? 2.3 this value this 프로퍼티에는 this 값이 할당된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정된다. 3. 실행 컨텍스트의 생성 과정12345678910111213var x = 'xxx';function foo () &#123; var y = 'yyy'; function bar () &#123; var z = 'zzz'; console.log(x + y + z); &#125; bar();&#125;foo(); 3.1 Global Code에의 진입 컨트롤이 실행 컨텍스트에 들어가기 이전에 유일한 전역 객체(Global Object)가 생성된다. 코드가 종료되면 전역 객체의 라이프 사이클은 끝이 난다. 코드의 어떠한 곳에서도 접근할 수 있다. 초기상태의 전역 객체에는 Built-in object(Math, String, Array 등)와 BOM, DOM이 Set 되어있다. 초기상태의 실행 컨텍스트 전역 객체가 생성된 이후, Global Code로 컨트롤이 이동하면 새로운 전역 실행 컨텍스트가 스택에 쌓인다. 전역 실행 컨텍스트의 생성 그리고 이후 이 실행 컨텍스트를 바탕으로 이하의 처리가 실행된다. Scope Chain의 생성과 초기화 Variable Instantiation 실행 this value 결정 3.1.1 Scope Chain의 생성과 초기화 새로운 실행 컨텍스트에 들어가게 되면 우선 Scope Chain의 생성과 초기화가 실행된다. Global Code로 컨트롤이 이동하면 Scope Chain는 전역 객체의 레퍼런스를 포함하는 리스트가 된다. Scope Chain의 생성과 초기화 Scope Chain에다가 0을 추가한다. 3.1.2 Variable Instantiation(변수 객체화) 실행 Scope Chain의 생성과 초기화가 끝나면 Variable Instantiation이 실행된다. Variable Instantiation은 Variable Object에 프로퍼티와 값을 추가하는 것을 의미한다.(변수 객체화) Global Code의 경우, Variable Object는 Global Object를 가리킨다. Variable Instantiation(변수 객체화): VO와 GO의 연결 Variable Instantiation (변수 객체화)는 아래의 순서로 Variable Object에 프로퍼티와 값을 set한다. (반드시 1→2→3 순서로 실행된다.) (Function Code인 경우) 매개변수(parameter)가 Variable Object의 프로퍼티로, 인수(argument)가 값으로 set된다. 대상 코드 내의 함수 선언(함수 표현식 제외)을 대상으로 함수명이 Variable Object의 프로퍼티로, 생성된 Function Object가 값으로 set된다.(함수 호이스팅) 대상 코드 내의 변수 선언을 대상으로 변수명이 Variable Object의 프로퍼티로, undefined가 값으로 set된다.(변수 호이스팅) 우선 2. 함수 foo의 선언이 처리되고(Function Code이 아닌 Global Code이기 때문에 1. 매개변수 처리는 실행되지 않는다.) 그 후 3. 변수 x의 선언이 처리된다. 3.1.2.1 함수 foo의 선언 처리 함수 선언은 Variable Instantiation 실행 순서 2.와 같이 선언된 함수명( foo )이 Variable Object( Global Code인 경우 Global Object )의 프로퍼티로, 생성된 Function Object가 값으로 바인딩된다. 함수 foo의 선언 처리 생성된 Function Object는 [[Scopes]] 프로퍼티를 가지게 된다. [[Scopes]] 프로퍼티는 값으로 현재 실행 컨텍스트의 Scope Chain이 참조하고 있는 객체와 같은 객체를 참조하는 리스트가 바인딩된다. 참조하는 값이 없이 최상위 이므로 0을 가지게된다. 함수 호이스팅: 스코프 체인이 가리키는 변수 객체에 이미 함수가 등록되어 있으므로 이후 코드를 실행할 때 함수선언식 이전에 함수를 호출할 수 있게 되었다. 3.1.2.2 변수 x의 선언 처리 변수 선언은 Variable Instantiation 실행 순서 3.과 같이 선언된 변수명( x )이 Variable Object의 프로퍼티로, undefined가 값으로 set된다. 선언 단계(Declaration phase)변수 객체(Variable Object)에 변수를 등록한다. 이 변수 객체는 스코프가 참조할 수 있는 대상이 된다. 초기화 단계(Initialization phase)변수 객체(Variable Object)에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다. 할당 단계(Assignment phase)undefined로 초기화된 변수에 실제값을 할당한다. var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 변수 호이스팅: 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 변수 x의 선언 처리 3.1.3 this value 결정 변수 선언 처리가 끝나면 다음은 this value가 결정된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정된다. Global Code의 경우, this의 value는 언제나 전역 객체이다. this value 결정 전역 컨텍스트(Global Code)의 경우, Variable Object, Scope Chain, this값은 언제나 전역 객체이다. 3.2 Global code의 실행12345678910111213var x = 'xxx';function foo () &#123; var y = 'yyy'; function bar () &#123; var z = 'zzz'; console.log(x + y + z); &#125; bar();&#125;foo(); 3.2.1 변수 값의 할당 현재 실행 컨텍스트의 Scope Chain이 참조하고 있는 Variable Object를 선두(0)부터 검색하여 변수명에 해당하는 프로퍼티가 발견되면 값(‘xxx’)을 할당한다. 변수 값의 할당 3.2.2 함수 foo의 실행 Global Code의 함수 foo가 실행되기 시작하면 새로운 함수 실행 컨텍스트가 생성된다. 함수 foo의 실행 컨텍스트로 컨트롤이 이동하면 Global Code의 경우와 마찬가지로 1. Scope Chain의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순차적으로 실행된다. Global Code와 다른 점은 이번 실행되는 코드는 Function Code이라는 것이다. 함수 foo의 실행 컨텍스트 생성 3.2.2.1 Scope Chain의 생성과 초기화 Function Code의 Scope Chain의 생성과 초기화는 우선 Activation Object에 대한 레퍼런스를 Scope Chain의 선두에 바인딩하는 것으로 시작된다. Activation Object는 스펙 상의 개념으로 프로그램이 Activation Object에 직접 접근할 수 없다. (Activation Object의 프로퍼티로의 접근은 가능하다) Scope Chain의 생성과 초기화: Activation Object의 생성과 바인딩 Caller(global context)의 [[Scope]] 프로퍼티가 참조하고 있는 객체가 Scope Chain에 push된다. 함수 foo를 실행한 직후 실행 컨텍스트의 Scope Chain은 Activation Object(함수 foo의 실행으로 만들어진 AO-1)과 Global Object를 순차적으로 참조하게 된다. Scope Chain의 생성과 초기화: Caller의 [[Scope]]를 Scope Chain에 push 3.2.2.2 Variable Instantiation 실행 Function Code의 경우, Scope Chain의 생성과 초기화에서 생성된 Activation Object를 Variable Object로서 Variable Instantiation가 실행된다. Variable Instantiation 실행: 함수 bar의 선언 처리 변수 y를 Variable Object(AO-1)에 set한다(프로퍼티는 y, 값은 undefined） 변수 y를 Variable Object(AO-1)에 set한다(프로퍼티는 y, 값은 undefined） 3.2.2.3 this value 결정 변수 선언 처리가 끝나면 다음은 this value가 결정된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정된다. 내부 함수의 경우, this의 value는 전역 객체이다. this value 결정 3.3 foo function code의 실행 이제 함수 foo의 코드블럭 내 구문이 실행된다. 위 예제를 보면 변수 y에 문자열 ‘yyy’의 할당과 함수 bar가 실행된다. 3.3.1 변수 값의 할당 지역 변수 y에 문자열 ‘yyy’를 할당할 때, 현재 실행 컨텍스트의 Scope Chain이 참조하고 있는 Variable Object를 선두(0)부터 검색하여 변수명에 해당하는 프로퍼티가 발견되면 값 ‘yyy’를 할당한다. 변수 y에의 값 할당 함수 bar의 실행 함수 bar가 실행되기 시작하면 새로운 실행 컨텍스트이 생성된다. 함수 bar의 실행 이전 함수 foo의 실행 과정과 동일하게 1. Scope Chain의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순차적으로 실행된다. 완성된 실행 컨텍스트 이 단계에서 console.log(x + y + z); 구문의 실행 결과는 xxxyyyzzz가 된다. x : AO-2에서 x 검색 실패 → AO-1에서 x 검색 실패 → GO에서 x 검색 성공 (값은 ‘xxx’) y : AO-2에서 y 검색 실패 → AO-1에서 y 검색 성공 (값은 ‘yyy’) z : AO-2에서 z 검색 성공 (값은 ‘zzz’)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Excution-Context","slug":"JavaScript/Excution-Context","permalink":"http://yoursite.com/categories/JavaScript/Excution-Context/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Excution-Context","slug":"Excution-Context","permalink":"http://yoursite.com/tags/Excution-Context/"}]},{"title":"JavaScript This","slug":"js-study-this","date":"2017-08-03T03:54:00.000Z","updated":"2017-11-10T12:53:01.000Z","comments":true,"path":"2017/08/03/js-study-this/","link":"","permalink":"http://yoursite.com/2017/08/03/js-study-this/","excerpt":"","text":"Javascript this 자바스크립트의 함수는 호출될 때, 매개변수로 전달되는 인자값 이외에, arguments 객체와 this를 암묵적으로 전달 받는다. 12345678910function square(number) &#123; console.log(arguments); console.log(this); // browser에서는 window로 node에서는 global로 출력된다. // 전역이다. return number * number;&#125;var result = square(); This는 특별한 상황 2가지를 제외한 경우는 모두 전역변수를 의미한다. 예외 1. method로 호출될때 호출한 것이 this로 사용된다./ method의 내부함수도 전역 변수이다. 예외 2. 생성자 함수에서 생성된 객체의 경우 this는 생성자 함수가 생성할 객체를 가르킨다. 자바스크립트의 경우 자바와 같이 this에 바인딩되는 객체는 한가지가 아니라 해당 함수 호출 패턴에 따라 this에 바인딩되는 객체가 달라진다. 함수 호출 패턴과 this 바인딩 메소드 호출 패턴(Method Invocation Pattern) 함수 호출 패턴(Function Invocation Pattern) 생성자 호출 패턴(Constructor Invocation Pattern) apply 호출 패턴(Apply Invocation Pattern) 1. 메소드 호출 패턴(Method Invocation Pattern) this는 그 method를 소유한 객체를 가르킨다. 즉 그 method를 호출한 객체를 가르킨다. 123456789101112131415var obj1 = &#123; name: 'Lee', sayName: function() &#123; console.log(this.name); &#125;&#125;var obj2 = &#123; name: 'Kim'&#125;obj2.sayName = obj1.sayName;obj1.sayName(); // Leeobj2.sayName(); // kim 프로토타입 객체도 메소드를 가질 수 있다. 프로토타입 객체 메소드 내부에서 사용된 this도 일반 메소드 방식과 마찬가지로 해당 메소드를 호출한 객체에 바인딩된다. 즉 함수를 부른 객체에 적용이된다. Q. obj2에는 sayName함수가없는데 이것은 obj2proto, obj1proto가 같아서인가요?? 아니면 무슨이유인가요? A. this의 특징인 method를 호출한 객체를 가르키기 때문이다. 12345678910111213function Person(name) &#123; this.name = name;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;var me = new Person('Lee');console.log(me.getName()); // Lee -&gt; method를 호출한 객체를 가르키기 때문이다.Person.prototype.name = 'Kim';console.log(Person.prototype.getName()); // kim 2. 함수 호출 패턴(Function Invocation Pattern) 전역객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window, Server-side(Node.js)에서는 global 객체를 의미한다. 기본적으로 this는 전역객체(Global object)에 바인딩된다. 전역함수는 물론이고 심지어 내부함수의 경우도 this는 외부함수가 아닌 전역객체에 바인딩된다. method 내부의 내부함수의 this도 전역을 가르킨다. (설계상 결점) 12345678910111213141516var value = 1;var obj = &#123; value: 100, foo: function() &#123; console.log(\"foo's this: \", this); // obj console.log(\"foo's this.value: \", this.value); // 100 function bar() &#123; console.log(\"bar's this: \", this); // window console.log(\"bar's this.value: \", this.value); // 1 &#125; bar(); &#125;&#125;;obj.foo(); 콜백함수의 경우에도 this는 전역객체에 바인딩된다.(설계적 결함) 12345678910111213var value = 1;var obj = &#123; value: 100, foo: function() &#123; setTimeout(function() &#123; console.log(\"callback's this: \", this); // window console.log(\"callback's this.value: \", this.value); // 1 &#125;, 100); &#125;&#125;;obj.foo(); this의 전역객체 회피방법 12345678910111213141516171819var value = 1;var obj = &#123; value: 100, foo: function() &#123; var that = this; // Workaround : this === obj console.log(\"foo's this: \", this); // obj console.log(\"foo's this.value: \", this.value); // 100 function bar() &#123; console.log(\"bar's this: \", this); // window console.log(\"bar's this.value: \", this.value); // 1 console.log(\"bar's that: \", that); // obj console.log(\"bar's that.value: \", that.value); // 100 &#125; bar(); &#125;&#125;; var that = this; 여기서 this는 obj이다 즉 that은 obj이므로 이상해지면 that을 써준다. 3. 생성자 호출 패턴(Constructor Invocation Pattern) 생성자 함수를 생성시 new를 쓴것과 안쓴것은 차이가 있다. 3.1 생성자 함수 동작 방식 빈 객체 생성 및 this 바인딩 this를 통한 프로퍼티 생성 생성된 객체 반환 생성자 함수 내부에는 return을 안써주는 것이다. 암묵적으로 해주기에 안써주는것이다 쓰면 코드가 꼬인다. this는 생성자 함수가 생성할 객체를 가르킨다. 12345678var Person = function(name) &#123; // 생성자 함수 코드 실행 전 -------- 1 this.name = name; // --------- 2 // 생성된 함수 반환 -------------- 3&#125;var me = new Person('Lee');console.log(me.name); 3.3 생성자 함수에 new 연산자를 붙이지 않고 호출할 경우1234567891011var Person = function(name) &#123; // 전역객체에 name 프로퍼티를 추가 this.name = name;&#125;;// 일반 함수로서 호출되었기 때문에 객체를 생성하여 반환하지 않는다.// 일반 함수의 this는 전역객체를 가리킨다.var me = Person('Lee');console.log(me); // undefinedconsole.log(window.name); // Lee me에다가 값이 들어가지 않고 window에 값이 들어간다. 방어코드를 작성해서 new를 빼먹는 경우를 방어한다. 1234567891011121314151617181920// Scope-Safe Constructor Patternfunction A(arg) &#123; // 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈객체를 생성하고 this에 바인딩한다. /* this가 호출된 함수(arguments.callee, 본 예제의 경우 A)의 인스턴스가 아니면 new 연산자를 사용하지 않은 것이므로 이 경우 new와 함께 생성자 함수를 호출하여 인스턴스를 반환한다. arguments.callee는 호출된 함수의 이름을 나타낸다. 이 예제의 경우 A로 표기하여도 문제없이 동작하지만 특정함수의 이름과 의존성을 없애기 위해서 arguments.callee를 사용하는 것이 좋다. */ if (!(this instanceof arguments.callee)) &#123; // A에 의해 생성된 객체가 아니라면 return new arguments.callee(arg); // 강제로 new를 붙인다. &#125; this.value = arg ? arg : 0;&#125;var a = new A(100);var b = A(10);console.log(a.value);console.log(b.value); argument.callee는 생성자의 이름이 나타난다. 4. apply 호출 패턴(Apply Invocation Pattern) 유사배열 : 유사배열은 배열이아닌 객체라서 배열처럼 불를수있지만 원래의 순서가 보장이 안된다. func.apply는 func의 양부인 Function.prototype 객체의 메소드이다. []는 option을 나타낸다. 1234func.apply(thisArg, [argsArray])// thisArg: 함수 내부의 this에 바인딩할 객체// argsArray: 함수에 전달할 인자 배열 12345678910var Person = function (name) &#123; this.name = name;&#125;;var foo = &#123;&#125;;// apply 메소드는 생성자함수 Person을 호출한다. 이때 this에 객체 foo를 바인딩한다.Person.apply(foo, ['name']); // this로 쓸 객체 = foo, name은 Person의 인자배열 / call은 , 로 구분해서준다.console.log(foo); // &#123; name: 'name' &#125; 1234567891011121314function convertArgsToArray() &#123; console.log(arguments); // arguments 객체를 배열로 변환 // slice: 배열의 특정 부분에 대한 복사본을 생성한다. var arr = Array.prototype.slice.apply(arguments); // arguments.slice // var arr = [].slice.apply(arguments); // argument를 Array로 변환해서 arr에 저장해준다. console.log(arr); return arr;&#125;convertArgsToArray(1, 2, 3); argumetns 객체는 배열 객체는 아닌데 slice를 쓰게해달라고 해주는게 apply이다 그래서 배열객체의.prototype에 .apply를 통해서 argument가 쓰게해준다. 123Person.apply(foo, [1, 2, 3]);Person.call(foo, 1, 2, 3); call과 apply의 차이는 배열이냐 , 이냐의 차이이다. 1234567891011121314151617function Person(name) &#123; this.name = name;&#125;Person.prototype.doSomething = function(callback) &#123; if(typeof callback == 'function') &#123; // --------- 1 여기서 this는 method안에서 작동하니 Person을 가르킨다. callback(); &#125;&#125;;function foo() &#123; console.log(this.name); // --------- 2 전역 this&#125;var p = new Person('Lee');p.doSomething(foo); // undefined callback함수에다가 직접적으로 call에 this를 명시해줘서 일반함수가 callback을 사용할 수 있게 해준다. 12345678910111213141516function Person(name) &#123; this.name = name;&#125;Person.prototype.doSomething = function(callback) &#123; if(typeof callback == 'function') &#123; callback.call(this); &#125;&#125;;function foo() &#123; console.log(this.name);&#125;var p = new Person('Lee');p.doSomething(foo); // 'Lee'","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"This","slug":"JavaScript/This","permalink":"http://yoursite.com/categories/JavaScript/This/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"This","slug":"This","permalink":"http://yoursite.com/tags/This/"}]},{"title":"JavaScript Scope","slug":"js-study-scope","date":"2017-08-03T03:54:00.000Z","updated":"2017-11-07T12:35:46.000Z","comments":true,"path":"2017/08/03/js-study-scope/","link":"","permalink":"http://yoursite.com/2017/08/03/js-study-scope/","excerpt":"","text":"Javascript Scope 3.Function scope자바스크립트의 Scope 종류 전역Scope(Global scope) 코드 어디에서든지 참조할 수 있다. 지역Scope(Local scope or Function-level scope) 정의된 함수 내에서만 참조할 수 있다. 변수의 Scope 종류 전역 변수 (Global variable) 전역 Scope를 갖는 변수. 지역 변수 (Local variable) 지역 Scope를 갖는 변수 변수는 선언 위치(전역 또는 지역)에 의해 Scope를 가지게 된다. 즉 전역에서 선언된 변수는 전역 Scope를 갖는 전역 변수이고, 지역(자바스크립트의 경우 함수 내부)에서 선언된 변수는 지역 Scope를 갖는 지역 변수가 된다. 전역 Scope를 갖는 전역 변수는 전역(코드 어디서든지)에서 참조할 수 있다. 지역(함수 내부)에서 선언된 지역 변수는 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다. javascript는 함수 코드블럭만 지역Scope로 인식하며, 그 외는 전역 Scope이다. 12345678910111213var x = 0; // global&#123; var x = 1; // global console.log(x); // 1&#125;console.log(x); // 1let y = 0; // global&#123; let y = 1; // local console.log(y); // 1&#125;console.log(y); // 0 let은 block-level-scope를 지원한다. 1. Global scope 전역 변수는 전역 객체 window의 프로퍼티이다.1234567891011var global = 'global'; // 전역 변수function foo() &#123; // 전역 함수 var local = 'local'; // this로 선언하면 함수외부에서도 참조가가능하다 but var는 안된다. console.log(global); console.log(local);&#125;foo();console.log(global); // window.global을 해도 같은 값이 나온다. 편의상 없앴다.console.log(local); // Uncaught ReferenceError: local is not defined 함수내부에 this로 선언한 변수들은 public 외부에서 참조가 가능하며 var로 선언한 변수들은 private하여 외부에서 참조가 불가능하다. 2. Non block-level scope -&gt; Function-level scope1234if (true) &#123; var x = 5; // function이 아니니깐 global하다.&#125;console.log(x); // 5가 나온다. 3. Function scope12345678var a = 10; // 전역변수(function () &#123; // IIFE 즉시실행함수이다. var b = 20; // 지역변수&#125;)();console.log(a); // 10console.log(b); // \"b\" is not defined 자바스크립트는 function-level scope를 사용한다. 즉 함수 내에서 선언된 매개변수와 변수는 함수 외부에서는 유효하지 않다. 따라서 변수 b는 지역 변수이다. 1234567891011121314var x = 'global';function foo() &#123; var x = 'local'; console.log(x); function bar() &#123; // 내부함수 console.log(x); // local &#125; bar();&#125;foo();console.log(x); // global Scope 체이닝이 발생한다. = 실행 컨텍스트 내부함수는 자신을 포함하고 있는 외부함수의 변수에 접근할 수 있다. 이는 매우 유용하다. 클로저에서와 같이 내부함수가 더 오래 생존하는 경우, 타 언어와는 다른 움직임을 보인다. 123456789var x = 'global';function foo() &#123; var x = 'local'; console.log(x);&#125;foo(); // localconsole.log(x); // global 123456789var x = 10;function foo() &#123; x = 100; console.log(x);&#125;foo(); // 100console.log(x); // 100 Q. 왜 100인가요?? 숫자는 지역값을 가져오나요? // A. 내부함수에 var가아닌 전역으로 선언해서 그렇다. 123456789101112131415var foo = function ( ) &#123; var a = 3, b = 5; var bar = function ( ) &#123; var b = 7, c = 11;// 이 시점에서 a는 3, b는 7, c는 11 a += b + c;// 이 시점에서 a는 21, b는 7, c는 11 &#125;;// 이 시점에서 a는 3, b는 5, c는 not defined bar( );// 이 시점에서 a는 21, b는 5 -&gt; a가 참조되어서 bar안에서 변경되서 a=21이며 b는 내부함수껏을 사용못하니깐 5이다.&#125;; 4. 암묵적 전역 var 키워드없이 선언을 하면 암묵적으로 전역번수가 된다. 5. Lexical scoping (Static scoping)123456789101112var i = 5;function foo() &#123; var i = 10; bar();&#125;function bar() &#123; // 선언된 시점에서의 scope를 갖는다! console.log(i);&#125;foo(); // 5 bar와 foo가 각각 scope이기에 bar는 전역변수 i=5를 가져와서 출력한다. 6. 변수명의 중복 i값이 서로 전역변수로 중복이 되기에 조심해야한다. 전역변수를 반드시 사용하여야 할 이유를 찾지 못한다면 지역변수를 사용하여야 한다. 변수의 범위인 스코프는 좁을수록 좋다. 7. 최소한의 전역변수 사용 전역변수 사용을 최소화하는 방법 중 하나는 애플리케이션에서 전역변수 사용을 위해 다음과 같이 전역변수 객체 하나를 만들어 사용하는 것이다. 12345678var MYAPP = &#123;&#125;;MYAPP.student = &#123; name: 'Lee', gender: 'male'&#125;;console.log(MYAPP.student.name); 8. 즉시실행함수를 이용한 전역변수 사용 억제 전역변수 사용을 억제하기 위해, 즉시 실행 함수(IIFE, Immediately-Invoked Function Expression)를 사용할 수 있다. 즉시 실행 함수는 즉시 실행되고 그 후 전역에서 바로 사라진다. 123456789101112(function () &#123; var MYAPP = &#123;&#125;; MYAPP.student = &#123; name: 'Lee', gender: 'male' &#125;; console.log(MYAPP.student.name); //사용가능&#125;());console.log(MYAPP.student.name); // 여기서 사용안된다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Scope","slug":"JavaScript/Scope","permalink":"http://yoursite.com/categories/JavaScript/Scope/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Scope","slug":"Scope","permalink":"http://yoursite.com/tags/Scope/"}]},{"title":"JavaScript Immutability","slug":"js-study-immutability","date":"2017-08-01T03:54:00.000Z","updated":"2017-11-24T10:47:30.000Z","comments":true,"path":"2017/08/01/js-study-immutability/","link":"","permalink":"http://yoursite.com/2017/08/01/js-study-immutability/","excerpt":"","text":"Javascript Immutability Immutability(변경불가성)이란? 객체가 생성된 이후 그 상태를 변경할 수 없는 디자인 패턴을 의미한다.레퍼런스를 참조한 다른 객체에서 객체를 변경하는 상황을 해결하는 방법 객체를 불변객체로 만들어 프로퍼티의 변경을 방지하며 객체의 변경이 필요한 경우에는 참조가 아닌 객체의 방어적 복사(defensive copy)를 통해 새로운 객체를 생성한 후 변경한다. 또는 Observer 패턴으로 객체의 변경에 대처할 수도 있다. Observer 패턴으로 객체의 변경에 대처할 수도 있다. Observer; 데이터 타입이 필요한이유 ? 메모리를 효율적으로 사용하기 위해서 1. immutable value vs. mutable value Javascript의 기본 자료형(primitive data type)은 변경 불가능한 값(immutable value)이다. Boolean null undefined Number String Symbol (New in ECMAScript 6) 객체 타입은 변경 가능한 값(mutable value)이다. 즉 객체는 새로운 값을 다시 만들 필요없이 직접 변경이 가능하다는 것이다. 123456var statement = 'I am an immutable value'; // string은 immutable valuevar otherStr = statement.slice(8, 17);console.log(otherStr); // 'immutable'console.log(statement); // 'I am an immutable value' slice() 메서드는 statement 변수에 저장된 문자열을 변경하는 것이 아니라 사실은 새로운 문자열을 생성하여 반환하고 있다.(immutable value) 12345var arr = [];console.log(arr.length); // 0var v2 = arr.push(2); // arr.push()는 메서드 실행 후 arr의 length를 반환console.log(arr.length); // 1 처리 후 결과의 복사본을 리턴하는 문자열의 메서드 slice()와는 달리 배열(객체)의 메서드 push()는 직접 대상 배열을 변경한다. 그 이유는 배열은 객체이고 객체는 immutable value가 아닌 변경 가능한 값이기 때문이다. 123456789101112131415var user = &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125;&#125;;var myName = user.name; // 변수 myName은 string 타입이다.// myName은 기본형이라서 user.name을 참조가아닌 복사를한다. user.name = 'Kim'; console.log(myName); // Lee -&gt; myName은 참조가아닌 복사를 하기때문에 kim이 반영이안됬다.myName = user.name; // 재할당console.log(myName); // Kim user.name의 값을 변경했지만 변수 myName의 값은 변경되지 않았다. 이는 user.name의 타입 string이 변경 불가능하기 때문이다. myName은 기본형으로써 값을 pass-by-value(복사)하기 때문에 user.name=’kim’이 바로 반영되지 않는다. 12345678910111213var user1 = &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125;&#125;;var user2 = user1; // user1이라는 객체를 pass-by-reference한것이다 변수 user2는 객체 타입이다.user2.name = 'Kim';console.log(user1.name); // Kimconsole.log(user2.name); // Kim var user2 = user1으로 인해서 user2가 객체 타입으로 변했기에 참조형으로 반영된다. 객체를 변경못하게 불변객체로 만들어야한다. 2. 불변 데이터 패턴(immutable data pattern) 의도하지 않은 객체의 변경을 막는 방법 : 객체를 불변객체로 만들어 프로퍼티의 변경을 방지하며 객체의 변경이 필요한 경우에는 참조가 아닌 객체의 방어적 복사(defensive copy)를 통해 새로운 객체를 생성한 후 변경한다. 2.1 Obejct.assign Object.assign은 타킷 객체로 소스 객체의 프로퍼티를 복사한다. 소스 객체의 프로퍼티와 동일한 프로퍼티를 가진 타켓 객체의 프로퍼티들은 소스 객체의 프로퍼티로 덮어쓰기된다. 리턴값으로 타킷 객체를 반환한다. copy의 역할을 한다. 12345678910111213141516171819202122232425// Copyconst obj = &#123; a: 1 &#125;;const copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125;console.log(obj == copy); // false// Mergeconst o1 = &#123; a: 1 &#125;;const o2 = &#123; b: 2 &#125;;const o3 = &#123; c: 3 &#125;;const merge1 = Object.assign(o1, o2, o3);console.log(merge1); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, 타겟 객체가 변경된다!// Mergeconst o4 = &#123; a: 1 &#125;;const o5 = &#123; b: 2 &#125;;const o6 = &#123; c: 3 &#125;;const merge2 = Object.assign(&#123;&#125;, o4, o5, o6);console.log(merge2); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o4); // &#123; a: 1 &#125; Object.assign을 사용하여 기존 객체를 변경하지 않고 객체를 복사하여 사용할 수 있다. 1234567891011121314151617const user1 = &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125;&#125;;const user2 = Object.assign(&#123;&#125;, user1); // user1을 &#123;&#125;에 Copyuser2.name = 'Kim';// 상기 2행은 아래와 동치이다.// &#123;name: 'Kim'&#125;은 user1에 병합되는 것이 아니라 첫번째 인자인 &#123;&#125;에 병합된다.// const user2 = Object.assign(&#123;&#125;, user1, &#123;name: 'Kim'&#125;);console.log(user1.name); // Leeconsole.log(user2.name); // Kim user1 객체를 빈객체에 복사하여 새로운 객체 user2를 생성하였다. user1과 user2는 어드레스를 공유하지 않으므로 한 객체를 변경하여도 다른 객체에 아무런 영향을 주지 않는다. 주의할 것은 user1 객체는 const로 선언되어 재할당은 할 수 없지만 객체의 프로퍼티는 보호되지 않는다. 다시 말하자면 객체의 내용은 변경할 수 있다. 2.2 Objet.freeze Object.freeze()를 사용하여 불변(immutable) 객체로 만들수 있다. 객체 내부의 객체는 얼리지 못한다. 12345678910111213141516171819const user1 = &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125;&#125;;const user2 = Object.assign(&#123;&#125;, user1, &#123;name: 'Kim'&#125;);console.log(user1.name); // Leeconsole.log(user2.name); // KimObject.freeze(user1);user1.name = 'Kim'; // 무시된다!console.log(user1); // &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125; &#125;console.log(Object.isFrozen(user1)); // true 하지만 객체 내부의 객체(Nested Object)는 변경가능하다. 즉 메소드의 내부내용은 변경가능하다. 1234567891011const user = &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125;&#125;;Object.freeze(user);user.address.city = 'Busan'; // 변경된다!console.log(user); // &#123; name: 'Lee', address: &#123; city: 'Busan' &#125; &#125; 내부 객체까지 변경 불가능하게 만들려면 Deep freeze를 하여야 한다. 12345678910111213141516171819202122232425function deepFreeze(obj) &#123; const props = Object.getOwnPropertyNames(obj); props.forEach((name) =&gt; &#123; const prop = obj[name]; if(typeof prop === 'object' &amp;&amp; prop !== null) &#123; deepFreeze(prop); &#125; &#125;); return Object.freeze(obj);&#125;const user = &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125;&#125;;deepFreeze(user);user.name = 'Kim'; // 무시된다user.address.city = 'Busan'; // 무시된다console.log(user); // &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125; &#125; 2.3 Immutable.js 또 다른 대안으로 Facebook이 제공하는 Immutable.js를 사용하는 방법이 있다. Immutable.js는 List, Stack, Map, OrderedMap, Set, OrderedSet, Record와 같은 영구 불변 (Permit Immutable) 데이터 구조를 제공한다. npm으로 설치한다. 1npm install immutable Immutable.js의 Map 모듈을 임포트하여 사용한다. 12345const &#123; Map &#125; = require('immutable')const map1 = Map(&#123; a: 1, b: 2, c: 3 &#125;)const map2 = map1.set('b', 50)map1.get('b') // 2map2.get('b') // 50 map1.set(‘b’, 50)의 실행에도 불구하고 map1은 불변하였다. map1.set()은 결과를 반영한 새로운 객체를 반환한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Immutability","slug":"JavaScript/Immutability","permalink":"http://yoursite.com/categories/JavaScript/Immutability/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Immutability","slug":"Immutability","permalink":"http://yoursite.com/tags/Immutability/"}]},{"title":"JavaScript Function","slug":"js-study-function","date":"2017-08-01T03:54:00.000Z","updated":"2017-11-05T04:25:05.000Z","comments":true,"path":"2017/08/01/js-study-function/","link":"","permalink":"http://yoursite.com/2017/08/01/js-study-function/","excerpt":"","text":"Javascript Function 함수란 어떤 특정 작업을 수행하기 위해 필요한 일련의 구문들을 그룹화하기 위한 개념이다.(코드의 재사용) 함수의 기능 특정 작업을 수행하는 구문들의 집합을 정의하고 필요시에 호출하여 필요한 값 또는 수행 결과를 얻는다. 객체 생성, 객체의 행위 지정(메서드) 정보의 구성 및 은닉, 클로저, 모듈화 등의 기능을 수행할 수 있다. 함수는 구문(statement)의 집합으로 모듈화의 근간이 된다. 함수도 객체이다. 다른 객체와 구분될 수 있는 특징은 호출할 수 있다는 것이다. 변수나 객체, 배열 등에 저장될 수 있고 다른 함수에 전달되는 인수로도 사용될 수 있으며 함수의 반환값이 될 수도 있다. 호출 : 함수를 실행시키는 행위 1. 함수 정의 함수선언식(Function declaration) 함수표현식(Function expression) Function() 생성자 함수 1.1 함수선언식(Function declaration) 함수선언식을 사용한 함수 정의는 function 키워드와 이하의 내용으로 구성된다. 함수명 : 함수명은 생략할 수 없다. 식별자의 역할을 한다. 매개변수 목록 : 0개 이상의 목록으로 괄호로 감싸고 콤마로 분리한다. 자료형 체크가 필요할 수 있다. tpyeof로 자료형을 체크한다. typeof num===’number’ &amp;&amp; !!num 이렇게 비교한다. 함수 몸체 : 중괄호({ })로 구문들을 감싸고 return 문으로 결과값을 반환할 수 있다. 이를 반환값(return value)라 한다. 123 function square(number) &#123; return number * number;&#125; number = 매개변수 = parameter 1.2 함수표현식(Function expression) 자바스크립트의 함수는 일급객체이다. 무명의 리터럴로 표현이 가능하다. 변수나 자료 구조(객체, 배열…)에 저장할 수 있다. 함수의 파라미터로 전달할 수 있다. 반환값(return value)으로 사용할 수 있다. 함수표현식이란? 함수 리터럴 방식으로 함수를 정의하고 변수에 할당하는 방식이다. 123var square = function(number) &#123; return number * number;&#125;; 함수표현식으로 정의한 함수는 함수명을 생략할 수 있다. 이러한 함수를 익명 함수(anonymous function)이라 한다. 1234567891011// 기명 함수표현식(named function expression) 재귀함수, 디버그var foo = function multiply(a, b) &#123; return a * b;&#125;;// 익명 함수표현식(anonymous function expression)var bar = function(a, b) &#123; return a * b;&#125;;console.log(foo(10, 5)); // 50console.log(multiply(10, 5)); // Uncaught ReferenceError: multiply is not defined 함수 호출시 변수가 함수명처럼 사용된다. 함수가 할당된 변수를 사용해 함수를 호출하지 않고 기명 함수의 함수명을 사용해 호출하게 되면 에러가 발생한다. 이는 함수표현식에서 사용한 함수명은 외부 코드에서 접근 불가능하기 때문이다. 기명 함수표현식은 재귀함수, 디버그를 할 때 필요하다. 12345678var foo = function(a, b) &#123; return a * b;&#125;;var bar = foo;console.log(foo(10, 10)); // 100 , 10을 argument, 인수라한다.console.log(bar(10, 10)); // 100 변수 bar와 변수 foo는 동일한 익명 함수의 참조값을 갖는다. 123var square = function square(number) &#123; return number * number;&#125;; 함수명과 함수 참조값을 가진 변수명이 일치하므로 함수명으로 호출되는 듯 보이지만 사실은 변수명으로 호출된 것이다. 결국 함수선언식도 함수표현식과 동일하게 함수 리터럴 방식으로 정의되는 것이다. 1.3 Function() 생성자 함수 함수선언식과 함수표현식은 모두 함수 리터럴 방식으로 함수를 정의하는데 이것은 결국 내장 함수 Function() 생성자 함수로 함수를 생성하는 것을 단순화 시킨 것이다. 12var square = new Function('number', 'return number * number');console.log(square(10)); // 100 2. 함수 호이스팅(Function Hoisting) 위의 3가지 함수 정의 방식은 동작 방식에 약간의 차이가 있다. 예) 밑에는 함수선언식이다. -&gt; 이 방법을 사용하지 말아라. 반드시 호출전에 선언할 것. 12345var res = square(5);function square(number) &#123; return number * number;&#125; 함수 선언의 위치와는 상관없이 코드 내 어느 곳에서든지 호출이 가능한데 이것을 함수 호이스팅(Function Hoisting)이라 한다. 자바스크립트는 ES6의 let, const를 포함하여 모든 선언(var, let, const, function, function*, class)을 호이스팅(Hoisting)한다. 함수선언식으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에 바로 초기화하고 이를 VO(variable object)에 저장한다.즉, 함수 선언, 초기화, 할당이 한번에 이루어진다. 예) 밑에는 함수표현식으로 함수를 정의 -&gt; 이방법 변수호이스팅만 발생 이것을 사용. 12345var res = square(5); // TypeError: square is not a functionvar square = function(number) &#123; return number * number;&#125; 함수선언식의 경우와는 달리 TypeError가 발생하였다. 함수표현식의 경우 함수 호이스팅이 아니라 변수 호이스팅이 발생한다. 변수 호이스팅은 변수 생성 및 초기화와 할당이 분리되어 진행된다. 호이스팅된 변수는 undefined로 초기화 되고 실제값의 할당은 할당문에서 이루어진다. 함수표현식은 함수선언식과는 달리 스크립트 로딩 시점에 변수 객체(VO)에 함수를 할당하지 않고 runtime에 해석되고 실행되므로 이 두가지를 구분하는 것은 중요하다. 함수선언식으로 함수를 정의하면 사용하기에 쉽지만 대규모 애플리케이션을 개발하는 경우 인터프리터가 너무 많은 코드를 변수 객체(VO)에 저장하므로 애플리케이션의 응답속도는 현저히 떨어질 수 있으므로 주의해야 할 필요가 있다. 3. First-class object (일급 객체) 일급 객체(first-class object)란? 생성, 대입, 연산, 인자 또는 반환값으로서의 전달 등 프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상을 의미한다. 무명의 리터럴로 표현이 가능하다. 예) var foo = function() { ~~ } // 함수의 이름이 없다. 변수나 자료 구조(객체, 배열…)에 저장할 수 있다. 함수의 파라미터로 전달할 수 있다. 반환값(return value)으로 사용할 수 있다. 123456789101112131415161718192021222324252627282930313233// 1. 무명의 리터럴로 표현이 가능하다.// 2. 변수나 데이터 구조안에 담을 수 있다.var increase = function(num) &#123; return num + 1;&#125;;var decrease = function(num)&#123; return num - 1;&#125;;var obj = &#123; increase: increase, decrease: decrease&#125;;// 3. 함수의 파라미터로 전달 할 수 있다.function calc(func, num)&#123; return func(num);&#125;console.log(calc(increase, 1));console.log(calc(decrease, 1));// 4. 반환값(return value)으로 사용할 수 있다.function calc(mode)&#123; var funcs = &#123; plus: function(left, right)&#123; return left + right; &#125;, minus: function(left, right)&#123; return left - right; &#125; &#125;; return funcs[mode]; // funcs.mode 로하면 mode라는 요소를 찾는다 하지만 이것은 잘못된것 func[mode]로해야한다.&#125;console.log(calc('plus')(2,1));console.log(calc('minus')(2,1)); Javascript의 함수는 위의 조건을 모두 만족하므로 Javascript의 함수는 일급객체이다. 함수와 다른 객체를 구분 짖는 특징은 호출할 수 있다는 것이다. 4. 매개변수(Parameter, 인자) 함수의 작업 실행을 위해 추가적인 정보가 필요할 경우, 매개변수를 지정한다. 매개변수는 함수 내에서 변수와 동일하게 동작한다. 4.1 매개변수(parameter, 인자) vs 인수(argument) 매개변수는 함수 내에서 변수와 동일하게 메모리 공간을 확보하며 전달되어진 인수는 매개변수에 할당된다. 만약 인수가 전달되지 않으면 매개변수는 undefined로 초기화된다. 12345var foo = function (p1, p2) &#123; // p1,p2은 parameter 인자이다. console.log(p1, p2);&#125;;foo(1); // 1 undefined -&gt; 1은 인수이다. 4.2 Call-by-value Primitives(기본자료형) 인수는 Call-by-value(값에 의한 호출)로 동작한다. 함수 호출 시 기본자료형 인수를 함수에 매개변수로 전달할 때 매개변수에 값을 복사하여 함수로 전달하는 방식이다. 함수 내에서 매개변수를 통해 값이 변경되어도 전달이 완료된 기본자료형 값은 변경되지 않는다. 123456789function foo(primitive) &#123; primitive += 1; return primitive;&#125;var x = 0;console.log(foo(x)); // 1console.log(x); // 0 -&gt; 기본자료형 값은 변경되지 않는다. 4.3 Call-by-reference 객체 타입(참조 타입) 인수는 Call-by-reference(참조에 의한 호출)로 동작한다. 함수 호출 시 참조 타입 인수를 함수에 매개변수로 전달할 때 매개변수에 값이 복사되지 않고 객체의 참조값이 매개변수에 저장되어 함수로 전달되는 방식이다. 함수 내에서 매개변수의 참조값이 이용하여 객체의 값을 변경했을 때 전달되어진 참조형의 인수값도 같이 변경된다. 12345678910111213141516171819function changeVal(primitive, obj) &#123; primitive += 100; obj.name = 'Kim'; obj.gender = 'female';&#125;var num = 100;var obj = &#123; name: 'Lee', gender: 'male'&#125;;console.log(num); // 100console.log(obj); // Object &#123;name: 'Lee', gender: 'male'&#125;changeVal(num, obj);console.log(num); // 100console.log(obj); // Object &#123;name: 'Kim', gender: 'female'&#125; num은 기본자료형이라서 call-by-value로 복사만 되고 obj은 참조형(객체) 변수라서 call-by-reference여서 kim, female이 들어간다.; 5. 반환값 (return value) 함수는 자신을 호출한 코드에게 수행한 결과를 반환(return)할 수 있다. return 키워드는 함수를 호출한 코드에게 값을 반환할 때 사용한다. 함수는 배열 등을 이용하여 한 번에 여러 개의 값을 리턴할 수 있다. 함수는 반환을 생략할 수 있다. 이때 함수는 암묵적으로 undefined를 반환한다. 자바스크립트 해석기는 return 키워드를 만나면 함수의 실행을 중단한 후, 함수를 호출한 코드로 되돌아간다. 만일 return 키워드 이후에 다른 구문이 존재하면 그 구문은 실행되지 않는다. 123456789101112131415function calculateArea(width, height) &#123; var area = width * height; return area; // 단일 값의 반환&#125;console.log(calculateArea(3, 5)); // 15console.log(calculateArea(8, 5)); // 40function getSize(width, height, depth) &#123; var area = width * height; var volume = width * height * depth; return [area, volume]; // 복수 값의 반환&#125;console.log('area is ' + getSize(3, 2, 3)[0]); // area is 6console.log('volume is ' + getSize(3, 2, 3)[1]); // volume is 18 6. 함수 객체의 프로퍼티 함수는 객체이다. 따라서 함수도 프로퍼티를 가질 수 있다. 12345678function square(number) &#123; return number * number;&#125;square.x = 10;square.y = 20;console.log(square.x, square.y); // 10, 20 함수는 일반 객체와는 다른 함수만의 표준 프로퍼티를 갖는다. 1234function square(number) &#123; return number * number;&#125;console.dir(square); 6.1 arguments 프로퍼티 arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회가능한(iterable) 유사 배열 객체(array-like object)이다. 함수 객체의 arguments 프로퍼티는 arguments 객체를 값으로 가지며 함수 내부에서 지역변수처럼 사용된다. 즉 함수 외부에서는 사용할 수 없다 123456789function multiply(x, y) &#123; console.log(arguments); return x * y;&#125;console.log(multiply()); // &#123;&#125;console.log(multiply(1)); // &#123; '0': 1 &#125;console.log(multiply(1,2)); // &#123; '0': 1, '1': 2 &#125;console.log(multiply(1,2,3));// &#123; '0': 1, '1': 2, '2': 3 &#125; 매개변수(parameter)는 인수(argument)로 초기화된다 매개변수의 갯수보다 인수를 적게 전달했을 때(multiply(), multiply(1)) 인수가 전달되지 않은 매개변수는 undefined으로 초기화된다. 매개변수의 갯수보다 인수를 더 많이 전달한 경우, 초과된 인수는 무시된다. 즉 arguments 객체는 매개변수 갯수가 확정되지 않은 가변 인자 함수를 구현할 때 유용하게 사용된다. 12345678910111213function sum() &#123; var res = 0; for (var i=0; i&lt;arguments.length; i++) &#123; res += arguments[i]; &#125; return res;&#125;console.log(sum()); // 0console.log(sum(1,2)); // 3console.log(sum(1,2,3)); // 6 arguments 객체는 배열의 형태로 인자값 정보를 담고 있지만 실제 배열이 아닌 유사배열객체(array-like object)이다. 유사배열객체란 length 프로퍼티를 가진 객체를 말한다. 배열 메서드를 사용하려면 Function.prototype.call, Function.prototype.apply를 사용하여야 하는 번거로움이 있다. 123456789function sum() &#123; // arguments 객체를 배열로 변환 var array = Array.prototype.slice.call(arguments); return array.reduce(function (pre, cur) &#123; return pre + cur; &#125;);&#125;console.log(sum(1, 2, 3, 4, 5)); // 15 call 함수를 사용하여서 arguments객체를 배열로 변환하였다. 6.2 caller 프로퍼티 caller 프로퍼티는 자신을 호출한 함수를 의미한다. 123456789101112131415function foo(func) &#123; var res = func(); return res;&#125;function bar() &#123; if (bar.caller == null) &#123; return 'The function was called from the top!'; &#125; else &#123; return 'This function\\'s caller :\\n' + bar.caller; &#125;&#125;console.log(foo(bar));console.log(bar()); bar.caller == null인경우는 전역에서 바로 부르는것 6.3 length 프로퍼티 length 프로퍼티는 함수 정의 시 작성된 매개변수 갯수를 의미한다. 123456789101112function foo() &#123;&#125;console.log(foo.length); // 0function bar(x) &#123; return x;&#125;console.log(bar.length); // 1function baz(x, y) &#123; return x * y;&#125;console.log(baz.length); // 2 6.4 name 프로퍼티 함수명을 나타낸다. 기명함수의 경우 함수명을 값으로 갖고 익명함수의 경우 빈문자열을 값으로 갖는다. 1234567891011// 기명 함수표현식(named function expression)var namedFunc = function multiply(a, b) &#123; return a * b;&#125;;// 익명 함수표현식(anonymous function expression)var anonymousFunc = function(a, b) &#123; return a * b;&#125;;console.log(namedFunc.name); // multiplyconsole.log(anonymousFunc.name); // '' 6.5 proto 프로퍼티 ECMAScript spec에서는 모든 객체는 자신의 프로토타입을 가리키는 [[Prototype]]이라는 숨겨진 프로퍼티를 가진다 라고 되어있다. -&gt; 부모가 있다라는 의미이다. proto과 [[Prototype]]은 같은 개념이다. proto로 부모를 찾을 수 있다. 최상위는 object.prototype이다. 자식은 부모의 것을 사용할 수 있고 그 반대는 안된다. 12345function square(number) &#123; return number * number;&#125;console.dir(square); 함수의 프로토타입 객체는 Function.prototype이며 이것 역시 함수이다. square.proto를 하면 squre의 부모인 Function prototype이 나온다. 6.6 prototype 프로퍼티1var foo = new Person(); 생성자함수가 foo 객체를 만들었을때 생성자 이름에 prototype이 붙은 애가 양부의 역할을 하는데 이때 은 foo객체의 부모이며 의 부모는 Object-prototype이고 Person() 생성자의 prototype을 Person.prototype이라고 불른다. 이때 Person() 생성자의 부모는 funtion-prototype이다. 다들 똑같은 객체이다. 함수 객체만이 가지고 있는 프로퍼티으로 자바스크립트 객체지향의 근간이다. 모든 함수 객체는 prototype 프로퍼티를 갖는다. 주의해야 할 것은 prototype 프로퍼티는 프로토타입 객체를 가리키는 [[Prototype]] 프로퍼티(__proto__ 프로퍼티)와는 다르다는 것이다. [[Prototype]] 프로퍼티 모든 객체가 가지고 있는 프로퍼티이다. 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체을 가리키며 함수 객체의 경우 Function.prototype를 가리킨다. 생성한 객체가 부모를 가르킬때 사용한다. prototype 프로퍼티 함수 객체만 가지고 있는 프로퍼티이다. 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다. 함수가 생성될 때 만들어 지며 constructor 프로퍼티를 가지는 객체를 가리킨다. 이 constructor 프로퍼티는 함수 객체 자신을 가리킨다. 생성자 함수가 생성한 객체의 부모역할을 할 객체를 가르킨다. constructor 프로퍼티는 Person.prototype이 Person 생성자 함수를 가르킨다. 123456789101112function square(number) &#123; return number * number;&#125;// console.dir(square);console.dir(square.__proto__);console.dir(square.prototype);console.log(square.__proto__ === Function.prototype); // true ①console.log(square.__proto__ === square.prototype); // falseconsole.log(square.prototype.constructor === square); // true ②console.log(square.__proto__.constructor === square.prototype.constructor); // false [[Prototype]] 프로퍼티는 함수 객체의 부모 객체(Function.prototype)를 가리키며 prototype 프로퍼티는 함수객체가 생성자 함수로 사용되어 객체를 생성할 때 생성된 객체의 부모 객체 역할을 하는 객체를 가리킨다.; 7. 함수의 다양한 형태7.1 즉시호출함수표현식 (IIFE, Immediately Invoke Function Expression) 함수의 정의(선언)와 동시에 실행(호출)되는 함수를 즉시호출함수라고 한다. 최초 한번만 호출되며 다시 호출할 수는 없다. 이러한 특징을 이용하여 최초 한번만 실행이 필요한 초기화 처리등에 사용할 수 있다. 전역문제를 가장 쉽게해결하는 IIFE(즉시호출함수표현식). 12345678910111213// 기명 즉시실행함수(named immediately-invoked function expression)(function myFunction() &#123; var a = 3; var b = 5; return a * b;&#125;());// 익명 즉시실행함수(immediately-invoked function expression)(function() &#123; var a = 3; var b = 5; return a * b;&#125;()); 코드의 복잡성을 막기위해서 즉시실행함수의 전체를 한번 막아줘야한다. 자바스크립트에서 가장 큰 문제점 중의 하나는 글로벌 스코프에 정의된 것은 코드 내의 어디서든지 접근이 가능하다는 것이다. 외부에 공유되면 곤란하거나 공유될 필요가 없는 프로퍼티나 메서드가 있다. 다른 스크립트 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 원치 않는 결과를 가져올 수 있다. 즉시실행함수 내에 처리 로직을 모아 두면 혹시 있을 수도 있는 변수명 충돌을 방지할 수 있어 이를 위한 목적으로 사용되기도 한다. 즉시실행함수 내에 정의해 두면 라이브러리의 변수들이 독립된 영역 내에 있게 되므로 여러 라이브러리들은 동시에 사용하더라도 변수명 충돌과 같은 문제를 방지할 수 있다. 1234567(function() &#123; var foo = 1; // 지역 console.log(foo);&#125;());var foo = 100; // 전역console.log(foo); 7.2 내부 함수 (Inner function) 내부함수 child는 자신을 포함하고 있는 부모함수 parent의 변수에 접근할 수 있다. 하지만 부모함수는 자식함수(내부함수)의 변수에 접근할 수 없다. closer와 관계가 있다. 1234567891011function parent(param) &#123; var parentVar = param; function child() &#123; var childVar = 'lee'; console.log(parentVar + ' ' + childVar); // Hello lee &#125; child(); console.log(parentVar + ' ' + childVar); // Uncaught ReferenceError: childVar is not defined&#125;parent('Hello'); 또한 내부함수는 부모함수 외부에서 접근할 수 없다. 12345678function sayHello(name)&#123; var text = 'Hello ' + name; var logHello = function()&#123; console.log(text); &#125; logHello();&#125;sayHello('lee'); // Hello leelogHello('lee'); // logHello is not defined 7.3 콜백 함수 (Callback function) 콜백함수는 함수를 명시적으로 호출하는 방식이 아니라 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수를 말한다. 콜백함수가 자주 사용되는 대표적인 예는 이벤트 핸들러 처리이다. 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button id=\"myButton\"&gt;Click me&lt;/button&gt; &lt;script&gt; var button = document.getElementById('myButton'); button.addEventListener('click', function() &#123; console.log('button clicked!'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 콜백 함수는 매개변수를 통해 전달되고 전달받은 함수의 내부에서 어느 특정시점에 실행된다. 123setTimeout(function()&#123; console.log('1초 후 출력된다.');&#125;, 1000); setTimeout method는 전역 메소드이다. 콜백 함수는 주로 비동기식 처리 모델(Asynchronous processing model)에 사용된다. 동기식 처리 모델이란 처리가 종료하면 호출될 함수(콜백함수)를 미리 매개변수에 전달하고 처리가 종료하면 콜백함수를 호출하는 것이다. 123456789function doSomething() &#123; var name = 'Lee'; setTimeout(function() &#123; console.log('My name is ' + name); &#125;, 100);&#125;doSomething(); // My name is Lee","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Function","slug":"JavaScript/Function","permalink":"http://yoursite.com/categories/JavaScript/Function/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://yoursite.com/tags/Function/"}]},{"title":"JavaScript Prototype","slug":"js-study-prototype","date":"2017-08-01T03:54:00.000Z","updated":"2017-11-07T12:37:50.000Z","comments":true,"path":"2017/08/01/js-study-prototype/","link":"","permalink":"http://yoursite.com/2017/08/01/js-study-prototype/","excerpt":"","text":"Javascript Prototype12345678function Person(name) &#123; this.name = name; this.sayHello = function()&#123; console.log(this.name); &#125;&#125;var foo = new Person('Lee'); foo의 property는 name, sayHello를 가진다. name은 primitive(기본값이라서) = Lee가 존재하며 sayHello는 객체라서 참조가 되는것(참조값 func이 존재만한다)이지 바로저장되지는 않는다.foo가 친부를 찾을때는 foo.__proto__.costructor도 되지만 foo.constructor(표준)를 사용하면 프로토타입 체이닝에 의해서 Person.prototype의 property를 사용하여서 Person() 생성자 함수를 찾을 수 있다. 함수는 일반 객체와 달리 prototype이라는 property를 가지는데 자신이 생성한 객체의 아버지를 가르킨다. 1. 프로토타입 객체 자바스크립트의 모든 객체는 부모가 존재한다. Prototype 기반 객체로 나타낸다. 123456789var student = &#123; name: 'Lee', score: 90&#125;;// student에는 hasOwnProperty 메서드가 없지만 아래 구문은 동작한다.console.log(student.hasOwnProperty('name')); // trueconsole.dir(student); // student의 dir을 본다. hasOwnProperty는 obejct 객체안에 존재하기에 사용가능하다. 함수가 아니여서 prototype이 존재하지 않는다. __proto__ 와 [[Prototype]]은 같은 개념이다. student.__proto__ === Object.prototype // true이다. 2. [[Prototype]] 프로퍼티 vs prototype 프로퍼티 [[Prototype]] 프러퍼티는 자신의 프로토타입 객체를 가리키는 숨겨진 프로퍼티이다. [[Prototype]] 프로퍼티는 __proto__ 프로퍼티로 구현되어 있어 __proto__과 [[Prototype]]은 같은 개념이다. 함수도 객체이므로 [[Prototype]] 프로퍼티를 갖는다. 그런데 함수 객체는 일반 객체와는 달리 prototype 프로퍼티도 소유하게 된다. 함수객체는 일반객체와 달리 호출할 수 있다. prototype 프로퍼티는 함수를 생성하는 생성자가 가르키는 것을 나타내고 [[Prototype]] 프로퍼티는 생성자로 생성한 함수가 가르키는것을 나타낸다 모두 프로토타입 객체를 가리키지만 관점의 차이가 있다. 12345678function Person(name) &#123; this.name = name;&#125;var foo = new Person('Lee');console.dir(Person); // prototype 프로퍼티가 있다. / Person.prototype이 존재한다.console.dir(foo); // prototype 프로퍼티가 없다. [[Prototype]]프로퍼티 함수를 포함한 모든 객체가 가지고 있는 프로퍼티이다. 객체의 입장에서 자신의 양부 역할을 하는 프로토타입 객체을 가리키며 함수 객체의 경우 Function.prototype를 가리킨다. 123console.log(Person.__proto__ === Function.prototype);// Person의 부모는 Function.prototype이다. Funtion이라는 생성자가 존재한다.// Function 생성자함수는 Person의 친부모이다. Function.prototype의 __proto__는 Object.prototype이다. prototype 프로퍼티 함수 객체만 가지고 있는 프로퍼티이다. 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성될 객체의 부모 역할을 하는 객체(프로토타입 객체)를 가리킨다 1console.log(Person.prototype === foo.__proto__); 3. constructor 프로퍼티 프로토타입 객체는 constructor 프로퍼티를 갖는다. constructor 프로퍼티는 생성된 함수의 입장에서 생성자 함수를 찾아가기 위한 프로퍼티이다. 1234567891011121314function Person(name) &#123; this.name = name;&#125;var foo = new Person('Lee');// Person() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Person() 생성자 함수이다.console.log(Person.prototype.constructor === Person);// foo 객체를 생성한 객체는 Person() 생성자 함수이다. prototype chaining이다.console.log(foo.constructor === Person);// Person() 생성자 함수를 생성한 객체는 Function() 생성자 함수이다.console.log(Person.constructor === Function); 4. Prototype chain 해당객체의 property가 있는지 여부를 찾고 없으면 proto를 찾아서 부모에 있는지 살핀다. 이것이 프로토타입 객체 상속의 핵심이다. 4.1 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인 객체 생성 방법은 3가지이다. 객체 리터럴 생성자 함수 -&gt; 생성자.prototype으로 생성된다. Object() 생성자 함수 -&gt; 객체 리터럴로 생성하면 내부적으로 Object 생성자 함수로 객체가 생성된다. Object.prototype으로 생성된다. 함수 객체인 Object() 생성자 함수는 일반 객체와 달리 prototype 프로퍼티가 있다. 1234567891011121314var person = &#123; name: 'Lee', gender: 'male', sayHello: function()&#123; console.log('Hi! my name is ' + this.name); &#125;&#125;;console.dir(person);console.log(person.__proto__ === Object.prototype); // ① trueconsole.log(Object.prototype.constructor === Object); // ② trueconsole.log(Object.__proto__ === Function.prototype); // ③ trueconsole.log(Function.prototype.__proto__ === Object.prototype); // ④ true ; 결론적으로 객체 리터럴을 사용하여 객체를 생성한 경우 Object생성자로 객체를 생성한다. 그래서 객체의 프로토타입 객체는 Object.prototype이다. 4.2 생성자 함수로 생성된 객체의 프로토타입 체인 생성자 함수로 객체를 생성하기 위해서는 우선 생성자 함수를 정의하여야 한다. 함수를 정의하는 방식은 3가지 있다. 함수선언식 함수표현식 Function() 생성자 -&gt; 결론적으로 이걸로 내부에 생성된다. 123456789101112131415161718function Person(name, gender) &#123; this.name = name; this.gender = gender; this.sayHello = function()&#123; console.log('Hi! my name is ' + this.name); &#125;;&#125;var foo = new Person('Lee', 'male');console.dir(Person);console.dir(foo);console.log(foo.__proto__ === Person.prototype); // ① trueconsole.log(Person.prototype.__proto__ === Object.prototype); // ② trueconsole.log(Person.prototype.constructor === Person); // ③ trueconsole.log(Person.__proto__ === Function.prototype); // ④ trueconsole.log(Function.prototype.__proto__ === Object.prototype); // ⑤ true 생성자 함수에는 method 만들지말고 생성자.prototype에다가 method를 만들어라.불필요한 중복을 줄이기 위해서 이다. Obejct.prototype객체를 프로토타입 체인의 종점이라고 한다. 5. 프로토타입 객체의 확장 프로토타입 객체도 객체이므로 프로퍼티를 추가/삭제할 수 있다. 1234567891011function Person(name) &#123; this.name = name;&#125;var foo = new Person('Lee');Person.prototype.sayHello = function()&#123; console.log('Hi! my name is ' + this.name);&#125;; // foo 객체를 생성한 이후에 함수를 추가해도 되고 전에 써도 된다.foo.sayHello(); Person.prototype은 생성자 함수를 생성할때 즉 new를 사용할때 생성된다. 6. 기본자료형(Primitive data type)의 확장 자바스크립트에서 기본자료형(숫자, 문자열, boolean, null, undefined)을 제외한 모든것은 객체이다. 123456789101112var str = 'test'; // 리터럴 방식console.log(typeof str); // stringconsole.log(str.constructor === String); // trueconsole.dir(str);var strObj = new String('test'); // 객체형으로 생성console.log(typeof strObj); // objectconsole.log(strObj.constructor === String); // trueconsole.dir(strObj);console.log(str.toUpperCase()); // TESTconsole.log(strObj.toUpperCase()); // TEST 기본자료형은 상속개념이 없지만 객체는 상속개념이 있다. console.log(strObj.constructor === String); 를하면 기본자료형을 순간적으로 객체형으로 바꿔줬다가 다시 기본자료형으로 돌아온다. 그래서 str.toUpperCase()를 사용할 수 있다. String, Number은 이방식을 사용할 때가 있다. 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다. 기본자료형은 객체가 아니므로 프로퍼티나 메소드를 직접 추가할 수 없다.(에러발생은 않는다.) -&gt; 해결책 : 직접하면된다 String.prototype.myMethod 값을 공유함으로써 효율적인 메모리 사용이 가능해진다. 123456789var str = 'test';String.prototype.myMethod = function () &#123; // 이것을 통해서 직접추가가능 단 조심해야한다. return 'myMethod';&#125;;console.log(str.myMethod()); // myMethodconsole.log('string'.myMethod()); // myMethodconsole.dir(String.prototype); 표준이 아닌곳에 추가를 하기 때문에 옳은 방법은 아니다. 따로 모아서 만드는 것이 좋다. myLibrary라는 객체를 만들어서 사용하는 것이 좋다. 7. 프로토타입 객체의 변경 상속을 변경하고 싶을 경우 사용한다. 프로토타입 객체 변경 시점 이전에 생성된 객체기존 프로토타입 객체를 [[Prototype]] 프로퍼티에 바인딩한다. 프로토타입 객체 변경 시점 이후에 생성된 객체변경된 프로토타입 객체를 [[Prototype]] 프로퍼티에 바인딩한다. 12345678910111213141516function Person(name) &#123; this.name = name;&#125;var foo = new Person('Lee');// 프로토타입 객체의 변경Person.prototype = &#123; gender: 'male' &#125;;var bar = new Person('Kim');console.log(foo.gender); // undefinedconsole.log(bar.gender); // 'male'console.log(foo.constructor); // ① Person(name)console.log(bar.constructor); // ② Object() 프로토타입 객체 변경 후 constructor가 깨지기 때문에 이렇게는 하지않는다. prototype에 method가 아닌 객체의 변경이 이루어져서 깨진다. Q. 프로토타입 객체 변경 전 : foo.constructor가 Person(name)을 가르킨다는게 무슨이야기인지 모르겠습니다. Person.prototype.constructor가 Person() 생성자 함수아닌가요?? A. foo.constructor은 foo가 양부의 property를 사용하기에 가르킬수 있다. 8. 프로토타입 체인 동작 조건 객체의 프로퍼티를 참조하는 경우, 해당 객체에 프로퍼티가 없는 경우, 프로포타입 체인이 동작한다. 123456789101112131415161718function Person(name) &#123; this.name = name;&#125;Person.prototype.gender = 'male'; // ①var foo = new Person('Lee');var bar = new Person('Kim');console.log(foo.gender); // ① 'male'console.log(bar.gender); // ① 'male'// 1. foo 객체에 gender 프로퍼티가 없으면 프로퍼티 동적 추가// 2. foo 객체에 gender 프로퍼티가 있으면 해당 프로퍼티에 값 할당foo.gender = 'female'; // ②console.log(foo.gender); // ② 'female'console.log(bar.gender); // ① 'male'","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Prototype","slug":"JavaScript/Prototype","permalink":"http://yoursite.com/categories/JavaScript/Prototype/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Prototype","slug":"Prototype","permalink":"http://yoursite.com/tags/Prototype/"}]},{"title":"JavaScript Data-Type Variable","slug":"js-study-data-type-variable","date":"2017-07-31T03:54:00.000Z","updated":"2017-11-05T03:58:39.000Z","comments":true,"path":"2017/07/31/js-study-data-type-variable/","link":"","permalink":"http://yoursite.com/2017/07/31/js-study-data-type-variable/","excerpt":"","text":"Javascript Data type &amp; Variable 변수란?: 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자이다. 자료형은 데이터의 성질을 나타낸다. javascript 영역이 입력되는 값을 판단하여서 메모리에 저장한다. JavaScript는 동적 타이핑 언어로 변수의 Type annotation이 필요없이 값이 할당되는 과정에서 자동으로 자료형이 결정된다. 할당되기 전에는 undefined형이다. typeof를 통하여 변수의 type을 알 수 있다. 12345678var str = 'Hello';var num = 1;var bool = true;var foo = 'string';console.log(typeof foo); // stringfoo = 1;console.log(typeof foo); // number 1.Data Type (자료형) 기본 자료형(변경 불가능) Boolean null undefined Number String Symbol(ECMAScript 6 추가) 객체형(변경 가능) object 1.1 Primitive Data Type (기본자료형) 기본자료형의 값은 변경 불가능한 값이다. (pass-by- value) 1.1.1 Boolean true, false 두가지의 값을 가질 수 있다. 비어있는 문자열, null, undefined, 숫자 0은 false로 간주된다. 1.1.2 null 값을 할당한 이후에 그 값의 관계를 끊는다. JavaScript는 case-sensitive(대소문자구분)하므로 null은 항상 소문자로 작성해야한다. var foo = null; 을하면 typeof가 null이 나와야하는데 object가 나온다 설계상의 오류이다. 즉 typeof로 check하면 안되고 (foo === null)로 체크해야한다. 1.1.3 undefined 값을 할당하지 않은 변수는 undefined값을 가진다. 12345678var foo;console.log(foo); // undefinedfoo = &#123; name: 'Lee', gender: 'male'&#125;console.log(foo.bar); // bar가 존재하지 않아서 undefined가 나온다. 1.1.4 Number 자바스크립트는 Number인 하나의 숫자 자료형만 존재한다. +/- Infinity, NaN(not-a-number) 정수를 +0으로 나누면 + Infinity, -0으로 나누면 - Infinity이다. NaN은 연산은 가능하지만 숫자로 표시를 못하는 경우 1.1.5 String String은 텍스트 데이터를 나타내는데 사용한다. ‘’, “”사이에 값을 넣을 수 있지만 주로 ‘’를 사용한다. 1234var str = \"string\";console.log(str[0]); // s console.log(typeof str); // type = stringconsole.log(str[3]); // i 자바스크립트의 문자열은 변경 불가능(immutable)하다. 이것은 한 번 문자열이 생성되면, 그 문자열을 변경할 수 없다는걸 의미한다. 변경 불가능(immutable) 한번 생성된 문자열은 read only로서 수정되지 않는다. 새로운 문자를 할당하는 것은 가능하다 += 를 사용한다. 재할당은 그 부분에다가 하는 것이아닌 새로운 부분에다가 만들고 변수가 그곳을 알려주는 것이다. 1234567891011121314var str = 'string';console.log(str); // stringstr = 'String'; // 재할당console.log(str); // Stringstr += ' test';console.log(str); // String teststr.substring(0, 3);console.log(str); // Strstr = str.toUpperCase();console.log(str); // STR 재할당이란? 기존에 string을 따로두고 새로운 곳에 String으로 만들어 둔다. 메서드란? .앞에는 기본적으로 객체이고 뒤에는 함수인데 이것을 합쳐서 이야기한다. 기본자료형은 안에 wrapper가 존재하기에 객체의 역할을 할 수 있다. 1.1.6 Symbol Symbol은 에플리케이션 전체에서 유일하며 변경 불가능한(immutable) 기본 자료형(primitive)이다. 주로 객체의 프로퍼티 키(property key)로 사용한다. 자료형을 symbol이라는 함수로 나타내며 이값은 에플리케이션에서 유일한 값으로 나타난다. 123456var key = Symbol('key');console.log(typeof key); // symbolvar obj = &#123;&#125;;obj[key] = 'value';console.log(obj[key]); // value 1.2 객체형 (object type, 참조형) 객체는 이름과 값을 가지는 데이터를 의미하는 프로퍼티와 동작을 의미하는 메서드를 포함하고 있는 독립적 주체이다.(pass-by-reference) 변경가능한 데이터이다. 데이터를 의미하는 프로퍼티(property)와 동작을 의미하는 메서드(method)를 포함하고 있는 독립적 주체이다. 객체의 종류 함수 배열 날짜 정규식 2. 변수(Varible) 값을 유지할 필요가 있을 때 사용한다. 변수명 생성 규칙 반드시 영문자(특수문자 제외), underscore ( _ ), 또는 달러 기호($)로 시작하여야 한다. 이어지는 문자에는 숫자(0~9)도 사용할 수 있다. JavaScript는 대/소문자를 구별하므로 사용할 수 있는 문자는 “A” ~ “Z” (대문자)와 “a” ~ “z” (소문자)이다. var keyword를 사용하여서 선언을한다. 123456789101112var name; // 변수 name 선언name = 'Lee'; // 변수 name에 값 'Lee'가 저장(할당)되었다.var age = 30; // 선언과 할당var person = 'Lee', address = 'Seoul', price = 200;var price = 10;var tax = 1;var total = price + tax; 선언이 안되어 있는 값에 접근하면 Reference Error 예외가 발생한다.123var x;console.log(x); // undefinedconsole.log(y); // ReferenceError 2.1 변수의 중복 선언 변수는 중복 선언이 가능하다. 123456var x = 1;console.log(x); // 1// 변수의 중복 선언var x = 100;console.log(x); // 100 이기능은 기존의 선언된 값이 의도되지않게 재할당이 될 위험이 있다.(협업시 문제 발생 가능성 증가) 2.2 변수 선언 시 var 키워드 생략 허용12x = 1;console.log(x); // 1 var를 사용하지 않았기 때문에 전역 변수로 선언이 된다. 전역 변수란? 소스코드 모든 영역에서 변수를 사용할 수 있다. 2.3 동적 타이핑 (Dynamic Typing) Typing 변수의 type을 설정하는 것을 나타낸다. 변수의 Type annotation이 필요없이 값이 할당되는 과정에서 자동으로 자료형이 결정된다. 같은 변수에 여러 data type의 값을 대입할 수 있다. type을 선언하지 않았다면 runtime에러가 발생할 확률이 높다. 1234567891011121314151617181920var foo;console.log(typeof foo); // undefinedfoo = null;console.log(typeof foo); // objectfoo = &#123;&#125;;console.log(typeof foo); // objectfoo = 3;console.log(typeof foo); // numberfoo = 3.14;console.log(typeof foo); // numberfoo = 'Hi'; console.log(typeof foo); // stringfoo = true; console.log(typeof foo); // boolean 하나의 변수로 여러개의 type을 설정할 수 있지만 위험할 수 있다. 2.4 변수 호이스팅 (Variable Hoisting) 자바스크립트의 모든 선언문은 호이스팅된다. 호이스팅이란 var 선언문이나 function 선언문을 해당 Scope의 선두로 옮겨진것 처럼보여지는 것을 말한다. javascript의 변수는 function-level scope를 가진다. Function-level scope : 함수 내부에서 선언한 변수는 지역변수이며, 함수 외부에서 선언한 변수는 모두 전역 변수이다. 즉 함수 블록만 지역이다. 함수내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다.함수 외부에서 선언한 변수는 함수내부에서 사용가능하다. 1234567console.log(foo); // ① undefinedvar foo = 123;console.log(foo); // ② 123&#123; var foo = 456;&#125;console.log(foo); // ③ 456 undefined인 이유는 변수 호이스팅으로 인해서 밑에 foo가 선언된 값이 선두로 옮겨진 것 처럼 보여지는 것이라서 그렇다. 변수의 생성단계 선언 단계 : 변수 객체에 변수를 등록한다. 이 변수 객체는 scope가 참조하는 대상이 된다. 초기화 단계 : 변수 객체에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다. 할당 단계 : undefined로 초기화된 변수에 실제값을 할당한다. var keyword로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 타언어에서는 if, for문 등의 { ~~ } 안에는 또다른 scope(지역 범위)으로 구분이 되지만 javascript에서는 구분이 되지 않는다. javascript는 함수만 scope로 구분한다. 2.5 var keyword로 선언된 변수의 문제점 Function-level scope 전역 변수의 남발가능성 농후 for loop 초기화식에서 사용한 변수를 for loop 외부 or 전역에서 참조할 수 있다. var keyword 생략 허용 의도하지 않은 변수의 전역화 중복 선언 허용 의도하지 않은 변수값 변경 변수 호이스팅 변수를 선언하기 전에 참조가 가능하다. 변수의 범위는 좁을수록 좋다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Data-Type","slug":"JavaScript/Data-Type","permalink":"http://yoursite.com/categories/JavaScript/Data-Type/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Data-Type","slug":"Data-Type","permalink":"http://yoursite.com/tags/Data-Type/"}]},{"title":"JavaScript Object","slug":"js-study-object","date":"2017-07-31T03:54:00.000Z","updated":"2017-11-04T09:22:01.000Z","comments":true,"path":"2017/07/31/js-study-object/","link":"","permalink":"http://yoursite.com/2017/07/31/js-study-object/","excerpt":"","text":"Javascript Object 1. 객체(Object)란? 자바스크립트는 객체기반의 스크립트 언어이며 이루고 있는 거의 모든것은 객체이다 객체 = 키 + 데이터 + 동작 이름(키) + 값으로 구성된 데이터(프로퍼티) + 동작을 나타내는(메서드) 1.1 프로퍼티(Property) 객체는 이름(name)과 값(value)의 쌍인 프로퍼티들을 포함하는 컨테이너라고 할 수 있다. 프로퍼티 이름 : 빈 문자열을 포함하는 문자열과 숫자 프로퍼티 값 : undefined을 제외한 모든 값 1.2 메서드(Method) 메서드는 객체에 제한되어 있는 함수를 의미한다. 2. 객체 생성 방법 자바스크립트는 클래스라는 개념이 없고 별도의 객체 생성 방법이 존재한다. 객체 리터럴, object() 생성자 함수, 생성자 함수 3가지의 방법이 존재한다. 2.1 객체 리터럴 중괄호({})를 사용하여 객체를 생성하는데 {} 내에 아무것도 기술하지 않으면 빈 객체가 생성된다. {} 내에 1개 이상의 프로퍼티 이름(Property name): 프로퍼티 값(Property value)을 기술하면 해당 프로퍼티가 추가된 객체를 생성할 수 있다. 123456789101112131415var emptyObject = &#123;&#125;; // empty object 즉 property가 없다.console.log(typeof emptyObject); // objectvar person = &#123; name: 'Lee', gender: 'male', sayHello: function () &#123; console.log('Hi! My name is ' + this.name); &#125;&#125;;console.log(typeof person); // objectconsole.log(person); // &#123; name: 'Lee', gender: 'male', sayHello: [Function: sayHello] &#125;person.sayHello(); // Hi! My name is Lee person은 2개의 property(name,gender)와 1개의 method(syHello())를 가지고 있다. 객체내에서 method가 다른 property를 선택할때는 this를 가르킨다. 2.2 Object() 생성자 함수 new 연산자와 Object() 생성자 함수를 사용하여 빈 객체를 생성할 수 있다. 12345678910111213// 빈 객체의 생성var person = new Object();// 프로퍼티 추가person.name = 'Lee';person.gender = 'male';person.sayHello = function () &#123; console.log('Hi! My name is ' + this.name);&#125;;console.log(typeof person); // objectconsole.log(person); // &#123; name: 'Lee', gender: 'male', sayHello: [Function] &#125;person.sayHello(); // Hi! My name is Lee 객체 리터럴 방식으로 생성된 객체는 결국 내장(Built-in) 함수인 Object() 생성자 함수로 객체를 생성하는 것을 단순화 시킨 short-hand(축약법)이다. 2.3 생성자 함수 동일한 프로퍼티를 갖는 객체를 한번에 만든다. 1234567891011121314151617181920// 생성자 함수function Person(name, gender) &#123; this.name = name; this.gender = gender; this.sayHello = function()&#123; console.log('Hi! My name is ' + this.name); &#125;;&#125;// 인스턴스의 생성var person1 = new Person('Lee', 'male');var person2 = new Person('Kim', 'female');console.log('person1: ', typeof person1);console.log('person2: ', typeof person2);console.log('person1: ', person1);console.log('person2: ', person2);person1.sayHello();person2.sayHello(); 생성자 함수 이름은 일반적으로 대문자로 시작한다. 프로퍼티 또는 메서드명 앞에 기술한 this는 생성자 함수로 생성될 인스턴스(instance)를 가리킨다. 따라서 this에 연결되어 있는 프로퍼티와 메서드는 public이다. 생성자 함수 내에서 선언된 일반 변수는 private이다. 즉 생성자 함수 내부에서는 자유롭게 접근이 가능하나 외부에서 접근할 수 있는 방법이 없다. 12345678910111213141516function Person(name, gender) &#123; var married = 'yes'; // private this.name = name; // public this.gender = gender; // public this.sayHello = function()&#123; // public console.log('Hi! My name is ' + this.name); &#125;;&#125;var person = new Person('Lee', 'male');console.log(typeof person);console.log(person);console.log(person.gender); // 'male'console.log(person.married); // undefined 3. 객체 프로퍼티 접근3.1 프로퍼티 이름 ‘’로 묶어주는 이유는 - 를 연산자로 인식하기 때문이다. last_name(Snake) = ok, lastName(Kamel) = ok, last-name(kebab) = no (일반적으로 카멜사용) 프로퍼티 값은 undefined을 제외한 모든 값과 표현식이 올 수 있으며 프로퍼티 값이 함수인 경우 이를 메서드라 한다. 예약어를 프로퍼티 이름으로 사용하여서는 않된다. 12345678var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male', function: 1 // OK. 하지만 예약어는 사용하지 말아야 한다.&#125;;console.log(person.function); 3.2 프로퍼티 값 읽기 객체의 프로퍼티에 접근하는 방법 마침표 . 표기법 대괄호 [] 표기법 -&gt; kebab 형식일때 사용한다. 123456789101112131415var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;console.log(person);console.log(person.first-name); // NaN: undefined-nameconsole.log(person[first-name]); // ReferenceError: first is not definedconsole.log(person['first-name']); // 'Ung-mo'console.log(person.gender); // 'male'console.log(person[gender]); // ReferenceError: gender is not definedconsole.log(person['gender']); // 'male' 객체에 존재하지 않는 프로퍼티를 참조하면 undefined를 반환한다. 1234567var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;console.log(person.age); // undefined 3.3 프로퍼티 값 갱신 새로운 값을 할당하면 프로퍼티 값은 갱신된다. 12345678var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;person['first-name'] = 'Kim';console.log(person['first-name'] ); // 'Kim' 3,4 프로퍼티 동적 생성 객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면 하면 해당 프로퍼티를 객체에 추가하고 값을 할당한다. 12345678var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;person.age = 20;console.log(person.age); // 20 3.5 프로퍼티 삭제 delete 연산자를 사용하여서 삭제가능하다. 객체에다가 delete를 사용하면 무시된다.1234567891011var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;delete person.gender;console.log(person.gender); // undefineddelete person;console.log(person); // Object &#123;first-name: 'Ung-mo', last-name: 'Lee'&#125; 3.6 for-in 문 for-in 문을 사용하면 객체에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다. 사용하지 않는 것이좋다. ES6에서 새로추가된 for-of 를 사용하여라. 순서가 보장되지 않고, 만들지 않은 값이 같이 나오기도 한다. 4. Pass-by-reference 참조형이란? 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미한다. 객체형과 다르게 기본자료형의 값은 값(value)으로 전달된다. 즉, 복사되어 전달된다. 이를 pass-by-value라 하며 한번 값이 정해지면 변경할 수 없다(immutable). 123456789101112// Pass-by-referencevar foo = &#123; val: 10&#125;var bar = foo;console.log(foo.val, bar.val); // 10 10console.log(foo === bar); // truebar.val = 20; // val에 20을 넣으면 bar도 자동으로 반영된다 둘은 reference관계라서 그렇다.console.log(foo.val, bar.val); // 20 20console.log(foo === bar); // true pass-by-reference는 변수 foo, bar 모두 동일한 객체를 참조하고 있다. 따라서 참조하고 있는 객체의 val 값이 변경되면 변수 foo, bar 모두 동일한 객체를 참조하고 있으므로 두 변수 모두 변경된 객체의 프로퍼티 값을 참조하게 된다. 객체는 참조(Reference) 방식으로 전달된다. 결코 복사되지 않는다. 예) pass-by-value 12345678910var foo = &#123; val: 10 &#125;;var bar = &#123; val: 10 &#125;;console.log(foo.val, bar.val); // 10 10console.log(foo === bar); // falsevar baz = bar;console.log(baz.val, bar.val); // 10 10console.log(baz === bar); // true foo와 변수 bar는 비록 내용을 같지만 별개의 객체를 생성하여 참조값을 할당하였다. 따라서 변수 foo와 변수 bar의 참조값은 동일하지 않다. 변수 baz에는 변수 bar의 값을 할당하였다. 결국 변수 baz와 변수 bar는 동일한 객체를 가리키는 참조값을 저장하고 있다. 따라서 변수 baz와 변수 bar의 참조값은 동일하다. 5. Pass-by-value 기본자료형의 값은 값(value)으로 전달된다. 즉, 복사되어 전달된다. 이를 pass-by-value라 한다. 기본자료형은 값이 한번 정해지면 변경할 수 없다.(immutable) 12345678910// Pass-by-valuevar a = 1;var b = a;console.log(a, b); // 1 1console.log(a === b); // truea = 10;console.log(a, b); // 10 1console.log(a === b); // false 6. 객체의 분류 객체는 아래와 같이 분류된다.; DOM : 정보를 가진 객체이다. BOM : browser를 컨트롤하기위한 객체들을 나타낸다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Object","slug":"JavaScript/Object","permalink":"http://yoursite.com/categories/JavaScript/Object/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Object","slug":"Object","permalink":"http://yoursite.com/tags/Object/"}]},{"title":"JavaScript-Control-Flow","slug":"js-study-control-flow","date":"2017-07-31T03:54:00.000Z","updated":"2017-10-31T13:24:32.000Z","comments":true,"path":"2017/07/31/js-study-control-flow/","link":"","permalink":"http://yoursite.com/2017/07/31/js-study-control-flow/","excerpt":"","text":"Javascript Control Flow 1. 블록 구문(Block statement) 중괄호로 범위가 정해진 구문을 블록 구문이라고 한다. 1234567891011121314151617181920// 함수function foo() &#123; var x = 1, y = 2; console.log(x + y);&#125;foo();// 객체리터럴var obj = &#123; x: 1, y: 2&#125;;console.log(obj.x + obj.y);// 흐름 제어 구문(control flow statement)var x = 0;while (x &lt; 10) &#123; x++;&#125;console.log(x); 2. 조건문 (Conditional statement) 조건식을 가지고 코드블럭을 실행할지 않할지에 대한 의사결정을 하는 것이다. 프로그래밍은 요구사항의 집합을 분석하여 적절한 자료구조와 함수의 집합으로 변환한 후 그 흐름을 제어하는 것이다. 2.1 if 문 if문을 통하여 논리적 참, 거짓을 구별한다. 12345if(조건문) &#123; // 조건식이 참이면 이 코드블록이 실행된다.&#125; else &#123; // 조건식이 거짓이면 이 코드블록이 실행된다.&#125; 1234567891011121314151617181920212223242526272829var hour = 20;var greeting;// if 문if (hour &lt; 18) &#123; greeting = 'Good day';&#125;console.log(greeting);// if-else 문if (hour &lt; 18) &#123; greeting = 'Good day';&#125; else &#123; greeting = 'Good evening';&#125;console.log(greeting);// if-else if 문if (hour &lt; 10) &#123; greeting = 'Good morning';&#125; else if (hour &lt; 20) &#123; greeting = 'Good day';&#125; else &#123; greeting = 'Good evening';&#125;console.log(greeting); 2.2 switch 문 switch변수의 값과 일치되는 case문으로 실행 순서가 이동하게 된다. 일치하는 값이 없다면 default로 이동한다. 1234567891011121314151617var color = 'red';// color = switch 변수switch (color) &#123; // color == 'yellow'인 경우 case 'yellow': console.log('yellow color'); // color == 'red'인 경우 case 'red': console.log('red color'); // color == 'blue'인 경우 case 'blue': console.log('blue color'); // 그외의 경우 default: console.log('unknown color');&#125; 이렇게 하면 break를 선언하지 않았기 때문에 red,blue,unknown까지 출력이된다. 123456789101112131415var color = 'red';switch (color) &#123; case 'yellow': console.log('yellow color'); break; case 'red': console.log('red color'); break; case 'blue': console.log('blue color'); break; default: console.log('unknown color');&#125; 3. 반복문(Loop) 주어진 조건식이 참인 경우 코드 블록을 반복해서 실행한다. 3.1 for 문 for문은 특정 조건이 거짓으로 판별될 때까지 반복한다. 123for ([초기문]; [조건문]; [증감문]) &#123; 구문;&#125; 여러 종류의 for문이 존재한다. 12345678910111213141516171819202122232425var array = ['one', 'two', 'three', 'four'];for (var i = 0; i &lt; array.length; i++) &#123; // console.log(array[i]); console.log('[' + i + '] = ' + array[i]);&#125;// for-infor (var index in array) &#123; console.log('[' + index + '] = ' + array[index]);&#125;// foreacharray.forEach(function (element, index, arr) &#123; console.log('[' + index + '] = ' + element);&#125;);// for-of (ES6)for (const element of array) &#123; console.log(element);&#125;// array.entries(): 배열의 key/value의 쌍을 반환하는 iterator를 반환for (const [index, value] of array.entries()) &#123; console.log('[' + index + '] = ' + value);&#125; for문에 어떤 식도 선언하지 않으면 무한루프가 된다. 3.2 while 문 조건문이 거짓이 되면 실행을 종료하고 반복문을 빠져나간다. 조건문이 언제나 참이면 무한루프가 된다. 무한루프를 탈출하기 위해서는 break문을 사용한다. break문을 감싸는 반복문 하나를 탈출한다. 12345678var i = 0;// 무한루프while (true) &#123; console.log(i); i++; // i가 10이면 exit! if (i === 10) break;&#125; 3.3 do-while 문 코드블록은 조건문을 확인하기 전에 무조건 1회 실행된다. 그후 조건문을 확인한다. 12345var i = 0;do &#123; console.log(i); i++;&#125; while (i &lt; 3); 3.4 continue continue문은 이후 구문의 실행을 스킵하고 반복문의 조건문으로 이동한다. 예참조 -&gt; 짝수에서는 console.log를 안한다.12345 for (var i = 0; i &lt; 5; i++) &#123; if (i % 2 == 0) continue; console.log(i); // 홀수만 출력&#125; 4. 평가(Evaluating) 일반적 표현식외에도 문자열, 숫자, 변수, 내장값등을 조건식으로 사용할 수 있다. 12345678910111213141516171819202122232425if (1) &#123; // true console.log('1');&#125;if ('str') &#123; // true console.log('2');&#125;if (true) &#123; //true console.log('3');&#125;if (null) &#123; // false console.log('4');&#125;var x = '';if (x) &#123; // false console.log('5'); &#125;if (!x) &#123; //true console.log('6'); &#125; 4.1 암묵적 강제 형 변환(Type coercion) context를 고려하여 내부적으로 자료형을 강제 형변환시킨다. 1234567console.log('1' &gt; 0); // trueconsole.log(1 + '2'); // '12'console.log(2 - '1'); // 1console.log('10' == 10); // trueconsole.log('10' === 10); // false -&gt; type이 다르다.console.log(undefined == null); // trueconsole.log(undefined === null); // false -&gt; type이 다르다. 4.2 Type Conversion Table 부정적 값은 = 0, false, undefined 등으로 나타내진다. 긍정적 값은 = 1, true 등으로 나타내진다. 4.3 Data type conversion 형 변환시 편리하다. 12345678910111213var val = '123';console.log(typeof val + ': ' + val); // string: 123// sting -&gt; numberval *= 1; // string에 수를 곱하면 type이 number로 변환된다.// val = Number(val);// val = parseInt(val);console.log(typeof val + ': ' + val); // number: 123// number -&gt; sting val += ''; // 숫자에 빈문자열을 더해준다.// val = String(val);console.log(typeof val + ': ' + val); // string: 123 val *= 1; // string에 수를 곱하면 type이 number로 변환된다.string-&gt;number val += ‘’; // 숫자에 빈문자열을 더해준다. number-&gt;string 4.4 Truthy &amp; Falsy values 아래 값들은 Boolean context에서 false로 평가된다. false undefined null 0 NaN (Not a Number) ‘’ (빈문자열) 4.5 Checking equality 동등비교시 (==, !=)이 아닌 일치연산자(===, !==)을 사용해야한다.12345678// logs false !!!console.log(null == false);console.log(undefined == false);console.log(null == 0);console.log(undefined == 0);console.log(undefined === null);console.log(NaN == null);console.log(NaN == NaN); 4.6 Checking existence 객체나 배열(배열도 객체이다)이 값을 가지고 있으면 truthy value로 취급된다. 12345if (document.getElementById('header')) &#123; // 요소가 존재함 : 필요한 작업을 수행&#125; else &#123; // 요소가 존재하지 않음 : 필요한 작업을 수행&#125; 객체의 존재를 boolean으로 비교하면 안된다. 1if (document.getElementById('header') == true) // false 주의 사항 : b가 false라는 값을 가진 객체가 된다. 12var b = new Boolean(false);if (b) // true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Control Flow","slug":"JavaScript/Control-Flow","permalink":"http://yoursite.com/categories/JavaScript/Control-Flow/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Control Flow","slug":"Control-Flow","permalink":"http://yoursite.com/tags/Control-Flow/"}]},{"title":"JavaScript Operator","slug":"js-study-operator","date":"2017-07-31T03:54:00.000Z","updated":"2017-11-05T04:13:12.000Z","comments":true,"path":"2017/07/31/js-study-operator/","link":"","permalink":"http://yoursite.com/2017/07/31/js-study-operator/","excerpt":"","text":"Javascript Operator 1. 산술 연술자 (Arithmetic Operators)1234567891011121314151617var x = 5;var y = 2;var z;z = x + y; // 7z = x - y; // 3z = x * y; // 10z = x / y; // 2.5z = x % y; // 1z = x++; // 5 선대입후증가 즉 먼저 z에게 값을준다 그래서 z= 5 그 뒤에 x=6이된다.z = ++x; // 7 선증가후대입 x=6인 값에 ++하니 z=7이된다.z = x--; // 7 선대입후감소 z = --x; // 5 선감소후대입var str1 = '5' + 5; // '55'var str2 = 5 + '5'; // '55'var str3 = 'Hello' + 5; // 'Hello5' + 연산자는 덧셈 연산과 문자열 연결 연산을 수행한다. 연산 대상이 모두 숫자인 경우 : 덧셈 연산 그 외의 경우 : 문자열 연결 연산 2. 대입 연산자 (Assignment Operators)123456789101112131415var x;x = 10; // 10x += 5; // 15x -= 5; // 10x *= 5; // 50x /= 5; // 10x %= 5; // 0var txt1 = 'Good';var txt2 = 'Morning';var txt3 = txt1 + ' ' + txt2; // Good Morningtxt1 = 'What a very ';txt1 += 'nice day'; // What a very nice day 3. 비교 연산자 (Comparison Operators) == : 동등비교 형변환 후, 비교한다. === : 일치비교 타입까지 일치하여라 true를 반환 != : 부등비교 !== : 불일치비교 ? : 삼항 연산자 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var x = 5x == 5 // truex == '5' // true '5'를 숫자로 형변환을 해버려서 true로 나타낸다.x == 8 // falsex === 5 // truex === '5' // falsex != 8 // truex != 5 // falsex != '5' // falsex !== 8 // truex !== 5 // falsex !== '5' // truex &gt; 0 // truex &gt; 5 // falsex &gt; 8 // falsex &lt; 0 // falsex &lt; 5 // falsex &lt; 8 // truex &gt;= 0 // truex &gt;= 5 // truex &gt;= 8 // falsex &lt;= 0 // falsex &lt;= 5 // truex &lt;= 8 // true//삼항연산자(ternary operator)// 조건 ? 조건이 ture일때 반환할 값 : 조건이 false일때 반환할 값var condition = true;var result = condition ? 'true' : 'false';console.log(result); // 'true'var now = new Date();var greeting = 'Good' + ((now.getHours() &gt; 17) ? ' evening.' : ' day.');// id의 길이가 INPUT_ID_MIN_LEN보다 작으면 에러 메시지를 출력한다.var id = 'lee';var INPUT_ID_MIN_LEN = 5;var errMsg = id.length &lt; INPUT_ID_MIN_LEN ? '아이디는 5자리 이상으로 입력하세요' : '성공';console.log(errMsg); // '아이디는 5자리 이상으로 입력하세요' 4. 논리 연산자 (Logical Operator)12345678910111213141516171819202122// &amp;&amp; (논리곱) 연산자var a1 = true &amp;&amp; true; // t &amp;&amp; t returns truevar a2 = true &amp;&amp; false; // t &amp;&amp; f returns falsevar a3 = false &amp;&amp; true; // f &amp;&amp; t returns falsevar a4 = false &amp;&amp; (3 == 4); // f &amp;&amp; f returns falsevar a5 = 'Cat' &amp;&amp; 'Dog'; // t &amp;&amp; t returns Dogvar a6 = false &amp;&amp; 'Cat'; // f &amp;&amp; t returns falsevar a7 = 'Cat' &amp;&amp; false; // t &amp;&amp; f returns false// || (논리 합) 연산자var o1 = true || true; // t || t returns truevar o2 = false || true; // f || t returns truevar o3 = true || false; // t || f returns truevar o4 = false || (3 == 4); // f || f returns falsevar o5 = 'Cat' || 'Dog'; // t || t returns Catvar o6 = false || 'Cat'; // f || t returns Catvar o7 = 'Cat' || false; // t || f returns Cat// ! (논리 부정) 연산자var n1 = !true; // falsevar n2 = !false; // truevar n3 = !'Cat'; // false 5. 단축 평가 논리연산자가 Boolean 값과 함께 사용되지 않을 경우, 둘중 1개가 반환된다. true || anything true false || anything anything true &amp;&amp; anything anything false &amp;&amp; anything false JavaScript는 빈문자열을 true로 인식한다. 6. 타입 연산자 (Type Operator) typeof : 변수의 자료형을 문자열로 반환한다. instanceof : 객체가 동일 객체형의 인스터스이면 true를 반환한다.123456789101112131415typeof 'John' // returns stringtypeof 3.14 // returns numbertypeof NaN // returns numbertypeof false // returns booleantypeof [1, 2, 3, 4] // returns objecttypeof &#123;name:'John', age:34&#125; // returns objecttypeof new Date() // returns objecttypeof function () &#123;&#125; // returns function typeof myCar // returns undefined (설계적 결함)typeof null // returns object (설계적 결함)function Person()&#123;&#125;var me = new Person()me instanceof Person // true 7. !! !!은 피연산자를 boolen으로 변환하는 것이다. 12345678console.log(!!1); // trueconsole.log(!!0); // falseconsole.log(!!&apos;string&apos;); // trueconsole.log(!!&apos;&apos;); // falseconsole.log(!!null); // falseconsole.log(!!undefined); // falseconsole.log(!!&#123;&#125;); // trueconsole.log(!![]); // true 객체(배열 포함)의 경우 빈 객체라도 존재하기만하면 true로 변환된다. 객체의 존재 확인 후 그 결과를 반환해야 하는 경우, !!를 사용하면 강제로 피연산자를 boolean으로 형 변환 할 수 있다. 123456789function checkExist(obj) &#123; return !!obj;&#125;var obj;console.log(checkExist(obj)); // falseobj = &#123;&#125;;console.log(checkExist(obj)); // true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Operator","slug":"JavaScript/Operator","permalink":"http://yoursite.com/categories/JavaScript/Operator/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Operator","slug":"Operator","permalink":"http://yoursite.com/tags/Operator/"}]},{"title":"JavaScript-Introduction","slug":"js-study-introduction","date":"2017-07-28T03:54:00.000Z","updated":"2017-10-29T12:37:22.000Z","comments":true,"path":"2017/07/28/js-study-introduction/","link":"","permalink":"http://yoursite.com/2017/07/28/js-study-introduction/","excerpt":"","text":"Javascript Introduction 1. Introduction 웹브라우저에서 동작하는 유일한 언어이다. jQuery의 등장으로 DOM(Document Object Model)를 보다 쉽게 제어할 수 있게 되었다. javascript는 interpreter language 컴파일러가 필요없다 동시에 번역한다. 명령형, 함수형, 프로토타입 기반 객체지향형 언어이다. 자유도(3가지가 다된다)가 높다보니 어렵다. Node.js의 등장으로 Full stack 개발 언어가 되었다. 2. 브라우저 동작 원리 javascript는 위치가 의미가 있다 dom을 만들기 때문이다. HTML 파서는 script 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진에 제어 권한을 넘긴다. 자바스크립트 엔진의 실행이 완료된 후 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. 이것은 script 태그의 위치에 의해 DOM의 생성이 지연될 수 있음을 의미한다. 3. History ECMAScript 3 : 가장 범용적으로 지원되는 버전이다 (1999.12) ECMAScript 5 : HTML5와 함께 출현한 표준안이다. JSON(JavaScript Object Notation)과 Strict Mode가 추가되었다. 인터넷 익스플로러 9이상이나 그 외 브라우저에서만 작동한다.(2009.12) ECMAScript 6 : let, const 키워드, Arrow Function, class, Symbol 타입 등이 추가되었다. 4. Browsers Support 대부분의 브라우저는 ES6를 지원하고 있지만 100%는 아니다. 그리고 Node.js의 경우 v4부터 지원을 시작하였다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Introduction","slug":"JavaScript/Introduction","permalink":"http://yoursite.com/categories/JavaScript/Introduction/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Introduction","slug":"Introduction","permalink":"http://yoursite.com/tags/Introduction/"}]},{"title":"JavaScript-Coding","slug":"js-study-coding","date":"2017-07-28T03:54:00.000Z","updated":"2017-10-29T12:35:14.000Z","comments":true,"path":"2017/07/28/js-study-coding/","link":"","permalink":"http://yoursite.com/2017/07/28/js-study-coding/","excerpt":"","text":"Javascript Coding 1. Computational thinking coding은 수행되어져야 하는 명령을 컴퓨터에 전달하는 일종의 커뮤니케이션이다. compiler은 인간의 언어를 컴퓨터 언어로 변환시킨다. 문제 해결 능력 : 요구사항을 명확히 이해한 후 해결과제가 일치하는 능력 2. Syntax &amp; Semantics 컴퓨터가 이해할 수 있는 언어인 기계어로 명령을 전달해야 한다. compiler, interpreter 컴퓨터가 이해할 수 있는 기계어로 변환하여 주는 일종의 번역기 이다. compiler : 인간의 언어에 가까운 고급 언어로 작성된 원시 프로그램을 입력으로 받아 기계어(機械語)로 된 목적 프로그램을 출력하기 위해 사용되는 언어 번역 프로그램 interpreter : interpreter language 컴파일러가 필요없다 동시에 번역한다. 단점 : 동시에 통역하기에 에러를 검출하기가 힘들다. 문법에는 당연히 맞게 써야하며 요구사항이 실현 되어야 의미가 있다. 프로그래밍은 요구사항의 집합을 분석하여 적절한 자료구조와 함수의 집합으로 변환한 후 그 흐름을 제어하는 것이다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Syntax","slug":"JavaScript/Syntax","permalink":"http://yoursite.com/categories/JavaScript/Syntax/"}],"tags":[{"name":"Syntax","slug":"Syntax","permalink":"http://yoursite.com/tags/Syntax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript-Syntax","slug":"js-study-syntax","date":"2017-07-28T03:54:00.000Z","updated":"2017-10-31T11:56:57.000Z","comments":true,"path":"2017/07/28/js-study-syntax/","link":"","permalink":"http://yoursite.com/2017/07/28/js-study-syntax/","excerpt":"","text":"Javascript Syntax basics 1. Hello world 정적인 HTML을 동적으로 변경할 수 있는 유일한 방법은 js를 사용하는 것이다. 1234function myFunction() &#123; var myHeader = document.getElementById('demo'); myHeader.innerHTML = 'Hello world!';&#125; 2. 외부의 Javascript 실행하기 HTML과 Javascript는 역할(관심사 Concern)이 다르므로 분리된 파일로 작성하는 것이 바람직하다. 1&lt;script src=\"extern.js\"&gt;&lt;/script&gt; 코드의 실행과정 1.script 요소를 만나면 웹페이지의 파싱을 잠시 중단한다. 2.src 어트리뷰트에 정의된 자바스크립트 파일을 로드한 후 실행한다. 3.중단된 웹페이지의 파싱을 계속 진행한다. body 요소의 가장 아래에 스크립트를 위치시키는 것은 좋은 아이디어이다. HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다. HTML은 script를 만나면 멈추게 된다. 스크립트 로딩 지연으로 인한 병목 현상을 근복적으로 방지하기 위한 어트리뷰트가 추가되었다. 12&lt;script async src=&quot;extern.js&quot;&gt;&lt;/script&gt;&lt;script defer src=&quot;extern.js&quot;&gt;&lt;/script&gt; async = 스크립트는 다운로드 완료 직후 실행된다. defer = 스크립트는 웹페이지 파싱 완료 직후 실행된다. async와 defer 어트리뷰트는 웹페이지 파싱과 외부 스크립트 파일의 다운로드가 동시에 진행된다는 면에서는 동일하다. 하지만 스크립트의 실행 시점이 다르다. IE9이상을 쓸거면 defer가 좋다. 3. JavaScript Output alert box -&gt; alert() HTML output -&gt; document.write() HTML element -&gt; innerHTML Browser console -&gt; console.log() 4. Javascript Syntax Basics4.1 구문(statement) 단계별로 수행될 명령들의 집합이다. 각각의 명령을 statement(구문)이라 하며 statement가 실행되면 무슨 일인가가 일어나게 된다. 구문은 값(Value), 연산자(Operator), 표현식(Expression), 키워드(Keyword), 주석(Comment)으로 구성되며 세미콜론( ; )으로 끝나야 한다. 구문은 block으로 그룹화 되며 이것을 함수라고 부른다. 조건문이나 반복문의 사용으로 제어될 수 있으며 이것을 Control Flow라고 한다. 4.2 표현식(Expression) 결과론 적으로 값 1개로 수렴되는 것이다. 4.2 변수(variable) 값을 저장하거나 참조하기 위해 사용된다. 메모리와 관련이 있다. 유지할 필요가 있는 값을 경우 변수를 사용한다.12var x; // 변수의 선언과 초기화x = 6; // 정수값의 할당 4.4 값(Value)12String str = \"Hello World\";&lt;1&gt; &lt;2&gt; &lt;3&gt; 자바스크립트는 7가지의 데이터 타입을 제공한다. 기본 자료형 Boolean null undefined Number String Symbol(New In ECMAScript 6) object(객체) 12345678910111213// literal : Number10.501001// literal : String'Hello'\"World\"// literal : Object&#123; name: 'Lee', gender: 'male' &#125;// literal : Array[ 'Black', 'Gray', 'White' ]; 4.5 연산자(Operator) 산술 연산자, 대입 연산자, 문자열 연산자, 비교 연산자, 논리 연산자 1234567891011121314// 대입 연산자var color = 'red';// 산술 연산자var area = 5 * 4;// 문자열 연산자var str = 'Hi! ' + 'My name is Lee';// 비교 연산자var foo = 3 &gt; 5; // false// 논리 연산자var bar = (5 &gt; 3) &amp;&amp; (2 &lt; 4); // true 4.6 키워드(keyword) 규정을 미리 정의해둔 것이다. 4.7 주석(Comment) // //(1줄 짜리) or / /(여러줄 짜리) 방법이 있다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Syntax","slug":"JavaScript/Syntax","permalink":"http://yoursite.com/categories/JavaScript/Syntax/"}],"tags":[{"name":"Syntax","slug":"Syntax","permalink":"http://yoursite.com/tags/Syntax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"CSS-Selector","slug":"css-study-seletor","date":"2017-07-19T03:54:00.000Z","updated":"2017-10-08T13:18:06.000Z","comments":true,"path":"2017/07/19/css-study-seletor/","link":"","permalink":"http://yoursite.com/2017/07/19/css-study-seletor/","excerpt":"","text":"CSS-Selector , 를 사용하여서 여러개의 selector를 지정할 수 있다.1h1, p &#123;color: red; &#125; 1. Universal Selector (전체 셀렉터) 를 사용하여서 모든 selector를 선택한다.12/* 모든 요소를 선택 */* &#123; color: red; &#125; 2. Tag Selector (태그 셀렉터) 태그명을 사용하여서 해당되는 selector를 선택한다.12/* 모든 p 태그 요소를 선택 */p &#123; color: red; &#125; 3. ID Selector(ID Selector) #id 을 사용하여서 해당 id를 가진 요소를 선택한다. id attribute 값은 중복될 수 없는 유일한 값이다.12345678/* id 어트리뷰트 값이 p1인 요소를 선택 */#p1 &#123; color: red; &#125;``` ## 4. Class Selector(클래스 셀렉터)- .class를 통하여 일치하는 요소를 선택한다.- class attribute 값은 중복될 수 있다. / class 어트리뷰트 값이 container인 모든 요소를 선택 // color 어트리뷰트는 자식 요소에 상속된다. /.container { color: red; }/ not supported in IE / #p2 { color: initial; }1234## 5. Attribute Selector(어트리뷰트 셀렉터)- selector[attribute] 지정된 어트리뷰트를 갖는 모든 요소를 선택한다. / a 요소 중에 href 어트리뷰트를 갖는 모든 요소 /a[href] { color: red; }12- selector[attribure=&quot;value&quot;] 지정된 어트리뷰트를 가지며 지정된 값과 어트리뷰트의 값이 일치하는 모든 요소를 선택한다. / a 요소 중에 target 어트리뷰트의 값이 “_blank”인 모든 요소 /a[target=”_blank”] { color: red; }12- selector[attribute~=&quot;value&quot;] 지정된 어트리뷰트의 값이 지정된 값을 (`공백으로 분리된`) 단어로 포함하는 요소를 선택한다. / h1 요소 중에 title 어트리뷰트 값에 “first”를 단어로 포함하는 요소 /h1[title~=”first”] { color: red; }12- selector[attribute|=&quot;value&quot;] 지정된 어트리뷰트의 값과 일치하거나 지정 어트리뷰트 값 뒤 연이은 `하이픈(“값-“)`으로 시작하는 요소를 선택한다. / p 요소 중에 lang 어트리뷰트 값이 “en”과 일치하거나 “en-“로 시작하는 요소 /p[lang|=”en”] { color: red; }12- selector[attribute^=&quot;value&quot;] 지정된 어트리뷰트 값으로 `시작하는 요소`를 선택한다. / a 요소 중에 href 어트리뷰트 값이 “https://&quot;로 시작하는 요소 /a[href^=”https://“] { color: red; }12- selector(attribute$=&quot;value&quot;) 지정된 어트리뷰트 값으로 `끝나는 요소`를 선택한다. / a 요소 중에 href 어트리뷰트 값이 “.html”로 끝나는 요소 /a[href$=”.html”] { color: red; }12- selector[attribute*=&quot;value&quot;] 지정된 어트리뷰트 값을 `포함하는 요소`를 선택한다. / div 요소 중에서 class 어트리뷰트 값에 “test”를 포함하는 요소 /div[class=”test”] { color: red; }/ div 요소 중에서 class 어트리뷰트 값에 “test”를 단어로 포함하는 요소 */div[class~=”test”] { background-color: yellow; }12345## 6. Combinator(복합 셀렉터)### 6.1 후손 셀렉터(Descendant Combinator)- space로 구분한다. / div 요소의 후손요소 중 p 요소 /div p { color: red; } paragraph 1 paragraph 2 paragraph 3 / 3개다 허용이다 /123### 6.2 자식 셀렉터(Child Combinator)- SelectorA &gt; SelectorB A의 모든 자식 요소 중 B와 일치하는 요소를 선택한다. / div 요소의 자식요소 중 p 요소 /div &gt; p { color: red; } paragraph 1 paragraph 2 paragraph 3 =&gt; 애만 아니다. 123456### 6.3 동위 셀렉터(Sibling Combinator)- 동위 셀렉터는 동위 관계에서 뒤에 위치하는 요소를 선택할 때 사용한다.#### 6.3.1 인접 형제 셀렉터- SelectorA + SelectorB A바로 뒤에 나오는 B만 선택된다. / p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소를 선택한다. /p + ul { color: red; } A div element. Coffee Tea Milk The first paragraph./ 이 부분 바로 밑에 ul만 선택 / Coffee Tea Milk Another list Coffee Tea Milk 123#### 6.3.2 일반 형제 셀렉터- SelectorA ~ SelectorB A 뒤에 위치하는 B 요소를 모두 선택한다./ p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소를 모두 선택한다./p ~ ul { color: red; } A div element. Coffee Tea Milk The first paragraph. / 이 밑에 ul 다 선택된다. / Coffee Tea Milk Another list Coffee Tea Milk 123456789101112131415## 7. 가상 클래스 셀렉터- 요소의 특정 상태에 따라 스타일을 정의할 때 사용된다.### 7.1 링크 셀렉터, 동적 셀렉터- 마우스가 올라와 있을 때 :hover- 방문하지 않은 링크일 때 :link- 방문한 링크일 때 :visited- 클릭된 상태일 때 :active- 포커스가 들어와 있을 때 :focus### 7.2 UI 요소 상태 셀렉터- 체크 상태일 때 :checked- 사용 가능한 상태일 때 :enabled- 사용 불가능한 상태일 때 :disabled / input 요소가 사용 가능한 상태일 때, input 요소 바로 뒤에 위치하는 인접 형제 span 요소를 선택 / input:enabled + span { color: blue; } / input 요소가 사용 불가능한 상태일 때, input 요소 바로 뒤에 위치하는 인접 형제 span 요소를 선택 / input:disabled + span { color: gray; text-decoration: line-through; } / input 요소가 체크 상태일 때, input 요소 바로 뒤에 위치하는 인접 형제 span 요소를 선택 / input:checked + span { color: red; }1234### 7.3 구조 가상 클래스 셀렉터- first-child 셀렉터에 해당하는 모든 요소 중 첫번째 자식인 요소를 선택한다.- last-child 셀렉터에 해당하는 모든 요소 중 마지막 자식인 요소를 선택한다./ p 요소 중에서 첫번째 자식을 선택 /p:first-child { color: red; }/ p 요소 중에서 마지막 자식을 선택 // body 요소의 두번째 p 요소는 마지막 자식 요소가 아니다.body 요소의 마지막 자식 요소는 div 요소이다. /p:last-child { color: blue; } This paragraph is the first child of its parent (body). Welcome to My Homepage This paragraph is not the first child of its parent. This paragraph is the first child of its parent (div). This paragraph is not the first child of its parent. 12345- nth-child(n) 셀렉터에 해당하는 모든 요소 중 앞에서 n번째 자식인 요소를 선택한다.- nth-last-child(n) 셀렉터에 해당하는 모든 요소 중 뒤에서 n번째 자식인 요소를 선택한다.&gt; n은 0부터 시작하는 정수이다. 0과 음수는 생략되기 때문에 2n+1, 2n-1은 결과적으로 같은 수열을 생성한다. /* ol 요소의 자식 요소인 li 요소 중에서 짝수번째 요소만을 선택 */ ol &gt; li:nth-child(2n) { color: orange; } /* ol 요소의 자식 요소인 li 요소 중에서 홀수번째 요소만을 선택 */ ol &gt; li:nth-child(2n+1) { color: green; } /* ol 요소의 자식 요소인 li 요소 중에서 첫번쨰 요소만을 선택 */ ol &gt; li:first-child { color: red; } /* ol 요소의 자식 요소인 li 요소 중에서 마지막 요소만을 선택 */ ol &gt; li:last-child { color: blue; } /* ol 요소의 자식 요소인 li 요소 중에서 4번째 요소 요소만을 선택 */ ol &gt; li:nth-child(4) { background: brown; } /* ul 요소의 모든 자식 요소 중에서 뒤에서부터 시작하여 홀수번째 요소만을 선택 */ ul &gt; :nth-last-child(2n+1) { color: red; } /* ul 요소의 모든 자식 요소 중에서 뒤에서부터 시작하여 짝수번째 요소만을 선택 */ ul &gt; :nth-last-child(2n) { color: blue; } 12345- :first-of-type 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 첫번째 등장하는 요소를 선택한다.- :last-of-type 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 마지막에 등장하는 요소를 선택한다.- :nth-of-type(n) 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 앞에서 n번째에 등장하는 요소를 선택한다.- :nth-last-of-type(n) 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 뒤에서 n번째에 등장하는 요소를 선택한다. /* p 요소의 부모 요소의 자식 요소 중 첫번째 등장하는 p 요소 */ p:first-of-type { color: red; } /* p 요소의 부모 요소의 자식 요소 중 마지막 등장하는 p 요소 */ p:last-of-type { color: blue; } /* p 요소의 부모 요소의 자식 요소 중 앞에서 2번째에 등장하는 p 요소 */ p:nth-of-type(2) { color: green; } /* p 요소의 부모 요소의 자식 요소 중 뒤에서 2번째에 등장하는 p 요소 */ p:nth-last-of-type(2) { color: orange;} /* p 요소 중에서 첫번째 자식을 선택 */ p:first-child { background: brown;} 1234### 7.4 부정 셀렉터- :not(셀렉터) 셀렉터에 해당하지 않는 모든 요소를 선택한다. / input 요소 중에서 type 어트리뷰트의 값이 password가 아닌 요소를 선택 / input:not([type=password]){background: yellow;}``` 8. 가상 요소 셀렉터 특정 부분에 스타일을 적용하기 위하여 사용된다. 요소 콘텐츠의 첫글자 또는 첫줄 요소 콘텐츠의 앞 또는 뒤 가상 요소에는 ::를 사용한다. ::first-letter 콘텐츠의 첫글자를 선택한다. ::first-line 콘텐츠의 첫줄을 선택한다. 블록 요소에만 적용할 수 있다. ::after 콘텐츠의 뒤에 위치하는 공간을 선택한다. 일반적으로 content 어트리뷰트와 함께 사용된다. ::before 콘텐츠의 앞에 위치하는 공간을 선택한다. 일반적으로 content 어트리뷰트와 함께 사용된다. ::selection 드래그한 콘텐츠를 선택한다. iOS Safari 등 일부 브라우저에서 동작 않는다.","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"},{"name":"Selector","slug":"CSS/Selector","permalink":"http://yoursite.com/categories/CSS/Selector/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Selector","slug":"Selector","permalink":"http://yoursite.com/tags/Selector/"}]},{"title":"CSS-Syntax","slug":"css-study-syntax","date":"2017-07-19T03:54:00.000Z","updated":"2017-10-15T12:27:18.000Z","comments":true,"path":"2017/07/19/css-study-syntax/","link":"","permalink":"http://yoursite.com/2017/07/19/css-study-syntax/","excerpt":"","text":"#CSS-Syntax CSS는 HTML요소의 style을 표현한다. 1.Selector(선택자) styling하려는 요소를 선택한다. 태그명, id(#), class(.) 명으로 가져올 수 있다. 2. Property(속성) ;를 사용하여 여러개의 property를 지정할 수 있다. 3. Value(속성 값) property에 따라서 특정 값을 입력할 수 있다. 4. HTML과 CSS의 연동 Rendering Engine이란?? HTML file을 읽는 능력이 있어야한다.&lt;순차적으로 읽는다.&gt;Html file 읽히는 도중에 CSS file을 서버에서 loading한다.HTML file 읽히는 도중에 JavaScript file도 읽는다 단! Js Engine으로 읽는다.한줄 씩 읽는 것을 parsing 이라고 하며 그 기계를 parser라고하며 Rendering Engine안에 parser, loader가 존재한다.Html 이 parsing을 하면 DOM이 컴퓨터의 메모리에 올라가 있는다.Css 이 parsing을 하면 CSSOM이 컴퓨터의 메모리에 올라가 있는다.결과론 적으로는 DOM + CSSOM = Render Tree가 생성된다. browser 동작원리 4,1 Link style HTML에서 외부에 있는 CSS 파일을 로드하는 방식이다. &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt; 4.2 Embedding style style tag 안에다가 입력하는 방식이다. 4.3 Inline style HTML 요소의 style property에 css를 기술하는 방식이다. Link style을 사용하는 것이 좋다. 5. Reset CSS 사용하기 기본적인 HTML 요소의 CSS를 초기화하는 용도로 사용한다. bootstrap등의 framework를 사용하면 Reset CSS를 사용하지 않아도 된다. Reset CSS 6. CSS Version CSS1 : 1996, CSS2 : 1998, CSS3 : 2005","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"},{"name":"Syntax","slug":"CSS/Syntax","permalink":"http://yoursite.com/categories/CSS/Syntax/"}],"tags":[{"name":"Syntax","slug":"Syntax","permalink":"http://yoursite.com/tags/Syntax/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]}]}