{"meta":{"title":"KimSejune Start Study","subtitle":"Node.js JavaScript","description":null,"author":"Sejune kim","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Node Developer Connect","slug":"node-developer-connect","date":"2017-11-09T03:54:00.000Z","updated":"2017-11-12T12:04:08.000Z","comments":true,"path":"2017/11/09/node-developer-connect/","link":"","permalink":"http://yoursite.com/2017/11/09/node-developer-connect/","excerpt":"","text":"Play Node 발표내용 정리GraphQL + Relay + Serverless필요한 리소스만 요청하고 사용하는 API 만들기장바구니 개발시 Component : cart, proudectlist, productdata 등등단점 : 모바일에서 네트워크 콜을 4가지를 해야하는데 이것이 네트워크가 안좋을때 받기가 힘들다.해결법 : queryString? =&gt; 장기적 개발이 힘들다.해결법 : custom된 endpoint를 생성한다 기기별로(모바일, 웹 등등) =&gt; 여러개의 엔드포인트를 만들기에는 문제가 있다.해결법 : BFF(soundcloud) 모바일을 위해 최적화된 endpoint를 만들어준다. =&gt; 고객마다 needs가 달라서 어렵다. BFF? 프론트엔드를 중심으로 백엔드가 들어간다. 최고의 해결법 : GraphQL =&gt; A Query Language for API API를 위한 질의 언어 12345678910111213141516171819202122232425// 요청&#123; me &#123; name: , company: &#125;&#125;// 응답&#123; me &#123; name: \"김세준\", company: \"학생\" &#125;&#125;// 해당유저의 정보만 요청가능하다&#123; &#123; user(id=1) &#123; name: \"김세준\", company: \"학생\" &#125; &#125;&#125; Post /graphql을 통해 여러개의 component를 1개로 보내준다. GraphQL은 강력한 TypeSystem으로 적용된다. 1234567891011121314151617181920// 형태type Query &#123; cart: Cart&#125;type Cart &#123; products: [product] ! shippingAddess: String!&#125;type Product &#123; imageUrl: String!, description: String!&#125;// 요청&#123; &#123; cart &#125;&#125; Mutation 기존의 것을 변형해서 가져온다. Mutation 1234567891011mutation &#123; createProduct(&#123; input: &#123; desciption: \"clothes\" &#125; &#125;)&#125;&#123; price &#123; product &#125;&#125; =&gt; client가 원하는 데이터 GraphQL의 최대의 강점은 Client가 원하는 값을 딱 그정도만 준다. 단 서버단에서 미리 맞춰야한다. Relay : passing 역할을 합니다. Client가 요청한 데이터를 중간에 Relay가 가로챈다 Relay의 요구사항특정한 id에 대해 요청을 하고 그에대한 응답을 해야합니다. ServerlessFunctions이 핵심 기능이다. input은 event이다. 서버관리의 모든걸 클라우드에게 맡기자 Event가 발생할때만 사용하기 때문에 Price가 적어진다. =&gt; 실행시간, 메모리 소비량, 요청 횟수를 줄인다. GrapeQL하나의 Endpoint에 모든 CRUD, 혹은 그에 속하기 애매한 모든 행위를 담음 POST의 경우 HTTP Payload를 적극적으로 활용application/jsonapplication/graphql 함수형 프로그래밍함수형 프로그래밍 특징 - 순수 함수일급객체 = 변수에 저장할 수 있는가, 파라미터로 전달할 수 있는가, return value로 사용될 수 있을까Persistent Immutable Data = 지속적이고 불변하는 데이터 함수형 프로그래밍이란? 데이터를 가공하는 컨베이어 벨트같은 것이다. 인프런 함수형-프로그래밍 Ramda 실용적인 함수형 프로그래밍 라이브러리 Ramda의 함수들은 모두 자동적으로 Curry 됩니다. R.isNil, R.path, R.compose(a,b,c,d) 1R.compose(R.isNil, R.path([\"req\", \"query\", itemName]))(httpParam); Node.js API 서버 성능 개선기서버 하나의 한계 파악병목구간 확인코드 개선 후 비교 ARTILLERY.IO =&gt; Node.js 작성된 부하 테스트 도구 #","categories":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/categories/Node/"},{"name":"PlayNode","slug":"Node/PlayNode","permalink":"http://yoursite.com/categories/Node/PlayNode/"}],"tags":[{"name":"PlayNode","slug":"PlayNode","permalink":"http://yoursite.com/tags/PlayNode/"}]},{"title":"Node-kue","slug":"node-study-elasticache","date":"2017-10-27T03:54:00.000Z","updated":"2017-10-27T12:26:37.000Z","comments":true,"path":"2017/10/27/node-study-elasticache/","link":"","permalink":"http://yoursite.com/2017/10/27/node-study-elasticache/","excerpt":"","text":"Kue file-type을 이용한 파일 형식 감지 Redis In-memory Database Kue를 이용한 작업 큐 구현 aws-sdk를 통한 AWS S3 사용 Sharp를 이용한 이미지 처리 이미지 처리 라이브러리 express.Router multer를 이용한 multipart/form-data 처리 파일 업로드 지원 JSDoc 주석을 통한 문서 생성 RedisRedis는 대표적인 In-memory 데이터베이스입니다. 간단히 key-value 스토어로 사용하거나, 내장된 다양한 자료구조를 사용할 수 있습니다. 설치macOS의 경우 아래 명령을 통해 설치합니다. 12brew install redisbrew services start redis KueKue는 Node.js 기반 비동기 작업 큐입니다. 데이터 저장과 통신을 위해 Redis를 사용합니다. 주로 CPU 부하가 큰 작업(멀티미디어 처리, PDF 생성 등)을 웹 서버와 분리된 다른 프로세스에서 실행시키기 위한 목적으로 사용됩니다. 어떤 작업을 다른 서버로 넘기기위한 방법이다. ElastiCacheElastiCache는 AWS에서 제공하는 Redis이다. ElastiCache를 사용할 때에는 const queue = kue.createQueue()안에서 AWS에서 생성한 ElastiCache의 end-point를 설정해야한다. ElastiCache를 실행시킬 worker.js를 실행시키기 위해서는 PM2로 실행한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Elasticache","slug":"Node-js/Elasticache","permalink":"http://yoursite.com/categories/Node-js/Elasticache/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"AWS","slug":"AWS","permalink":"http://yoursite.com/tags/AWS/"},{"name":"Elasticache","slug":"Elasticache","permalink":"http://yoursite.com/tags/Elasticache/"}]},{"title":"Node-Project","slug":"node-project-dada","date":"2017-10-08T03:54:00.000Z","updated":"2017-10-27T12:28:25.000Z","comments":true,"path":"2017/10/08/node-project-dada/","link":"","permalink":"http://yoursite.com/2017/10/08/node-project-dada/","excerpt":"","text":"Node Project DADADa, Da&lt;기록과 통계&gt;를 통해 식습관을 모니터링 할 수 있고,칼로리 카운트를 통해 식단을 관리할 수 있는 회원제 &lt;다이어트 다이어리&gt; 서비스 서비스 목표바른 다이어트를 위해서는 건강하고 균형잡힌 식습관을 유지할 필요가 있다. 사용자가 복잡하고 번거로운 칼로리/영양성분 계산을 하지 않아도 되게 하자. 사용자가 식단을 기록하고, 통계를 확인하면서 본인의 식습관을 차차 교정하도록 유도하자. 사용자가 건강한 식습관을 유지할 수 있도록 식단 관리를 서포트해주는 편리한 서비스를 제공하자. 서비스 기능 요약1. 기록(주요 기능) 식단 기록 텍스트 검색과 사진 검색을 지원한다. 검색을 통해 아침/점심/저녁/간식 식사 정보를 기록할 수 있다. 사진 기록 사진을 업로드할 수 있다. 업로드한 사진은 앨범을 통해 보관할 수 있다. 앨범에 저장된 사진은 이후 다른 날 식단 다이어리에서도 첨부하거나 사진 검색에 활용할 수 있다. 일기 기록 당일 장문의 일기와 짧은 반성 일기를 남길 수 있다. 반성 일기는 다음 날 로그인시 홈 로딩화면 위에 표시된다. 체중 기록 시작/목표/현재 체중을 사용자가 직접 입력하거나 삭제 할 수 있다. 시작 체중으로부터 현재 체중까지 변화 양상을 확인할 수 있는 그래프를 제공한다. 2. 리포트 주 별 통계 (차트)사용자의 식사 패턴(식사 시간대, 3대 영양소 비율)에 대한 막대그래프와 요약 정보를 제공한다. 3. 레시피 검색 검색텍스트 검색과 사진 검색을 지원한다. 레시피 정보 원하는 레시피 정보를 조회할 수 있다. 레시피 화면을 통해 요리 진행 사항을 체크할 수 있다. (체크박스 제공) 레시피 재료의 양 정보를 기준 인분 수 입력을 통해 조정된 값으로 제공받을 수 있다. 레시피로 조리된 음식을 식단에 기록할 수 있다. 4. 로그인 로그인은 소셜로그인만 지원한다. 네이버, 카카오, 페이스북, 인스타그램 로그인을 지원한다. 5. SNS공유 식단 및 통계를 미리 디자인된 정적 페이지로 각 소셜에 공유할 수 있다. 팀 구성원프론트엔드 김나영 이혜승 백엔드 김세준 임옥택 조수현 기술 스택 &amp; 툴ProtoType &amp; Design Google spread sheet Sketch Invision Frontend1) UI React React-Router Redux CSS 1-1) Extension or Frameworks Semantic-ui-react (CSS Framework) Draft.js (Text editor Framework) recharts.js (Chart Package) 2) Network fetch API 3) Package Manager yarn 4) Convention &amp; Task Manager editor config prettier (formatter) eslint webpack Backend1) Server Node.js Express 2) Database MYSQL KNEX (node-mysql connector) 3) Open API Googl Vision API AWS (supported: EC2, S3(Image Storage), Caddy): Cloud Web Server Redis(supported: KUE): In-memory data structure store 4) Package Manager npm 5) Convention editor config eslint 6) Error Reporting Manager BugSnag Team Work Git (소스 코드 버전 관리) Zeplin (디자인 시안 공유) 매주 월/화/목 HangOut 온라인 회의: 데일리 스크럼 매주 수/금 오프라인 정기 회의: 이슈 공유 및 논의, 코드 리뷰 Scrum Board 작성: Google Spread Sheet (매일 진행 사항 공유 &amp; 일정 관리) Github &amp; Github Projects (작업 분담(기능별 &amp; 페이지별) 및 이슈 관리) API Document Summary1. 기획1) 와이어프레임 2) 프로토타입 프로토타입 보기 2. 디자인1) 디자인 시안 더 많은 디자인 시안 보기 3. 개발","categories":[{"name":"Project","slug":"Project","permalink":"http://yoursite.com/categories/Project/"},{"name":"ReadMe","slug":"Project/ReadMe","permalink":"http://yoursite.com/categories/Project/ReadMe/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Knex","slug":"Knex","permalink":"http://yoursite.com/tags/Knex/"}]},{"title":"Node-Project","slug":"node-project-dada-redis","date":"2017-10-08T03:54:00.000Z","updated":"2017-10-28T06:55:24.000Z","comments":true,"path":"2017/10/08/node-project-dada-redis/","link":"","permalink":"http://yoursite.com/2017/10/08/node-project-dada-redis/","excerpt":"","text":"Node Project DADARedis Google Vision API와 S3upload를 Promise.All로 처리하면서 sharp로 이미지를 변환하였으나 CPU의 부하를 줄여주기 위하여 Kue + Redis를 사용 하였다. Redis는 In memory Database라고 불리며 배열 형식의 데이터 처리에 특화되어있다. 먼저 promise.all로 구현이 되어있던 부분 중에서 sharp로 처리하는 부분을 제거하고 새로운 promise로 queue.create()를 한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// queue를 사용하기 위해서는 createQueue()를 해주어야 한다. const kue = require('kue')const queue = kue.createQueue()/*createQueue를 설정하는 방법이다.const queue = kue.createQueue(&#123; prefix: 'q', redis: &#123; port: 1234, host: '10.0.50.20', auth: 'password', db: 3, // if provided select a non-default redis db options: &#123; // see https://github.com/mranney/node_redis#rediscreateclient &#125; &#125;&#125;)*/router.post('/', upload.single('upload_img'), (req, res) =&gt; &#123; // jpg image/jpeg &lt;&lt; [ ext, mime ] const &#123; ext, mime &#125; = fileType(req.file.buffer) if (!supportImageExt.includes(ext)) &#123; res.status(400) res.send('지원하지 않는 파일입니다.') &#125; else if (req.file.size &gt; maxFileSize) &#123; res.status(400) res.send('파일 용량은 3mb 까지 입니다.') &#125; const fileName = `$&#123;uuid.v4()&#125;.$&#123;ext&#125;` Promise.all([googleVision(req.file.buffer), s3upload(req.file.buffer, fileName, mime)]) .then(result =&gt; &#123; const filterText = ['food', 'cuisine', 'american food', 'baking', 'flavor', 'recipe', 'fast food', 'dessert', 'dish', 'cookie', 'organism', 'snack', 'font', 'baked goods', 'finger food', 'junk food', 'side dish', 'vegetarian food'] const out = result[0].filter(item =&gt; &#123; if (filterText.indexOf(item.description) &lt; 0) &#123; return item &#125; &#125;) const output = &#123; 'visionAnalysis': out, 'imgUrl': result[1].Location &#125; res.send(output) return output &#125;) .then(result =&gt; &#123; // sharp로 처리하였던 부분을 redis로 처리하기 위하여 새로운 promise 작성 return new Promise((resolve, reject) =&gt; &#123; // queue.create를 생성시 queue.process와 같게 해야하며 2번째 인자로는 전달할 값을 넣어주어야 한다. queue.create('thumbnail', &#123; 'imgUrl': result.imgUrl &#125;) .removeOnComplete(true) .save(err =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve() &#125; &#125;) &#125;) &#125;) .catch(err =&gt; &#123; res.status(400) res.send(err) &#125;)&#125;) redis를 실행시킬 파일 12345678910111213141516171819202122232425262728293031323334const kue = require('kue')const queue = kue.createQueue()// queue.create와 같게 만들어야한다. // 생성시 2번째로 보내주는 값이 url이기 때문에 axios를 통하여 값을 get해야한다.queue.process('thumbnail', (job, done) =&gt; &#123; // image를 다운받기 때문에 responseType에 유의해야한다. axios(&#123; 'method': 'get', 'url': `$&#123;job.data.imgUrl&#125;`, // / options are 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // default // 이곳에서는 arraybuffer가 사용된다. 'responseType': 'arraybuffer' &#125;) .then(response =&gt; &#123; // `data` is the response that was provided by the server console.log('response.body', response.data) const &#123; ext, mime &#125; = fileType(response.data) console.log('ext!!!!!!!!!!!Mim11', ext, mime) const fileName = `$&#123;uuid.v4()&#125;.$&#123;ext&#125;` return sharp(response.data) .resize(200, 200) .crop(sharp.gravity.center) .toBuffer() .then(resizeFile =&gt; &#123; console.log('done') return s3upload(resizeFile, `thumb/$&#123;fileName&#125;`) &#125;) .then(() =&gt; &#123; done() &#125;) &#125;)&#125;)","categories":[{"name":"Project","slug":"Project","permalink":"http://yoursite.com/categories/Project/"},{"name":"redis","slug":"Project/redis","permalink":"http://yoursite.com/categories/Project/redis/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Knex","slug":"Knex","permalink":"http://yoursite.com/tags/Knex/"}]},{"title":"Node-Testablility","slug":"node-study-testablility","date":"2017-09-27T03:54:00.000Z","updated":"2017-10-07T08:46:42.000Z","comments":true,"path":"2017/09/27/node-study-testablility/","link":"","permalink":"http://yoursite.com/2017/09/27/node-study-testablility/","excerpt":"","text":"Testablility테스트 용이성(Testability)는 소프트웨어에 대한 테스트가 얼마나 쉬운지를 말하는 용어입니다. 테스트 용이성이 높을 수록 소프트웨어의 설계가 유연하고 컴포넌트 간 결합도가 낮기 때문에, 좋은 설계라고 할 수 있습니다. 이번 프로젝트에서는 Node.js 기반 소프트웨어를 테스트하는 방법과, Testability를 고려한 설계 방법, 지속적인 통합(Continuous Integration, CI)를 다룹니다. assert 내장 모듈 assert.ok(true) true로 들어오면 true이다. =&gt; !! 뒤에 값을 붙여서 확인가능하다. assert.equal(a, b) a == b가 같은지 확인 assert.strictEqual(a, b) a === b 가 같은지 확인 assert.deepEqual([1,2,3], [1,2,3]) 배열, 객체까지도 같은지를 확인한다. assert.throws(() =&gt; {throw new Error() } ) 나의 의도대로 에러가 발생하는지 테스트 할 때 사용 ex) assert.throws(() =&gt; {throw new MyError()}, MyError) Mocha test framework SuperAgent &amp; SuperTest Testability를 높이기 위한 의존성 주입과 Sinon 지속적인 통합 &amp; Travis CI","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Testablility","slug":"Node-js/Testablility","permalink":"http://yoursite.com/categories/Node-js/Testablility/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Testablility","slug":"Testablility","permalink":"http://yoursite.com/tags/Testablility/"}]},{"title":"Node-Linux-AWS(EC2)","slug":"node-linux-awsEC2","date":"2017-09-26T03:54:00.000Z","updated":"2017-10-06T12:55:43.000Z","comments":true,"path":"2017/09/26/node-linux-awsEC2/","link":"","permalink":"http://yoursite.com/2017/09/26/node-linux-awsEC2/","excerpt":"","text":"Linux TutorialEC2AWS EC2(Elastic Compute Cloud)는 리눅스 및 Windows 가상 서버를 제공하는 AWS 서비스입니다. 서버를 사용한 시간만큼만 과금되고, 필요에 따라 서버의 갯수를 늘였다가 줄였다가 하는 일을 자유롭게 할 수 있습니다. 또한 서버를 다시 구축할 필요 없이 서버의 사양을 높이거나 낮출 수도 있습니다. 인스턴스 및 AMI 리전 및 가용 영역 IAM 역할 EC2에 AWS roles를 꼭 붙인다. 보안 그룹 Elastic Block Store 키 페어 EC2 인스턴스에 접속하기 위해 키 페어가 필요합니다. 인스턴스 생성 시 다운로드 받은 비밀 키를 잃어버리면 인스턴스에 접속할 수 없게 되니 주의하세요. SSHSSH(Secure Shell)는 네트워크 상의 다른 컴퓨터에 접속해서 명령을 실행하거나 파일을 전송할 수 있도록 해 주는 응용 프로그램, 혹은 그 프로토콜을 말합니다. 보통 22번 포트를 사용합니다. SSH는 통신을 암호화하기 때문에 다른 사람이 통신의 내용을 엿볼 수 없습니다. Git 역시 통신을 위해 SSH 프로토콜을 사용하고 있습니다. EC2 인스턴스 역시 SSH를 통해 접속할 수 있습니다. 접속을 위해서 인스턴스 생성 시에 부여받은 비밀 키가 필요합니다. EC2 Instances 페이지 상단의 Connect 버튼을 눌러 가이드를 따라하세요. 리눅스에서 자주 사용되는 명령아래에 자주 사용하는 리눅스 명령을 모아두었습니다. man 명령을 사용하면 다른 명령에 대한 도움말을 표시할 수 있습니다. (예: man ls) 파일 관리 명령 ls: 디렉토리의 내용을 표시합니다. pwd: 작업 디렉토리를 표시합니다. touch: 빈 파일을 만듭니다. cp: 파일 혹은 디렉토리를 복사합니다. mv: 파일 혹은 디렉토리를 이동합니다. 이름을 바꿀 때에도 사용됩니다. rm: 파일 혹은 디렉토리를 삭제합니다. chmod: 파일의 접근 권한을 설정합니다. chown: 파일의 소유자를 변경합니다. ln: 파일 링크를 만듭니다. symbolic link를 만든다. =&gt; symbolic link는 절대경로를 사용해야한다 ls -al 를 통하여 자세한 정보를 받아올 수 있다. 시스템 및 접속 정보 who: 시스템에 접속 중인 계정을 표시합니다. whoami: 현재 접속자의 계정 이름을 표시합니다. date: 현재 시간을 표시합니다. top: 시스템 자원과 프로세스의 정보를 표시합니다. 이와 유사하지만 더 편리하게 사용할 수 있는 htop라는 도구도 있습니다. free: 시스템의 메모리 사용량을 표시합니다. df: 시스템의 디스크 사용량을 표시합니다. du: 파일 및 디렉토리의 디스크 사용량을 표시합니다. -r option으로 폴더도 복사할 수 있다. rm -rf 으로 폴더를 삭제할 수 있다. 프로세스 관리 sleep: 쉘을 일정 시간동안 정지시킵니다. ps: 시스템에서 실행되고 있는 프로세스의 정보를 표시합니다. jobs: 현재 쉘에서 실행 중인 작업을 표시합니다. fg: 중지되었거나 백그라운드에서 실행되고 있는 작업을 포그라운드로 표시합니다. bg: 중지되어 있는 작업을 백그라운드에서 실행시킵니다. kill: 특정 프로세스를 종료합니다. nohup: 터미널이 종료되어도 프로세스가 종료되지 않도록 합니다. 파일의 내용 표시 cat: 파일의 내용을 출력합니다. less: 파일의 내용을 스크롤하며 탐색합니다. tail: 파일의 마지막 부분의 내용을 출력합니다. echo: 문자열을 출력합니다. wc: 파일의 단어 갯수를 세어 표시합니다. tee: 표준 입력으로 출력과 파일 저장을 동시에 합니다. 기타 grep: 파일의 내용을 필터링합니다. curl: URL을 통해 통신을 합니다. curl 명령을 통해 파일을 다운로드 받을 수 있습니다. clear: 터미널 화면의 내용을 비웁니다. sudo: 관리자 권한으로 명령을 실행합니다. 패키지 관리 apt: 데비안 계열 리눅스의 패키니 매니저인 패키지를 설치합니다. 리눅스 참고자료SubshellRedirectionPipeJobSignal CyberduckCyberduck은 SSH를 통해 파일을 전송할 수 있는 프로토콜인 SFTP을 지원하는 파일 브라우저입니다. SFTP 외에도 많은 프로토콜 및 서비스를 지원합니다. Cyberduck을 이용해 편하게 EC2에 파일 전송을 할 수 있습니다. SFTP 연결을 새로 만들고 EC2 주소와 EC2 비밀 키를 넣어 주면 됩니다. RDSRDS는 클라우드에서 관계형 데이터베이스를 제공하는 AWS 서비스입니다. EC2와 유사하게 유연한 배포 및 확장이 가능합니다. MySQL, PostgreSQL, Oracle, MS SQL 등의 다양한 RDBMS를 지원합니다. RDS 보안 그룹RDS 보안 그룹의 소스로 다른 보안 그룹을 지정할 수 있습니다. 이렇게 설정하면, 외부(인터넷)으로부터의 접속은 막히는 대신 해당 보안 그룹을 사용하는 모든 인스턴스(일반적으로 애플리케이션 서버)에서 수신 트래픽이 허용됩니다. 자세한 내용은 공식 문서를 참고해주세요. 위와 같은 보안 그룹 설정을 적용하면 일반적인 방식으로는 보안 그룹 바깥에서 RDS 인스턴스에 접속할 수 없게 됩니다. 대신 SSH 터널링을 활용해 SSH를 거쳐서 접속하면, 바깥에서도 RDS 인스턴스에 접속할 수 있습니다. MySQL Workbench를 이용하면 SSH를 거치는 MySQL 커넥션을 쉽게 만들 수 있습니다. Git을 이용한 웹 서버 배포이제 이전에 실습했었던 채팅 서버를 EC2와 RDS를 사용해서 배포해보겠습니다. 일단 서버에서 Github 저장소를 복제하기 위해서는 SSH key 생성과 등록이 필요합니다. 12$ ssh-keygen$ cat ~/.ssh/id_rsa.pub 그 다음, 보안 그룹이 잘 설정되었는지 확인하고 EC2 주소에 접속해보세요. Route 53Route 53은 도메인과 관련된 기능을 제공하는 AWS 서비스입니다. Route 53을 통해 도메인 구입, DNS 서버 설정 등을 할 수 있습니다. Route 53에서 구입한 도메인을 EC2 인스턴스에 연결시킬 수 있습니다. 자세한 내용은 공식 문서를 참고해주세요. PM2Node.js로 만들어진 웹 서버는 예기치 못한 에러 때문에 종료되어버리는 경우도 있고, 메모리 누수가 발생하는 경우도 잦습니다. 이런 문제를 해결하기 위해 서버가 예상치 못한 이유로 종료되었을 때 서버를 재시작해주고, 또 메모리 사용량이 일정량 이상이 되면 서버를 재시작해주는 등의 작업이 필요합니다. 이런 작업을 자동화해주는 도구를 보고 프로세스 매니저라고 부릅니다. PM2는 Node.js 생태계에서 가장 널리 사용되는 프로세스 매니저입니다. 비슷한 다른 도구들과 비교했을 때 사용하기 쉽고 편의 기능이 많습니다. 또한 Node.js 모니터링 도구인 Keymetrics와 긴밀하게 통합됩니다. 또한 PM2에는 Node.js cluster를 자동 생성해주는 기능 및 로드 밸런서가 포함되어 있어서, 고성능 웹 서버를 쉽게 운영할 수 있도록 해줍니다. Cluster에 대한 자세한 설명은 공식 문서를 참고해주세요. 많은 서버를 다룰때에는 Node.js cluster를 통해서 서버를 다룰줄 알아야한다. 보통 아래와 같이 프로세스 정의 파일을 통해 실행할 스크립트와 환경변수 등을 설정한 후, 해당 설정에 이름을 붙여서 실행하게 됩니다. 자세한 사용법은 공식 문서를 참고해주세요. pm2로 실행을 해두면 터미널을 종료하여도 서버가 끝나지 않는다. pm2를 사용할때 여러개의 서버를 한번에 관리할 수 있다. 1234567891011121314# 설치방법npm install -g pm2# 실행방법pm2 start src/index.js# 실행 목록pm2 ls# 실행 목록 삭제pm2 appname delete# 원하는 이름으로 실행pm2 start src/index.js --name 원하는이름 12345678910111213# process.ymlapps: - script : ./api.js name : 'api-app' instances: 4 exec_mode: cluster - script : ./worker.js name : 'worker' watch : true env : NODE_ENV: development env_production: NODE_ENV: production 123456789101112131415161718192021222324252627282930313233343536$ pm2 start process.yml --name myapp``` ## Reverse Proxy리버스 프록시는 웹 서버의 일종으로, 시스템의 바깥 쪽에서 내부에 있는 웹 서버로 요청을 전달해주는 기능을 합니다. 리버스 프록시는 보통 다음과 같은 역할을 수행합니다. - DDoS 등의 공격을 막는 방화벽- 부하를 분산시키는 로드 밸런서- 정적 컨텐츠 제공- 압축- 하나의 IP 주소와 포트를 이용해 여러 개의 웹 서버 운영## Caddy[Caddy](https://caddyserver.com/)는 [리버스 프록시 기능](https://caddyserver.com/docs/proxy)을 내장하고 있는 웹 서버로, 인증서 등록 및 설치를 자동으로 해주기 때문에 굉장히 편하게 HTTPS 웹 서버를 운영할 수 있습니다. 또한 Caddyfile이라는 간단한 문법의 설정 파일을 통해 웹 서버를 설정하도록 하고 있습니다. 아래는 리버스 프록시 설정을 한 Caddyfile 예제입니다. - EC2를 실행한 후에 Caddy를 실행시킬 수 있습니다.```bash# https://example.com URI로 들어온 요청을 http://localhost:3000 서버에 연결시킴# http://example.com 쪽으로 들어온 요청은 https로 리다이렉트example.com &#123; proxy / localhost:3000 &#123; # 리버스 프록시에 요청이 어떤 형태(IP, 프로토콜)로 왔는지를 # 뒤쪽 서버에 별도의 헤더를 통해 전달 transparent &#125;&#125;chat.example.com &#123; proxy / localhost:4000 &#123; transparent # 웹소켓 요청도 전달하기 websocket &#125;&#125; Caddyfile을 작성한 뒤에 해당 폴더에서 caddy 명령을 통해 Caddy 웹 서버를 실행시킬 수 있습니다. 터미널이 꺼져도 계속 Caddy가 실행되게 하려면 아래의 명령을 실행하면 됩니다. 1$ nohup caddy &amp; HTTPS를 사용하려면 먼저 DNS 설정이 되어 있어야 합니다. Route 53에서 먼저 DNS 설정을 한 뒤에 Caddy를 실행시켜 주세요. Reverse Proxy + Express리버스 프록시를 통해 운영되는 Express 웹 서버가 IP 추적 기능이나 쿠키를 사용한다면 반드시 trust proxy 옵션을 설정해주어야 합니다. 자세한 사항은 공식 문서를 참고해주세요.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Linux","slug":"Node-js/Linux","permalink":"http://yoursite.com/categories/Node-js/Linux/"},{"name":"AWS","slug":"Node-js/Linux/AWS","permalink":"http://yoursite.com/categories/Node-js/Linux/AWS/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"AWS","slug":"AWS","permalink":"http://yoursite.com/tags/AWS/"}]},{"title":"Node-SPA-security-authentication","slug":"node-study-spa-security-authentication","date":"2017-09-25T03:54:00.000Z","updated":"2017-10-05T02:38:34.000Z","comments":true,"path":"2017/09/25/node-study-spa-security-authentication/","link":"","permalink":"http://yoursite.com/2017/09/25/node-study-spa-security-authentication/","excerpt":"","text":"170925 WPSN SPA Security &amp; AuthenticationSPA SecuritySPA(Single-Page Application)은 사용자 경험이 좋은 만큼 프론트엔드와 백엔드의 코드가 복잡해지는 경우가 많습니다. SPA와 API 서버의 출처가 같은 경우, 보안과 인증을 위해 전통적 방식대로 쿠키를 쓸 수 있습니다. 다만 쿠키를 위한 보안 정책(CSRF 등)은 당연히 적용해야 합니다. SPA와 API 서버의 출처가 다른 경우에도 쿠키를 사용할 수 있지만, 여러가지 문제(구현 상 불편함, 보안의 취약함)때문에 보통 쿠키 대신 JWT와 같은 토큰을 사용하는 경우가 많습니다. 일단은 출처가 다르므로 CORS 보안 정책에 대한 구현이 필요한데, 이 때 설정을 통해서 특정 출처의 Ajax 요청에 대해서만 API 서버에 접근 가능하도록 제한을 둘 수 있습니다. 1234app.use(cors(&#123; origin: 'http://example.com', optionsSuccessStatus: 200 // some legacy browsers (IE11, various SmartTVs) choke on 204 &#125;)) 기존 page : window.open(‘http:google.com’)열린 page : window.opener // 나를 연 page를 참조 window.opener.postMessage(‘send message’, ‘*’) 기존 page : window.addEventListerner(‘message’, e =&gt; { console.log(e.data)}) SPA AuthenticationSPA의 인증을 위해 단순하게 인증을 위한 REST API를 둘 수도 있을 것입니다. 하지만 회원가입과 로그인은 누구나 할 수 있어야 한다는 특성때문에 REST API가 공격을 받을 위험이 커지게 됩니다. 그래서 회원가입과 로그인 만큼은 SPA + REST API를 통해서 하는 것이 아니라, CSRF와 Captcha 등의 보안 정책을 적용한 별도의 웹 페이지를 통해 해주는 것이 좋습니다. 이런 전략을 사용하면 SPA와 웹 페이지 간에 토큰을 주고 받을 필요가 있는데, 이를 위해 팝업(window.open)과 윈도우 간 메시지 통신(window.postMessage)을 사용합니다. redirect 로그인, 회원가입을 하면 토큰을 포함 시킨 경로를 가지고 spa로 redirect 시킬 수 있다. popup =&gt; window.open, window.postMessage사용 아래의 두 프로젝트를 통해 직접 SPA 인증 절차를 시험해 볼 수 있습니다. api 프로젝트는 passport를 이용해서 Github OAuth 로그인을 구현한 프로젝트입니다. spa 프로젝트는 React를 이용해서 API 서버에 접속할 수 있는 프로젝트입니다. 인증 절차는 다음과 같이 구현되었습니다. SPA에서 API 서버의 /auth/ 경로에 대해 팝업을 열고 message 이벤트에 대한 핸들러를 등록합니다. 사용자는 API 서버에 대해 열린 팝업에서 로그인을 시도합니다. 로그인이 성공하면, 팝업에서 window.opener.postMessage(…)를 통해 SPA에 토큰을 전달합니다. 이제부터 SPA에서 토큰을 통해 인증된 요청을 보낼 수 있게 됩니다. 인증 절차에 대한 자세한 사항은 코드를 참고해주세요.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"SPA","slug":"Node-js/SPA","permalink":"http://yoursite.com/categories/Node-js/SPA/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"SPA","slug":"SPA","permalink":"http://yoursite.com/tags/SPA/"}]},{"title":"Node-Rest-API","slug":"node-study-restapi2","date":"2017-09-25T03:54:00.000Z","updated":"2017-10-05T02:38:41.000Z","comments":true,"path":"2017/09/25/node-study-restapi2/","link":"","permalink":"http://yoursite.com/2017/09/25/node-study-restapi2/","excerpt":"","text":"REST(Representaitonal State Transfer)REST(Representaitonal State Transfer)는 HTTP나 JSON 같은 기술 표준아닙니다. REST는 로이 필딩이라는 사람이 아파치 웹 서버와 HTTP 1.1을 설계할 때 세웠던 원칙들을 모아서 쓴 그의 박사학위 논문에서 처음 제시한 뒤 널리 퍼진 개념입니다. REST는 웹 서비스를 만들 때 아래와 같은 설계 규칙을 지키도록 명시하고 있습니다. 클라이언트-서버 아키텍처 무상태(statelessness): 클라이언트의 세션 상태는 웹 서버 대신 클라이언트에 저장되어야 합니다. 어떤 값이 어디에 저장될지 모르기 때문에 웹 서버에 저장되면 안된다. 캐시 가능: 웹 서버의 응답은, 캐시 가능 여부에 대한 정보를 포함해야 합니다. 계층 시스템: 클라이언트는 요청이 정확히 어느 웹 서버에 도달할 지, 중간 매체가 있는지 없는지를 모르더라도 별다른 문제없이 서비스를 사용할 수 있어야 합니다. 일관된 인터페이스 자원은 URI를 통해서 식별하고, 자원의 제공 형태를 식별자에 포함시키지 않습니다. 서버가 요청을 잘 처리할 수 있도록 각 요청은 충분한 정보를 포함하고 있어야 합니다. (Content-Type 등) 필요 시 코드 전송(Code on demand): 웹 서버는 자바 애플릿, 플래시, 자바스크립트 등의 제공을 통해 클라이언트의 기능을 확장시킬 수 있습니다. 위 설계 원칙을 따름으로써 웹 서버는 아래의 좋은 속성들을 가질 수 있게 됩니다. 높은 성능 확장가능성(Scalability) 인터페이스의 단순함 웹 서버의 실시간 업데이트가 가능 Sticky Session 사용자가 사용했던 한개의 서버로만 접속하게 하는 것 : 좋지 않은 방법이다. REST API위의 REST 원칙을 따르는 웹 API를 가지고 REST API라고 부릅니다. REST API 역시 REST와 같이 표준화 된 기술은 아닙니다만, 개발자 커뮤니티에서 합의가 되어 있는 best practice 들이 있습니다. RESTful URI 설계REST API의 URI는 기본적으로 ‘자원’을 나타냅니다. URI를 통해 자원을 표현할 때는 다음과 같은 기본 원칙을 따르도록 합니다. 슬래시(/) 문자는 자원 간 계층관계를 나타내는 데 사용합니다. 마지막 문자로 슬래시를 포함하지 않습니다. 띄어쓰기를 표현할 때는 하이픈(-)을 사용하고, 밑줄(_)을 사용하지 않는다 대문자 대신 소문자만을 사용합니다. 경로에 확장자를 쓰지 않습니다. 내용 협상을 위해서는 Accept 헤더를 사용합니다. 자원은 하나일 수도, 여러 개일수도, 혹은 특정한 동작을 나타내는 것일 수도 있습니다. Document도큐먼트는 보통 하나의 객체 혹은 데이터베이스 레코드를 나타내는 단일 자원입니다. URI에서는 아래와 같이 단수 명사로 표기합니다. 123https://api.example.com/userhttps://api.example.com/service-infohttps://api.example.com/resource Collection컬렉션은 보통 여러 개의 객체 복수의 자원 혹은 데이터베이스의 여러 레코드를 나타내는 자원입니다. 도큐먼트는 파일에, 컬렉션은 폴더에 비유할 수 있습니다. 12https://api.example.com/todoshttps://api.example.com/articles 컬렉션 뒤에 자원의 식별자를 붙여서 도큐먼트를 나타낼 수도 있습니다. 12https://api.example.com/todos/123https://api.example.com/articles/how-to-design-rest-api Controller자원에 대한 단순한 CRUD(Create, Read, Update, Delete)는 HTTP 메소드를 통해서 할 수 있지만, 단순 CRUD가 아닌 경우에는 자원 뒤에 동사를 붙여서 해당 동작을 표현할 수 있습니다. 우리의 절차를 걸치지 않고 다른 사람이 데이터베이스를 변경할 수 도 있다. 밑에 예제 처럼해야한다. controller에 대해서는 없는 기능에 대해서는 post 요청을 사용한다. 1https://api.example.com/todos/123/finish REST API 통신 설계기본적으로 의미에 맞는 HTTP 메소드와 상태 코드를 사용해주세요. 컬렉션, 도큐먼트, 컨트롤러에 대해서는 HTTP 메소드를 아래와 같이 사용합니다. 123456789# 컬렉션에 속해있는 자원을 모두 가져오기 위해 컬렉션 URI에 GET 요청을 보냅니다.GET https://api.example.com/todos# 컬렉션에 대한 filtering이나 pagination을 위해 쿼리 스트링을 사용할 수 있습니다.GET https://api.example.com/todos?complete=true&amp;assignee=meGET https://api.example.com/todos?page=2# 컬렉션 내에 새로운 자원을 생성하기 위해 POST 요청을 보냅니다.POST https://api.example.com/todos 12345678910# 단일 도큐먼트를 읽어오기 위해 도큐먼트 URI에 GET 요청을 보냅니다.GET https://api.example.com/userGET https://api.example.com/todos/123# 도큐먼트를 수정하기 위해 PUT(치환) 혹은 PATCH(변경) 요청을 보냅니다.PUT https://api.example.com/todos/123PATCH https://api.example.com/user# 도큐먼트를 삭제하기 위해 DELETE 요청을 보냅니다.DELETE https://api.example.com/todos/123 이런 식으로 하면 안 됩니다! 12345678# 자원의 생성을 위한 URI가 따로 존재하고 GET 메소드를 사용하는 경우GET /add_todo?title=mytodo# 자원 식별자를 쿼리 스트링에 포함시키는 경우GET /todo?id=1# 자원의 삭제를 위해 POST 메소드를 사용하는 경우POST /todos/1/delete?id=1 get으로 절대로 자원을 생성해서는 안된다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Rest-API","slug":"Node-js/Rest-API","permalink":"http://yoursite.com/categories/Node-js/Rest-API/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"RestAPI","slug":"RestAPI","permalink":"http://yoursite.com/tags/RestAPI/"}]},{"title":"Node-kue","slug":"node-study-kue","date":"2017-09-21T03:54:00.000Z","updated":"2017-10-04T11:37:38.000Z","comments":true,"path":"2017/09/21/node-study-kue/","link":"","permalink":"http://yoursite.com/2017/09/21/node-study-kue/","excerpt":"","text":"Kue file-type을 이용한 파일 형식 감지 Redis In-memory Database Kue를 이용한 작업 큐 구현 aws-sdk를 통한 AWS S3 사용 Sharp를 이용한 이미지 처리 이미지 처리 라이브러리 express.Router multer를 이용한 multipart/form-data 처리 파일 업로드 지원 JSDoc 주석을 통한 문서 생성 file-typefile-type은 파일의 내용을 확인해서 그 파일이 어떤 형식의 파일인지를 탐지해주는 라이브러리입니다. 웹 브라우저와 Node.js 모두에서 동작합니다. Node.js의 경우 바이너리 파일을 담는 클래스인 Buffer의 인스턴스를 이용해 파일 형식을 탐지할 수 있습니다. fs 모듈의 readFile 혹은 readFileSync 메소드를 이용하면 Buffer 클래스를 사용해볼 수 있습니다. fs는 내장 모듈로써 설치하지 않아도 바로 사용가능하다. 12345678const fs = require('fs')const fileType = require('file-type')const buffer = fs.readFileSync('image.png')console.log(buffer instanceof Buffer)// trueconsole.log(fileType(buffer))// &#123; ext: 'png', mime: 'image/png' &#125; RedisRedis는 대표적인 In-memory 데이터베이스입니다. 간단히 key-value 스토어로 사용하거나, 내장된 다양한 자료구조를 사용할 수 있습니다. 설치macOS의 경우 아래 명령을 통해 설치합니다. 12brew install redisbrew services start redis Key-value storeredis-cli를 실행해서 아래 명령을 시험해보세요. 123456789101112131415161718192021222324252627// redis-cli 시작redis-cli// key-value 추가set mykey 'Hello Redis!'// value 가져오기get mykey// value 1 증가시키기incr mycount// value 5 증가시키기incrby mycount 5// value 1 감소시키기decr mycount// key가 존재하는지 확인exists mykeyexists yourkey// key 삭제del mykey// 5초 뒤 key 삭제expire mycount 5 Data structuresRedis는 다양한 데이터 구조를 내장하고 있습니다. 아래 list 관련 명령을 시험해보세요. 123456789101112131415// 리스트 오른쪽에 요소 추가rpush mylist 1rpush mylist 2 3 4 5// 범위 가져오기lrange mylist 0 2// 리스트 왼쪽에 요소 추가lpush mylist 6 7 8 9// 리스트 왼쪽 요소 제거lpop mylist// 리스트 오른쪽 요소 제거rpop mylist 아래 hash 관련 명령을 시험해보세요. 12345678// 해시 속성 추가hmset user:1000 username fast password campus birthyear 2014// 해시 속성 가져오기hget user:1000 username// 해시 속성 모두 가져오기hgetall user:1000 아래 set 관련 명령을 시험해보세요. 12345678910111213// 집합에 요소 추가sadd myset 1 2 3// 모든 요소 가져오기smembers myset// 집합의 요소인지 확인sismember myset 1// 랜덤 뽑기sadd deck 1 2 3 4 5spop deckspop deck 이 밖에 Redis는 sorted set, bitmap, hyperloglog 등의 자료 구조를 지원합니다. 자세한 내용은 공식문서를 참고해주세요. Pub/SubRedis는 데이터의 저장 외에 프로세스 간 통신을 위한 발행/구독 기능을 가지고 있습니다. 두 개의 redis-cli를 실행한 다음 한 쪽에서는 구독, 한 쪽에서는 발행 명령을 실행해보세요. sub으로 채널을 생성한다. pub으로 sub로 생성된 채널에 메시지를 보낼 수 있다. 12345// 채널 구독subscribe mychannel// 메시지 발행publish mychannel 'Hello Redis!' KueKue는 Node.js 기반 비동기 작업 큐입니다. 데이터 저장과 통신을 위해 Redis를 사용합니다. 주로 CPU 부하가 큰 작업(멀티미디어 처리, PDF 생성 등)을 웹 서버와 분리된 다른 프로세스에서 실행시키기 위한 목적으로 사용됩니다. 어떤 작업을 다른 서버로 넘기기위한 방법이다. 다음과 같이 작업을 생성합니다. 1234567891011121314151617const kue = require('kue')const queue = kue.createQueue(&#123; /* 작업 큐 설정 */ // 이곳에서 radis관련 설정을 할 수 있다.&#125;)const jobData = &#123; imageUrl: 'https://example.com/image.png', type: 'png'&#125;queue.createJob('make-thumbnail', jobData)// 작업이 끝난 뒤에 꼭 지워주는 removeOnComplete 옵션을 써야한다. .removeOnComplete(true) .save(err =&gt; &#123; if (err) &#123; /* 에러 처리 */ &#125; &#125;) 위에서 생성된 작업을 다음과 같이 받아서 실행합니다.123456789101112131415const kue = require('kue')const queue = kue.createQueue(&#123; /* 작업 큐 설정 */&#125;)// 작업을 동시에 10개까지 실행 job 개겣를 받는다.queue.process('make-thumbnail', 10, (job, done) =&gt; &#123; processImage(job.imageUrl, job.type) .then(() =&gt; &#123; done() &#125;) .catch(err =&gt; &#123; done(err) &#125;)&#125;) AWS S3AWS S3는 클라우드 파일 저장소입니다. 여러 프로그래밍 언어로 된 API를 통해 파일을 관리할 수 있고, 저장소 용량에 제한이 없으며 사용한 만큼만 비용을 지불하면 됩니다. (프리 티어 계정이라면 본 실습에서 사용하는 사용량 정도로는 과금이 될 일이 없으니 안심하세요!) S3 사용을 위해서는 AWS 계정과 AWS CLI 설정이 필요합니다. AWS CLI 설치macOS 사용자는 터미널에서 아래의 명령을 차례대로 실행하세요. 1234brew install python3pip3 install --user --upgrade awscliecho 'PATH=$HOME/Library/Python/3.6/bin:$PATH' &gt;&gt; ~/.zshrcaws --version 설치 후, aws configure 명령을 실행하여 계정 생성시에 부여받은 AWS access key ID와 secret key를 입력하세요. 파일 업로드Node.js에서는 aws-sdk npm 패키지를 통해 AWS의 모든 서비스를 사용할 수 있습니다. 아래와 같이 S3에 파일을 업로드할 수 있습니다. aws sdk 참고 자료 1234567891011121314151617const aws = require('aws-sdk')const s3 = new aws.S3(&#123; apiVersion: '2006-03-01'&#125;)const buffer = ... // 업로드 할 파일s3.upload(&#123; ACL: 'public-read', // 익명의 사용자도 파일 경로만 알면 읽기 가능하도록 설정 Body: buffer, Bucket: 'my-bucket-name', Key: 'my-file-name', ContentDisposition: ... // Content-Disposition 헤더 ContentType: ... // Content-Type 헤더&#125;, (err, data) =&gt; &#123; console.log(data.Location)&#125;) s3에서 버킷을 생성한다. 버킷은 URL에 들어갈 수 있는 이름으로 작성해야한다. sharpsharp는 Node.js에서 사용할 수 있는 고속 이미지 프로세싱 라이브러리입니다. 다양한 이미지 처리를 지원합니다. (크기 조정, 병합, 회전, 블러, 색조 변경 등) 자세한 사용법은 공식 문서를 참고하세요. 이 프로젝트에서는 썸네일 이미지 생성을 위해 크기 조정 기능을 사용해보겠습니다. 아래와 같이 크기 조정을 할 수 있습니다. 설치가 되지 않을 경우1. xcode-select --install2. npm install node-gyp 123456sharp('image.png') .resize(200, 200) // 비율에 맞게 줄인다. .crop(sharp.gravity.center) // 중앙을 남기고 잘른다. .toFile('output.png', (err, info) =&gt; &#123; console.log(info) &#125;) Buffer를 사용하는 경우 아래와 같이 작성할 수도 있습니다. 1234567sharp(inputBuffer) .resize(200, 200) .crop(sharp.gravity.center) .toBuffer() .then(buffer =&gt; &#123; ... &#125;) 12345678910111213141516const sharp = require('sharp')const fs = require('fs')sharp('photo.jpg') .resize(200, 200) .crop(sharp.gravity.center) .toFile('output.png', (err, info) =&gt; &#123; console.log(info) &#125;)const buffer = fs.readFileSync('photo.jpg')sharp(buffer) .resize(200, 200) .crop(sharp.gravity.center) .toFile('output2.png', (err, info) =&gt; &#123; console.log(info) &#125;) express.Routerexpress.Router를 사용하면 여러 라우트 핸들러를 묶어 모듈화시킬 수 있습니다. Router 인스턴스는 app과 비슷하게 사용하며, Router 인스턴스 자체도 미들웨어이므로 app.use메소드를 통해 사용할 수 있습니다. 1234567891011const router = express.Router()router.use(...)router.get('/some-path', (req, res) =&gt; &#123; ...&#125;)router.post('/other-path', (req, res) =&gt; &#123;&#125;) 1234567891011121314151617181920212223242526272829const express = require('express')const app = express()const router = express.Router()router.get('/', (req, res) =&gt; &#123; res.send('hello router')&#125;)const router2 = express.Router()router2.get('/', (req, res) =&gt; &#123; res.send('hello router2')&#125;)router2.use((req, res, next) =&gt; &#123; res.status(404) res.end('Not Fount')&#125;)app.use(router)app.use('/router2', router2)app.listen('3000', (req, res) =&gt; &#123; console.log('connect!!')&#125;) 위와 같이 라우터 인스턴스를 정의한 이후 app에 마운트하여 사용합니다. 123456789101112131415161718192021222324252627282930313233343536373839// 아래와 같이 마운트하면 됩니다.app.use(router)// 혹은 특정 경로에 마운트할 수도 있습니다.// 이제부터 /api/some-path, /api/other-path 주소로 접속해야 합니다.app.use('/api', router)``` &gt; api경로를 사용하는 router들을 다른 .js파일로 만들어서 개발하면 좋다.## multer`multer는` body-parser와 유사하지만, application/x-www-form-urlencoded 대신 multipart/form-data 형태의 폼 데이터를 처리하기 위해 사용됩니다. multer를 이용해 폼 데이터가 처리되면, `파일을 나타내는 객체`는 `req.file` 혹은 `req.files`에 저장되고 나머지 폼 데이터는 body-parser와 비슷하게 req.body에 저장됩니다. ```jsconst multer = require('multer')const upload = multer()// 하나의 파일 처리app.post('/photo', upload.single('photo'), (req, res) =&gt; &#123; // req.file : 파일 객체 // req.body : 나머지 폼 데이터&#125;)// 여러 개의 파일 처리 (파일 필드가 모두 같은 이름을 사용할 때)app.post('/photos', upload.array('photo'), (req, res) =&gt; &#123; // req.files : 파일 객체로 이루어진 배열 // req.body : 나머지 폼 데이터&#125;)// 여러 개의 파일 처리 (각각 다른 필드 이름 사용 시)const uploadMiddleware = upload.fields([ &#123; name: 'avatar', maxCount: 1 &#125;, &#123; name: 'gallery', maxCount: 8 &#125;])app.post('/photos', uploadMiddleware, (req, res) =&gt; &#123; // req.files : 필드 이름을 속성 이름으로, 파일 객체로 이루어진 배열을 값으로 하는 객체 // req.body : 나머지 폼 데이터&#125;) 123456789101112131415161718192021222324252627282930// multer.jsconst express = require('express')const multer = require('multer')const sharp = require('sharp')const app = express()const upload = multer()app.set('view engine', 'pug')app.get('/', (req, res) =&gt; &#123; res.render('index.pug')&#125;)app.post('/', upload.single('photo'), (req, res) =&gt; &#123; // 들어오는 photo가 buffer에 들어온다. sharp(req.file.buffer) .resize(200, 200) .crop(sharp.gravity.center) .toFile('output3.png', (err, info) =&gt; &#123; console.log(info) res.redirect('/') &#125;)&#125;)app.listen('3000', (req, res) =&gt; &#123; console.log('connect!!')&#125;) JSDocJSDoc은 특별한 형태의 주석을 소스코드에 작성하면 그에 따라 문서를 자동으로 생성해주는 문서 생성 도구입니다. JSDoc을 위한 주석을 아래와 같이 작성합니다. 12345678910111213// image.js/** 를 치면 나온다./** * 썸네일 생성 작업을 작업 큐에 추가합니다. * @param queue - kue queue 인스턴스 * @param &#123;string&#125; location - S3에 업로드된 파일의 public url * @returns &#123;Promise&#125; */function createThumbnailJob(queue, id) &#123; ...&#125; jsdoc을 설치하고 아래 명령을 실행하면, out 폴더에 문서가 자동으로 생성됩니다. 12345npm install -g jsdocjsdoc image.js// 문서가 생성된다.open out/index.html","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"kue","slug":"Node-js/kue","permalink":"http://yoursite.com/categories/Node-js/kue/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"kue","slug":"kue","permalink":"http://yoursite.com/tags/kue/"}]},{"title":"Node-OAuth","slug":"node-study-oauth","date":"2017-09-19T03:54:00.000Z","updated":"2017-10-04T11:40:04.000Z","comments":true,"path":"2017/09/19/node-study-oauth/","link":"","permalink":"http://yoursite.com/2017/09/19/node-study-oauth/","excerpt":"","text":"OAuth TutorialWPSN OAuth 튜토리얼최근에 웹을 사용한 경험이 있는 분들은 대부분 “페이스북으로 로그인” 버튼을 한 번 쯤 사용해보셨을 겁니다. 이 때 사용되는 인증 절차가 바로 OAuth입니다. OAuth가 사용되기 전에는 인증 방식의 표준이 없었기 때문에, 회사들마다 각자의 인증 방식을 사용했습니다. 이렇게 제각각이던 인증 방식을 표준화한 것이 바로 OAuth입니다. OAuth는 현재 2.0 버전까지 나와있는 상태로, 유명한 소셜 네트워크나 API 제공자들은 대부분 OAuth 2.0을 지원하고 있습니다. OAuth를 사용하면 사용자의 아이디와 암호가 노출되지 않도록 하면서도 애플리케이션에 API 접근 권한을 안전하게 위임할 수 있습니다. OAuth 역할OAuth 인증 과정에 참여하는 역할들이 아래에 나와있습니다. ex) Trello에 Google id로 로그인한다. 자원 소유자OAuth를 통해 보호되고 있는 자원을 소유하고 있는 자원의 실제 소유자입니다. 웹 애플리케이션의 사용자입니다. 보통의 경우 사람을 나타낸다. google로 로그인한 나를 나타낸다. 자원 서버사용자 소유의 자원을 제공하는 서버. API 서버라고 봐도 무방합니다. google 서버를 나타낸다. 인증 서버소규모 서비스의 경우 자원 서버와 같은 서버에 위치해있는 경우가 많습니다. google 서버를 나타낸다. 클라이언트OAuth를 통해 보호되고 있는 자원에 사용자 대신 접근하려고 하는 주체를 말합니다. 보통 자원 서버가 제공하는 API를 사용하려고 하는 웹 애플리케이션 서버를 가리킵니다. Trello이다 why? 나를 대신해서 google 계정으로 로그인하기 때문이다. OAuth 2.0 Server-side FlowOAuth 2.0에는 다양한 형태의 인증 절차가 준비되어 있습니다만, 보통 Server-side Flow 방식을 많이 사용합니다. Server-side Flow 방식의 절차는 아래 그림과 같습니다. Client도 Authorization Server에다가 등록을 해줘야한다. 사용자(자원 소유자)는 웹 애플리케이션(OAuth 클라이언트)에 인증 시작을 위한 요청을 보낸다. 웹 애플리케이션은 인증 서버로 사용자의 웹 브라우저를 리다이렉트 시킨다. (OAuth 클라이언트 정보가 포함됨) 사용자는 인증 서버에서 보여주는 화면을 통해 웹 애플리케이션이 요구하는 권한을 확인하고, 웹 애플리케이션이 본인 대신에 인증 정보를 활용할 수 있도록 허가한다. 인증 서버는 사용자의 웹 브라우저를 다시 웹 애플리케이션으로 리다이렉트 시킨다 (인증 코드 포함) 웹 애플리케이션은 인증 코드를 포함시킨 요청을 인증 서버에 보내고, 액세스 토큰을 응답받는다. 웹 애플리케이션은 이제부터 액세스 토큰을 이용해 자원 서버를 사용할 수 있게 된다. 보통 가장 처음으로 사용자에 대한 정보를 가져온다. 해당 사용자 정보를 이용해 성공적으로 인증이 되었다는 사실을 사용자에게 보여준다. 사용자는 웹 애플리케이션을 통해서 자원 서버에 저장되어 있는 정보를 활용할 수 있게 된다. OAuth의 구현위에서 보셨다시피 OAuth를 통한 인증을 직접 구현하기에는 그 절차가 굉장히 복잡합니다. 다행히, 유명한 인증 제공자(Google, Facebook, Twitter 등)에 대해서는 npm에 미리 준비되어 있는 Passport strategy만 구현을 함으로써, 애플리케이션에 OAuth 인증을 쉽게 추가할 수 있습니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"OAuth","slug":"Node-js/OAuth","permalink":"http://yoursite.com/categories/Node-js/OAuth/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"OAuth","slug":"OAuth","permalink":"http://yoursite.com/tags/OAuth/"}]},{"title":"Node-Passport","slug":"node-study-passport","date":"2017-09-19T03:54:00.000Z","updated":"2017-10-02T14:02:38.000Z","comments":true,"path":"2017/09/19/node-study-passport/","link":"","permalink":"http://yoursite.com/2017/09/19/node-study-passport/","excerpt":"","text":"Passport TutorialPassport는 다양한 인증 수단을 지원할 수 있도록 추상화된 인증 미들웨어입니다. 전통적인 웹 개발에서는 사용자 이름과 암호를 이용해 인증을 하는 방식이 대부분이었지만 최근에는 다양한 인증 제공자(Facebook, Twitter, Google 등)를 통한 인증이 많이 활용되는 추세입니다. 그런데 여러 인증 제공자를 활용하기 위해 각각의 인증 제공자를 위한 서버 코드를 따로따로 작성하는 일은 개발자에게는 힘든 작업일 것입니다. Passport를 사용하면 어떤 인증 방식을 사용하건 간에 통일된 방식으로 인증 절차를 정의할 수 있습니다. Passport가 강제하는 방식으로 인증을 하게 되면, 다양한 인증 수단을 활용하기 위해 필요한 구현 비용이 많이 줄어듭니다. StrategyPassport는 인증 절차를 정의하기 위해 strategy라는 개념을 사용합니다. 특정 인증 방식에 대해 정해진 방식대로 strategy를 구현하기만 하면, express와 같은 웹 서버와 쉽게 연동할 수 있습니다. 다양한 인증 방식을 위한 strategy가 이미 준비되어 있습니다. Strategy 마다 구현 방법이 조금씩 다르니, 자세한 구현 방법은 해당 strategy의 문서를 참고해주세요. 아래는 사용자 이름과 암호를 사용하는 인증 절차를 나타내는 passport-local strategy 예제입니다. 1234567891011121314151617// passport가 \"사용자 이름과 암호 기반 인증\"을 수행하도록 strategy 등록passport.use(new LocalStrategy((username, password, done) =&gt; &#123; query.compareUser(username, password) .then(user =&gt; &#123; // 인증 성공 done(error, 성공값) done(null, user) &#125;) .catch(err =&gt; &#123; if (err instanceof query.LoginError) &#123; // 인증 실패: 사용자 책임 done(null, false, &#123;message: err.message&#125;) &#125; else &#123; // 인증 실패: 서버 책임 done(err) &#125; &#125;)&#125;)) passport.authenticate()위에서 구현한 strategy를 이용해 passport가 인증을 위한 라우트 핸들러를 생성하게 할 수 있습니다. 즉 위에서 strategy를 만들면 passport의 method를 사용할 수 있다. 123456// passport-local을 통해 생성한 라우트 핸들러app.post('/login', passport.authenticate(('local'), &#123; successRedirect: '/', // 인증 성공 시 리다이렉트시킬 경로 failureRedirect: '/login', // 인증 실패 시 리다이렉트시킬 경로 failureFlash: '아이디 혹은 패스워드가 잘못되었습니다.' // 인증 실패 시 표시할 메시지&#125;)) stategy구현과 authenticate는 1개의 세트로 보며 만약 네이버, 구글, 다음으로 로그인 하고 싶다면 3세트를 구현해주어야한다. serializeUser, deserializeUser프로그램 상의 어떤 객체를 바이너리 혹은 텍스트의 형태로 변환하는 작업을 직렬화(serialization), 그 반대를 역직렬화(deserialization)라고 합니다. 세션을 이용한 인증을 할 때, 일반적으로 user 객체를 대표하는 특정 속성(id 혹은 username)을 세션에 저장하는 작업을 합니다. 또한 세션에 들어있는 유저 정보를 통해 데이터베이스에서 user 객체를 얻어오는 작업도 합니다. 이 또한 각각 직렬화, 역직렬화라고 할 수 있을 것입니다. passport는 사용 중인 인증 방식에 관계없이 통일된 방식으로 직렬화/역직렬화를 하도록 강제합니다. 이를 따르면 여러 인증 방식을 사용하더라도 문제 없이 세션에 인증 정보를 저장하고 세션으로부터 인증 정보를 추출할 수 있습니다. req.user에다가 passport가 값을 넣어주는 작업을 한다. 이 작업은 위의 세트와 다르게 1번만 구현하면 다른 방식으로 로그인 하는 것도 대응 가능하다. 12345678910111213141516// passport가 유저 정보를 세션에 저장할 수 있도록 직렬화passport.serializeUser((user, done) =&gt; &#123; done(null, user.id)&#125;)// passport가 세션으로부터 유저 객체를 가져올 수 있도록 역직렬화passport.deserializeUser((id, done) =&gt; &#123; query.getUserById(id) .then(user =&gt; &#123; if (user) &#123; done(null, user) // req.user에 저장됨 &#125; else &#123; done(new Error('해당 아이디를 가진 사용자가 없습니다.')) &#125; &#125;)&#125;) req.login, req.logoutreq.login(user)는 user 객체를 직렬화한 뒤 세션에 저장해서, 해당 세션을 로그인시키는 메소드입니다. passport.authenticate 메소드가 생성한 라우트 핸들러를 사용한다면, 이 라우트 핸들러 안에서 req.login 메소드가 호출되기 때문에 따로 로그인을 시켜줄 필요는 없습니다. 보통 req.login 메소드는 아래와 같이 회원 가입 이후에 자동으로 로그인을 시켜주려는 목적으로 사용됩니다. 1234567891011121314app.post('/register', (req, res, next) =&gt; &#123; query.createUser(req.body.username, req.body.password) .then(user =&gt; &#123; // 회원 가입 시 자동으로 로그인 시키고 리다이렉트 req.login(user, err =&gt; &#123; if (err) &#123; next(err) &#125; else &#123; res.redirect('/') &#125; &#125;) &#125;) .catch(util.flashError(req, res))&#125;) req.logout 메소드는 현재 세션에 들어있는 인증 정보를 지우고 로그아웃을 시키는 메소드입니다. 아래와 같이 사용할 수 있습니다. 12345app.post('/logout', (req, res) =&gt; &#123; // passport가 제공하는 `req.logout` 메소드 req.logout() res.redirect('/login')&#125;) passport.initialize()Express 앱에서 Passport를 사용하기 위해서는 다음과 같이 미들웨어를 주입해주어야 합니다. 인증 과정에서 세션을 사용하지 않는다면 passport.session()은 주입하지 않아도 무방합니다.123// passport 관련 미들웨어 삽입app.use(passport.initialize())app.use(passport.session())","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Passport","slug":"Node-js/Passport","permalink":"http://yoursite.com/categories/Node-js/Passport/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Passport","slug":"Passport","permalink":"http://yoursite.com/tags/Passport/"}]},{"title":"Node-CSRF","slug":"node-study-csrf","date":"2017-09-18T03:54:00.000Z","updated":"2017-10-01T09:59:33.000Z","comments":true,"path":"2017/09/18/node-study-csrf/","link":"","permalink":"http://yoursite.com/2017/09/18/node-study-csrf/","excerpt":"","text":"CSRF 예제CSRF(Cross-site Request Forgery, 사이트 간 요청 위조)는 사용자가 악의적인 웹 페이지에 접속했을 때 해당 웹 페이지에서 다른 서버로 요청을 보내어 정보를 조작하는 공격 기법입니다. 전통적인 웹 개발에서 자주 일어나는 보안 사고입니다. (2008년 옥션 개인정보 유출 사건을 참고하세요.) URL shotener 서버로 CSRF 공격을 시험해볼 수 있습니다. 로컬 서버를 켜고 상단의 Show 버튼으로 웹 페이지를 열어 요청을 보내보세요. CSRF 공격이 가능한 이유는 웹 서버로 오는 요청이 어떤 웹 페이지에서 출발했던 간에 쿠키가 자동으로 포함되어 오기 때문입니다. (Ajax 요청은 제외) 이렇게 쿠키는 편하긴 하지만 잘못 다루었을 경우에 보안에 심각한 위협이 될 수 있습니다. CSRF 공격을 방어하기 위해서는, 사용자가 우리 웹 페이지에 접속하지 않고는 데이터를 조작하는 요청(POST)을 보낼 수 없게만들어야 합니다. 이를 위해 우리 웹 페이지에 접속해야만 받을 수 있는 정보(이를 CSRF 토큰이라 부릅니다)를 요청에 포함시켜 보냄으로써 CSRF 공격을 방어할 수 있습니다. express 기반 웹 사이트에서는 csurf 미들웨어를 사용해 CSRF 공격을 방어할 수 있습니다. CRURF 123456789101112131415161718192021222324var cookieParser = require('cookie-parser')var csrf = require('csurf')var bodyParser = require('body-parser')var express = require('express') // setup route middlewares var csrfProtection = csrf(&#123; cookie: true &#125;)var parseForm = bodyParser.urlencoded(&#123; extended: false &#125;) // create express app var app = express() // parse cookies // we need this because \"cookie\" is true in csrfProtection app.use(cookieParser()) app.get('/form', csrfProtection, function(req, res) &#123; // pass the csrfToken to the view res.render('send', &#123; csrfToken: req.csrfToken() &#125;)&#125;) app.post('/process', parseForm, csrfProtection, function(req, res) &#123; res.send('data is being processed')&#125;) 123456&lt;form action=\"/process\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"_csrf\" value=\"&lt;%= csrfToken %&gt;\"&gt; Favorite color: &lt;input type=\"text\" name=\"favoriteColor\"&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt; csrf는 cookie session을 사용할때 문제가 된다. jwt를 사용할때는 csrf는 필요가 없다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"CSRF","slug":"Node-js/CSRF","permalink":"http://yoursite.com/categories/Node-js/CSRF/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"CSRF","slug":"CSRF","permalink":"http://yoursite.com/tags/CSRF/"}]},{"title":"Node-CSRF","slug":"node-study-socketio","date":"2017-09-18T03:54:00.000Z","updated":"2017-10-01T10:02:19.000Z","comments":true,"path":"2017/09/18/node-study-socketio/","link":"","permalink":"http://yoursite.com/2017/09/18/node-study-socketio/","excerpt":"","text":"SocketIO초기의 HTTP는 실시간 전송이 안되었어서 초기에는 실시간처럼 보이는 Long Polling와 comet이라는 응답을 서버가 결정을 하는 기술을 사용하였다.현재는 WebSocketIO를 표준으로 사용하고 있다. WebSocketIO HandShake WebSocketIO는 client가 server에게 websocket이라고 요청을 보낸다. server가 지원을 해주면 연결을 한다. HTTP의 요청응답을 넘어서 server, client가 서로가 필요할때 바로 정보를 요청 및 전달한다. websocket연결을 보기위해서는 검사tab의 Frames로 확인 할 수 있다. Socket.io SocketIO 예제Socket.io는 실시간 웹을 위한 JS 라이브러리입니다. 기존의 웹은 클라이언트(브라우저)가 요청을 해야만 서버로부터 데이터를 받을 수 있었던 데 반해, Socket.io와 같은 기술을 사용하면 클라이언트가 요청을 하지 않아도 필요할 때 서버로부터 데이터를 받을 수 있습니다. 이를 이용하면, 채팅이나 실시간 차트 혹은 실시간 알림을 지원하는 웹 어플리케이션을 작성할 수 있습니다. Socket.io는 실시간 통신을 위해 주로 WebSocket이라는 웹 표준 기술을 사용하지만, 구형 웹브라우저 등 WebSocket을 지원하지 않는 환경에서는 다른 기술을 사용할 수도 있습니다. (long polling, comet 등) 다른 일반적인 웹소켓 서버와는 호환이 되지 않으므로 주의하세요. 123456789101112131415161718192021222324//index.js// DOMContentLoaded html이 다 loading되었을 때 실행되게 한다.document.addEventListener('DOMContentLoaded', () =&gt; &#123; const socket = io() socket.on('response', data =&gt; &#123; console.log(`$&#123;data.message&#125; @ $&#123;new Date&#125;`) &#125;) // emit : 우리가 맺은 socketio에다가 message라는 이름의 event를 발생시켜라 거기에 이런 데이터를 포함시켜라 document.querySelector('#message').addEventListener('click', e =&gt; &#123; socket.emit('message', &#123;message: '간단한 메시지를 이렇게 보낼 수 있습니다.'&#125;) &#125;) document.querySelector('#message-and-ack').addEventListener('click', e =&gt; &#123; socket.emit('messageAndAck', &#123;message: '메시지를 보낸 후에 서버에서 응답을 받을 수도 있습니다'&#125;, data =&gt; &#123; console.log(data) &#125;) &#125;) document.querySelector('#broadcast').addEventListener('click', e =&gt; &#123; socket.emit('broadcast', &#123;message: '다른 클라이언트에게만 가는 메시지도 보낼 수 있습니다.'&#125;) &#125;)&#125;) index.js에 있는 message event가 발생하고 client에게 server.js에서 response event를 발생을 하면 index.js에서 response를 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// server.jsconst express = require('express')const http = require('http') // express를 사용하려면 http를 써야한다.const socketio = require('socket.io')const app = express()const server = http.Server(app)const io = socketio(server)app.set('view engine', 'pug')app.use(express.static('public'))app.get(\"/\", (req, res) =&gt; &#123; res.render('index.pug')&#125;)app.get('/namespace', (req, res) =&gt; &#123; res.render('namespace.pug')&#125;)app.get('/room/:id', (req, res) =&gt; &#123; res.render('room.pug', &#123;id: req.params.id&#125;)&#125;)/*# 서버 측 API## 사전 정의된 이벤트 목록- 'connect' 혹은 'connection': 클라이언트가 새 연결을 맺었을 때- 'disconnect': 클라이언트의 연결이 끊어졌을 때- 'error': 에러가 발생했을 때- 'disconnecting': 클라이언트가 연결을 끊기 직전에*/io.on('connection', socket =&gt; &#123; // Simple Message socket.on('message', data =&gt; &#123; // 현재 네임스페이스에 접속 중인 모든 클라이언트에게 메시지 보내기 io.emit('response', data) &#125;) // Acknowledgement socket.on('messageAndAck', (data, ack) =&gt; &#123; io.emit('response', data) // 메시지를 보낸 클라이언트에게만 회신하기 ack(&#123;ok: true&#125;) &#125;) // Broadcast socket.on('broadcast', data =&gt; &#123; // 메시지를 보낸 클라이언트를 제외한 모든 클라이언트에게 메시지 보내기 socket.broadcast.emit('response', data) &#125;)&#125;)// Custom Namespace 통신을 격리하기 위해서 사용한다. -&gt; namespace.jsconst someNsp = io.of('/some-namespace')someNsp.on('connection', socket =&gt; &#123; socket.on('message', data =&gt; &#123; someNsp.emit('response', data) &#125;)&#125;)// Roomconst roomNsp = io.of('/room')/*room은 동적으로 지정할 수 있는 통신의 분리 단위입니다.하나의 소켓은 여러 개의 room에 들어갈 수 있습니다.*/roomNsp.on('connection', socket =&gt; &#123; let id; socket.on('join', data =&gt; &#123; // `socket.join`을 호출해서 특정 room에 진입합니다. socket.join(data.id) id = data.id &#125;) socket.on('message', data =&gt; &#123; // `socket.to`는 이벤트 방출을 특정 room에 한정시킵니다. roomNsp.to(id).emit('response', data) &#125;)&#125;)const listener = server.listen(process.env.PORT, function () &#123; console.log('Your app is listening on port ' + listener.address().port)&#125;) 접속한 사람마다 각자의 socket객체를 생성 해준다. 사전 정의된 이벤트 목록SocketIo의 기본 이벤트 목록 &#39;connect&#39; 혹은 &#39;connection&#39;: 클라이언트가 새 연결을 맺었을 때 &#39;disconnect&#39;: 클라이언트의 연결이 끊어졌을 때 &#39;error&#39;: 에러가 발생했을 때 &#39;disconnecting&#39;: 클라이언트가 연결을 끊기 직전에 server.js에서 socket.emit는 자기자신에게만 보내진다. io.emit는 접속한 전부에게 보내진다. 1234567891011121314// namespace.jsdocument.addEventListener('DOMContentLoaded', () =&gt; &#123; // 특정 namespace에 대한 연결 수립 const socket = io('/some-namespace') socket.on('response', data =&gt; &#123; console.log(`$&#123;data.message&#125; @ $&#123;new Date&#125;`) &#125;) document.querySelector('#message').addEventListener('click', e =&gt; &#123; socket.emit('message', &#123;message: '특정한 이름공간에 접속할 수 있습니다. 통신은 다른 이름공간과 분리됩니다.'&#125;) &#125;)&#125;) namespace는 미리 만들어진 방에서 격리할 때 사용한다.roomspace는 동적으로 변경되는 방에서 격리할 때 사용한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"SocketIO","slug":"Node-js/SocketIO","permalink":"http://yoursite.com/categories/Node-js/SocketIO/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"SocketIO","slug":"SocketIO","permalink":"http://yoursite.com/tags/SocketIO/"}]},{"title":"Node-Knex-Seed","slug":"node-study-knex-seed","date":"2017-09-18T03:54:00.000Z","updated":"2017-10-01T10:00:24.000Z","comments":true,"path":"2017/09/18/node-study-knex-seed/","link":"","permalink":"http://yoursite.com/2017/09/18/node-study-knex-seed/","excerpt":"","text":"SEED기존의 seed.js로 데이터베이스의 값을 넣는 것이아닌 knex의 seed로 값을 넣어본다. 기존 seed.js12345678910111213141516171819const faker = require('faker')const randomstring = require('randomstring')const knex = require('./knex')knex('user') .insert(&#123; id: 'fast', password: 'campus' &#125;) .then(() =&gt; &#123; for(var i = 0; i &lt; 20; i++)&#123; knex('url_entry') .insert(&#123; id: randomstring.generate(8), long_url: faker.internet.url(), user_id: 'fast' &#125;).then(console.log) &#125; &#125;) seeds 생성방법seed 명령어12345// seed file을 만드는 명령어$ knex seed:make initial_data// seed 실행 명령어$ knex seed:run 변경된 seeds/initial_data.js 123456789101112131415161718192021222324252627282930const faker = require('faker')const randomstring = require('randomstring')// 값이 실행되어서 이 파일의 작업이 끝나는 것에 대해서 알려줘야한다.exports.seed = function(knex, Promise) &#123; // Deletes ALL existing entries return knex('user') .insert(&#123; id: 'kim', password: 'sejune' &#125;) .then(() =&gt; &#123; const arr = [] for(var i = 0; i &lt; 20; i++)&#123; arr.push( knex('url_entry') .insert(&#123; id: randomstring.generate(8), long_url: faker.internet.url(), user_id: 'kim' &#125;) ) &#125; return Promise.all(arr) // promise는 어떤값을 감싸고 있는데 그 값을 then을 사용해서 사용할 수 있다. // 단 return하는 것이 그냥 값이면 then에서는 그 값을 사용할 수 있다. // 여기서 다음에 등장하는 then에는 arr를 사용할 수 있다. &#125;)&#125;","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"knex","slug":"Node-js/knex","permalink":"http://yoursite.com/categories/Node-js/knex/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"kenx","slug":"kenx","permalink":"http://yoursite.com/tags/kenx/"}]},{"title":"Node-MongoDB","slug":"node-study-mongodb","date":"2017-09-17T03:54:00.000Z","updated":"2017-10-04T11:42:27.000Z","comments":true,"path":"2017/09/17/node-study-mongodb/","link":"","permalink":"http://yoursite.com/2017/09/17/node-study-mongodb/","excerpt":"","text":"Node mongoDBMEAN Stack = MongoDB + Express + Angular + Node IT (Information Technology) 저장 : 데이터 저장소 처리 : 프로그래밍 언어 (1) MongoDB 란?몽고DB(MongoDB) 크로스 플랫폼 : window, linux, mac 전부다 가능하다. 도큐먼트(JSON과 같은 동적 스키마형 문서) 지향 NoSQL 데이터베이스 시스템 : NonSQL SQL외에 다른것도 사용한다. Readys방식 =&gt; 키:값 MongoDB =&gt; 문서기반(JSON) : Java Script Object Notation BigData =&gt; 컬럼패밀리 Graph 오픈소스(Open Source) C++로 작성됨 높은 확장성 높은 성능 더 쉽고 더 빠르게 데이터 통합 가능 NoSQLNoSQL 데이터베이스는 전통적인 관계형 데이터베이스 보다 덜 제한적인 일관성 모델을 이용하는 데이터의 저장 및 검색을 위한 매커니즘을 제공한다.이러한 접근에 대한 동기에는 디자인의 단순화, 수평적 확장성, 세세한 통제를 포함한다.NoSQL 데이터베이스는 단순 검색 및 추가 작업을 위한 매우 최적화된 키 값 저장 공간으로, 레이턴시와 스루풋과 관련하여 상당한 성능 이익을 내는 것이 목적이다.NoSQL 데이터베이스는 빅데이터와 실시간 웹 애플리케이션의 상업적 이용에 널리 쓰인다.또, NoSQL 시스템은 SQL 계열 쿼리 언어를 사용할 수 있다는 사실을 강조한다는 면에서 “Not only SQL”로 불리기도 한다. (위키백과) 데이터 저장소에 대한 CAP 이론CAP 정리, 또는 브루어의 정리(Brewer -)는, 다음과 같은 세 가지 조건을 모두 만족하는 분산 컴퓨터 시스템이 존재하지 않음을 증명한 정리이다. 일관성(Consistency): 모든 노드가 같은 순간에 같은 데이터를 볼 수 있다. 가용성(Availability): 모든 요청이 성공 또는 실패 결과를 반환할 수 있다. 분할내성(Partition tolerance): 메시지 전달이 실패하거나 시스템 일부가 망가져도 시스템이 계속 동작할 수 있다. 위의 세 가지 조건의 첫 글자를 따서 CAP 정리라고 부른다.2000년 전산학자 에릭 브루어가 이 명제를 가설로서 제시하였고, 2002년 세스 길버트와 낸시 린치가 이를 증명하였다. CAP정리에 따르면 분산 시스템이 추구하는 데이터의 특성은 세 가지 중 두가지만 보장할 수 있다. CA 분류 (일관성 +가용성) : 전통적인 RDBMS. 트랜잭션.CP 분류 (가용성 + 분할용인) : 구글의 BigTable, HBase 등AP 분류 (가용성 + 분할용인) : Dynamo, Cassandra, MongoDB 등 (2) MongoDB 설치 mongoDB 설치 1&gt; brew install mongodb data/db 폴더 생성```sudo mkdir -p data/db data/db로 이동 후 sudo chown kimsejune /data/db mongoDB를 실행시키는 명령어 : 서버의 역할을 한다.mongod 클라이언트의 역할 실행 명령어 mongo showdbs // 서버, 클라이언트 정보 확인 db.member.insert({ “id”:”hong”, “email”:”tpwns1088@gmail.com”});// mongoDB에 값을 추가하는 명령어 db.member.find()// mongoDB의 member값을 찾는다.``` GUI Tool : RoboMongo (3) 관계형 데이터베이스와 몽고디비 비교 RDBMS MongoDB Database Database Table Collection Row Document Column Key Primary Key ObjectId(_id) RDBMS 명령과 MongoDB 함수 비교 &gt; InsertSQL : insert into members (“name”,”email”) values(“홍길동”,”hong@aaa.com”)Mongo DB : db.members.insert({name:”hong”, email:”hong@aaa.com”}) SelectSQL : select * from members where name=”홍길동”Mongo DB : db.members.find({name:”홍길동”}) UpdateSQL : update members set email=”hong@aaa.com” where name=”홍길동”Mongo DB : db.members.update( {name:”홍길동”}, {$set :{email:”hong@aaa.com”} } ) DeleteSQL : delete from members where name=”홍길동”Mongo DB : db.members.remove({name:”홍길동”}) (4) REST API와 몽고 디비 연동 이해 HTTP METHOD 역할 MongoDB 함수 POST 리소스를 생성 insert, save GET 리소스를 조회 find PUT 리소스를 수정 update DELETE 리소스를 삭제 delete (5) MEAN 스택 미니 프로젝트MongoDB : 문서 기반의 NoSQL 데이터베이스.ExpressJS : Node.js에서 가장 널리 쓰이는 웹 프레임워크.AngularJS : 구글에서 개발한 MVC 기반 클라이언트 측 자바스크립트 프레임워크.Node.js : 자바스크립트 엔진 기반의 웹 서버. Asyncawait version이 낮은 node에서 callback hell을 방지한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"mongoDB","slug":"Node-js/mongoDB","permalink":"http://yoursite.com/categories/Node-js/mongoDB/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"mongoDB","slug":"mongoDB","permalink":"http://yoursite.com/tags/mongoDB/"}]},{"title":"Node-Knex-Migration","slug":"node-study-knex-migration","date":"2017-09-15T03:54:00.000Z","updated":"2017-10-01T09:47:48.000Z","comments":true,"path":"2017/09/15/node-study-knex-migration/","link":"","permalink":"http://yoursite.com/2017/09/15/node-study-knex-migration/","excerpt":"","text":"Node knex MigrationSchema AlterMigration하는 방법 123$ npm install knex -g$ knex init knexfile.js가 생성된다 이것으로 앞으로 migration을 한다.(초기모습) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//knexfile.js// Update with your config settings.module.exports = &#123; // 개발단계 development: &#123; client: 'sqlite3', connection: &#123; filename: './dev.sqlite3' &#125; &#125;, staging: &#123; client: 'postgresql', connection: &#123; database: 'my_db', user: 'username', password: 'password' &#125;, pool: &#123; min: 2, max: 10 &#125;, migrations: &#123; tableName: 'knex_migrations' &#125; &#125;, production: &#123; client: 'postgresql', connection: &#123; database: 'my_db', user: 'username', password: 'password' &#125;, pool: &#123; min: 2, max: 10 &#125;, migrations: &#123; tableName: 'knex_migrations' &#125; &#125;&#125;; development, staging, production 3가지로 구성되어있다. NODE_ENV=production node src/index.js형식으로 실행을 한다 production값을 변경가능하며 default값은 development이다. debug는 devlopment에서는 사용하고 product에서는 사용하지 않는다. 각자의 환경에서 설치할 수 있는데 개발에서 사용되는 패키지를 운영에다가 넣을 필요가없으니 개발환경에서만 사용하는 것은 --save-dev로 설치해둔다. test, faker같은 것을 –save-dev로 설치해둔다. knexfile.js 적용모습 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Update with your config settings.require('dotenv').config()module.exports = &#123; development: &#123; client: 'mysql', connection: &#123; host: process.env.DATABASE_HOST, user: process.env.DATABASE_USER, password: process.env.DATABASE_PASSWORD, database: process.env.DATABASE_NAME &#125;, debug: true &#125;, staging: &#123; client: 'postgresql', connection: &#123; database: 'my_db', user: 'username', password: 'password' &#125;, pool: &#123; min: 2, max: 10 &#125;, migrations: &#123; tableName: 'knex_migrations' &#125; &#125;, production: &#123; client: 'postgresql', connection: &#123; database: 'my_db', user: 'username', password: 'password' &#125;, pool: &#123; min: 2, max: 10 &#125;, migrations: &#123; tableName: 'knex_migrations' &#125; &#125;&#125;; Knex Migration 생성법1$ knex migrate:make migration_name migrations라는 폴더에 migration_name 파일이 생긴다. up : 데이터베이스를 변경하는데 사용한다. down : 변경된 값을 되돌리는데 사용한다. migration을 사용하여서 table을 생성하는 방법 1&gt; knex migrate:latest 1번 더 같은 명령어를 실행하면 이미 저장되어있다고 알려준다. migration 취소방법 1&gt; knex migrate:rollback migration은 한번 할 때 한번씩 하는 것이 좋다.(작은 단위로 실행을 추천) 이제 schema.js는 필요가 없게 되었다. 123456789101112131415// schema.jsconst knex = require('./knex')knex.schema.createTable('user', t =&gt; &#123; t.string('id').primary() t.string('password').notNullable()&#125;).then(() =&gt; knex.schema.createTable('url_entry', t =&gt; &#123; t.string('id', 8).primary() t.string('long_url').notNullable() t.string('user_id') t.foreign('user_id').references('user.id') t.timestamp('created_at').defaultTo(knex.fn.now())&#125;)).then(process.exit)// 실행 node src/schema.js 하면 DB에 생성된다. 변경 후 migrationfile 123456789101112131415161718192021222324252627282930// add_user.js &lt;migration file&gt;exports.up = function(knex, Promise) &#123; // return은 promise가 끝난 여부를 판단하기 때문이다. return knex.schema.createTable('user', t =&gt; &#123; t.string('id').primary() t.string('password').notNullable() &#125;)&#125;;exports.down = function(knex, Promise) &#123; // usertable을 되돌리는 코드 작성 return knex.schema.dropTable('user')&#125;;// url_entry.js &lt;migration file&gt;exports.up = function(knex, Promise) &#123; return knex.schema.createTable('url_entry', t =&gt; &#123; t.string('id', 8).primary() t.string('long_url').notNullable() t.string('user_id') t.foreign('user_id').references('user.id') t.timestamp('created_at').defaultTo(knex.fn.now()) &#125;)&#125;;exports.down = function(knex, Promise) &#123; return knex.schema.dropTable('url_entry')&#125;; Database 동시성 문제접속한 링크에 count를 1씩 올릴때 동시에 1000번의 요청을 보낼 경우에 값을 제대로 반영을 못한다는 문제가 발생한다. 아래의 예를 보면 알 수 있다. 1234567891011121314151617181920212223// query.js saveClickCountById(id, click_count) &#123; return knex('url_entry') .where(&#123;id&#125;) .update(&#123;click_count&#125;) &#125;// index.jsapp.get('/:id', (req, res, next) =&gt; &#123; query.getUrlById(req.params.id) .then(urlEntry =&gt; &#123; if(urlEntry)&#123; query.saveClickCountById(urlEntry.id, urlEntry.click_count+1) .then(() =&gt; &#123; res.redirect(urlEntry.long_url) // 301 moved~~ 영원히 이동한다 (브라우저에 저장) , 302 브라우저에 저장안하고 다시보낸다. // res.redirect(301, entry.long_url)를 해야하지만 사람들이 얼마나 클릭했는지 확인하기 위해서 301을 뺐다. &#125;) &#125;else &#123; next() &#125; &#125;)&#125;) 값을 업데이트하기전에 계속 값이 덮어씌어지는 문제가 발생한다. 해결방법 잠금 =&gt; 성능이 느려진다. DeadLock이 발생할 확률이 생긴다. Atomic Update 원자적 갱신 명령을 내릴 때 자동으로 증가시킨다. knex의 .increment를 사용한다. 12345678910111213141516171819202122// query.js incrementClickCountById(id) &#123; return knex('url_entry') .where(&#123;id&#125;) .increment('click_count', 1) &#125;// index.jsapp.get('/:id', (req, res, next) =&gt; &#123; query.getUrlById(req.params.id) .then(urlEntry =&gt; &#123; if(urlEntry)&#123; query.incrementClickCountById(urlEntry.id) // Atomic Update를 적용한 상태이다. .then(() =&gt; &#123; res.redirect(urlEntry.long_url) // 301 moved~~ 영원히 이동한다 (브라우저에 저장) , 302 브라우저에 저장안하고 다시보낸다. // res.redirect(301, entry.long_url)를 해야하지만 사람들이 얼마나 클릭했는지 확인하기 위해서 301을 뺐다. &#125;) &#125;else &#123; next() &#125; &#125;)&#125;) Atomic Update를 하면 데이터베이스에 접속해서 가져오는 것이 아닌 바로 값을 올려버리기 때문에 제대로 값이 나타난다. bcrypt를 사용한 보안bcrypt 12345678910111213&gt; npm install --save bcrypt&gt; node&gt; bcrypt = require('bcrypt')&gt; bcrypt.hashSync('campus', 10) # 2의 10승이다.&gt; hash = bcrypt.hashSync('campus', 10) # hash에다가 값을 담아둔다# 비교방법&gt; bcrypt.compareSync('campus', hash) # 정확하게 일치해야지 true이다.true&gt; bcrypt.compareSync('campus1', hash)false To check a password123// Load hash from your password DB.bcrypt.compareSync(myPlaintextPassword, hash); // truebcrypt.compareSync(someOtherPlaintextPassword, hash); // false 동기의 방식을 사용하는 위에 script보다 아래의 방식이 좋다. 1234567// Load hash from your password DB.bcrypt.compare(myPlaintextPassword, hash).then(function(res) &#123; // res == true&#125;);bcrypt.compare(someOtherPlaintextPassword, hash).then(function(res) &#123; // res == false&#125;); npm validator많은 종류의 validation이 생성되어있으며 값이 맞는지 검증해주는 역할을 한다. 1&gt; npm install validator --save Error 처리방법Flash : error를 session 저장해두었다가 다음 요청이 왔을 때 error 메세지를 보여준다. 1&gt; npm install connect-flash --save session을 사용하면 여러 요청에 걸친 정보를 유지할 수 있다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"knex","slug":"Node-js/knex","permalink":"http://yoursite.com/categories/Node-js/knex/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"kenx","slug":"kenx","permalink":"http://yoursite.com/tags/kenx/"}]},{"title":"Node-Knex","slug":"node-study-knex","date":"2017-09-14T03:54:00.000Z","updated":"2017-09-30T13:08:48.000Z","comments":true,"path":"2017/09/14/node-study-knex/","link":"","permalink":"http://yoursite.com/2017/09/14/node-study-knex/","excerpt":"","text":"Node KnexWPSN Knex 튜토리얼Node.js를 통해 MySQL을 이용하는 방법에는 아래와 같이 여러 가지가 있습니다. 쿼리를 직접 작성한 후 실행 (mysql …) 쿼리 빌더를 통해서 쿼리 실행 (Knex.js, Squel.js, …) ORM(Object Relational Mapping)을 통해서 쿼리 실행 (Sequelize, Bookshelf.js, Objection.js, …) 자주쓰이는 Sequelize의 예시이다.123456789101112131415161718const Sequelize = require('sequelize');const sequelize = new Sequelize('database', 'username', 'password');const User = sequelize.define('user', &#123; username: Sequelize.STRING, birthday: Sequelize.DATE&#125;);sequelize.sync() .then(() =&gt; User.create(&#123; username: 'janedoe', birthday: new Date(1980, 6, 20) &#125;)) .then(jane =&gt; &#123; console.log(jane.get(&#123; plain: true &#125;)); &#125;); 실무에서는 1번 방식을 사용하는 경우는 거의 없고, 주로 2번 방식과 3번 방식을 사용합니다. 쿼리 빌더는 쿼리를 직접 작성하는 대신 프로그래밍 언어로 작성된 API를 이용해 간접적으로 쿼리를 작성하는 방식을 말합니다. 쿼리 빌더를 사용하면 쿼리의 조합과 재사용을 유연하고 편리하게 할 수 있습니다. ORM(Object Relational Mapping)은 데이터베이스를 객체 지향 프로그래밍을 통해 다룰 수 있게 만들어주는 도구입니다. Validation 등의 부가 기능을 내장하고 있는 경우가 많으며 테이블 간의 관계도 편하게 다룰 수 있으나, 잘 사용하게 되기까지 필요한 학습 비용이 높다는 단점이 있습니다. 이 강의에서 사용할 Knex.js는 Node.js와 브라우저 위에서 사용가능한 쿼리 빌더입니다. SQL과 비슷한 형태의 문법을 가지고 있고, 또 마이그레이션 기능을 내장하고 있어 널리 사용되고 있습니다. 또한 MySQL, Postgres, MSSQL, Oracle과 같은 유명한 DBMS를 지원합니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"knex","slug":"Node-js/knex","permalink":"http://yoursite.com/categories/Node-js/knex/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"kenx","slug":"kenx","permalink":"http://yoursite.com/tags/kenx/"}]},{"title":"Node-Knex-Query-builder","slug":"node-study-knex-query-builder","date":"2017-09-14T03:54:00.000Z","updated":"2017-09-30T13:08:57.000Z","comments":true,"path":"2017/09/14/node-study-knex-query-builder/","link":"","permalink":"http://yoursite.com/2017/09/14/node-study-knex-query-builder/","excerpt":"","text":"Node KnexKnex - Query BuilderKnex 인스턴스 생성Knex를 이용해 MySQL 서버에 접속하기 위해서는 일단 아래와 같이 Knex 인스턴스를 만들어야 합니다. 123456789module.exports = require('knex')(&#123; client: 'mysql', connection: &#123; host: 'localhost', user: 'root', // 실제 서비스에서는 root 계정을 사용하지 않는 것이 좋습니다. password: 'rootpassword', database: 'employees' &#125;&#125;) 확인방법12$ node&gt; knex = require('./src/knex') Connection PoolKnex 인스턴스를 생성하면 connection pool이 만들어집니다. 한 번에 여러 커넥션을 맺어 놓는다는 의미. 그래서 해당 커넥션을 이용합니다. 인스턴스 생성 시 별도의 옵션을 주지 않는다면 커넥션 풀은 2개의 커넥션으로 시작하며, 필요에 의해 10개까지 늘어날 수 있습니다. 자세한 설정은 공식문서를 Knex를 이용한 쿼리 수행이제부터 Knex 인스턴스를 이용해 쿼리를 날릴 수 있습니다. 주의! 레코드가 수 십만 개 이상인 경우에는 결과를 받아오는 데 시간이 오래 걸리니 꼭 limit 메소드를 사용해주세요. 123456789101112131415knex('salaries').limit(3).then(console.log)// 결과[ &#123; emp_no: 10001, salary: 60117, from_date: 1986-06-25T15:00:00.000Z, to_date: 1987-06-25T14:00:00.000Z &#125;, &#123; emp_no: 10001, salary: 62102, from_date: 1987-06-25T14:00:00.000Z, to_date: 1988-06-24T14:00:00.000Z &#125;, &#123; emp_no: 10001, salary: 66074, from_date: 1988-06-24T14:00:00.000Z, to_date: 1989-06-24T15:00:00.000Z &#125; ] Knex 인스턴스는 메소드 체이닝 방식으로 사용하도록 만들어져 있습니다. 아래와 같이 메소드를 계속 이어붙이는 방식으로 쿼리를 빌드합니다. 123456789// 1위부터 10위까지의 최고 연봉자의 연봉과 first_name을 출력합니다.knex('employees') .select('first_name') .max('salary as max_salary') .join('salaries', 'employees.emp_no', 'salaries.emp_no') .groupBy('salaries.emp_no') .orderBy('max_salary', 'desc') .limit(10) .then(...) Knex 인스턴스는 표준 Promise가 아니라 자체 Promise 구현을 사용합니다. 이 구현의 특이한 점은 then 메소드를 호출하기 전까지는 SQL을 실행시키지 않는다는 것입니다. 위 성질을 이용해 then 메소드를 호출하지 않은 채로 toString 메소드를 호출하면, 쿼리를 실행시키기 전에 쿼리 빌더가 어떤 쿼리를 생성하는지 알 수 있습니다. 12knex('salaries').limit(3).toString()// select * from `salaries` limit 3 없는 테이블을 써도 생성은 된다. 그러나 실행은 안된다 꼭 실행시에 뒤에 .then을 해줘야한다. SELECTselect 메소드를 사용하면 원하는 컬럼만을 불러올 수 있습니다. 12345knex('salaries') .select('emp_no', 'salary') .limit(3) .toString()// select `emp_no`, `salary` from `salaries` limit 3 실제로 쿼리를 실행하면 아래와 같은 결과를 반환합니다. 123456789knex('salaries') .select('emp_no', 'salary') .limit(3) .then(console.log)// 결과[ &#123; emp_no: 10001, salary: 60117 &#125;, &#123; emp_no: 10001, salary: 62102 &#125;, &#123; emp_no: 10001, salary: 66074 &#125; ] select 메소드의 인자로 넘기는 문자열 뒤에 as를 붙여서, 반환되는 객체들의 속성 이름을 바꿀 수 있습니다. 123456789knex('salaries') .select('emp_no as e', 'salary as s') .limit(3) .then(console.log)// 결과[ &#123; e: 10001, s: 60117 &#125;, &#123; e: 10001, s: 62102 &#125;, &#123; e: 10001, s: 66074 &#125; ] distinct 메소드를 사용해 중복 제거를 할 수 있습니다. 123456789knex('employees') .distinct('first_name') .limit(3) .toString()/*select distinct `first_name` from `employees`limit 3*/ WHEREwhere 메소드를 이용해 WHERE 구문을 빌드할 수 있습니다. 12345678910knex('salaries') .where('emp_no', 20000) .limit(3) .toString()/*select * from `salaries`where `emp_no` = 20000limit 3*/ 아래와 같이 연산자를 사용할 수도 있습니다. 12345678910knex('salaries') .where('emp_no', '&gt;', 20000) .limit(3) .toString()/*select * from `salaries`where `emp_no` &gt; 20000limit 3*/ AND 연산자를 사용하기 위해 where 메소드를 여러 번 사용하거나, andWhere 메소드를 사용할 수 있습니다. 1234567891011121314knex('salaries') .where('emp_no', '&gt;', 20000) .where('salary', '&gt;', 150000) .andWhere('from_date', '&lt;', '1999-01-01') .limit(3) .toString()/*select * from `salaries`where `emp_no` &gt; 20000 and `salary` &gt; 150000 and `from_date` &lt; '1999-01-01'limit 3*/ 또는 where 메소드에 객체를 넘길 수도 있습니다. 1234567891011knex('employees') .where(&#123; first_name: 'Georgi', last_name: 'Facello' &#125;) .toString()/*select * from `employees`where `first_name` = 'Georgi' and `last_name` = 'Facello'*/ NOT 연산자를 사용하기 위해서 whereNot 메소드를 사용합니다. 12345678910knex('salaries') .whereNot('emp_no', '&gt;', 20000) .limit(3) .toString()/*select * from `salaries`where not `emp_no` &gt; 20000limit 3*/ OR 연산자를 사용하기 위해 orWhere 메소드를 사용할 수 있습니다. 또한 연산이 복잡한 경우에는 함수를 인자로 넘겨서 여러 where의 결합을 나타낼 수 있습니다. orWhere은 where와 같지만 or로 연결해주는 역할을 한다. 123456789101112131415161718192021knex('salaries') .where(function() &#123; // arrow function을 사용하면 안 됩니다! this .where('emp_no', '&gt;', 20000) .andWhere('salary', '&gt;', 150000) &#125;) .orWhere(function() &#123; this .where('emp_no', '&lt;', 11000) .andWhere('salary', '&lt;', 60000) &#125;) .limit(3) .toString()/*select * from `salaries`where (`emp_no` &gt; 20000 and `salary` &gt; 150000) or (`emp_no` &lt; 11000 and `salary` &lt; 60000)limit 3*/ 이 안에서는 errow function을 사용할 수 없다 why? this의 성격때문이다. error function에서 this는 한번 정해지면 바꿀수 없기 때문이다. 그 밖에 아래와 같은 메소드들이 있습니다. whereIn whereNotIn whereNull whereNotNull whereExists whereNotExists whereBetween whereNotBetween andWhereNot orWhereNot 자세한 사용법은 공식 문서를 참고해주세요. INSERT123456789101112131415161718192021knex('employees') .insert(&#123; emp_no: 876543, first_name: 'fast', last_name: 'campus', birth_date: '1960-01-01', hire_date: '1980-01-01', gender: 'M' &#125;) .toString()// 찾는 방법knex('employees').where('emp_no', 876543).then(console.log)// 방법2knex('employees').where(&#123;emp_no: 876543&#125;).then(console.log)/*insert into `employees` (`birth_date`, `emp_no`, `first_name`, `gender`, `hire_date`, `last_name`)values ('1960-01-01', 876543, 'fast', 'M', '1980-01-01', 'campus')*/ UPDATE12345678910knex('employees') .where(&#123;emp_no: 876543&#125;) .update(&#123;last_name: 'five'&#125;) .toString()/*update `employees`set `last_name` = \\'five\\'where `emp_no` = 876543*/ DELETE123456789knex('employees') .where(&#123;emp_no: 876543&#125;) .delete() .toString()/*delete from `employees`where `emp_no` = 876543*/ DELETE, UPDATE는 where절을 사용하지 않는다면 전체가 업데이트 or 삭제가 되니 꼭 where절을 사용해야한다. ORDER BYorderBy 메소드를 사용해서 ORDER BY 구문을 빌드할 수 있습니다. 1234567891011knex('employees') .orderBy('first_name', 'desc') .orderBy('last_name') .limit(3) .toString()/*select * from `employees`order by `first_name` desc, `last_name` asclimit 3*/ LIMIT, OFFSETlimit, offset 메소드를 사용해서 각각 LIMIT, OFFSET 구문을 빌드할 수 있습니다. limit : 위에서부터 개수만큼 offset : 100개를 건너뛰고나서부터 123456789knex('employees') .limit(3) .offset(100) .toString()/*select * from `employees`limit 3 offset 100*/ 집계함수Knex 인스턴스의 count, max, min, sum, avg 등의 메소드를 통해 집계함수를 빌드할 수 있습니다.1234567891011121314knex('salaries') .count('*') .toString()/*select count(*) as `c` from `salaries`*/knex('salaries') .max('salary') .toString()/*select max(*) as `m` from `salaries`*/ 집계함수의 인자로 넘기는 문자열 뒤에 as를 붙여서, 반환되는 객체들의 속성 이름을 바꿀 수 있습니다. 123456789101112knex('salaries') .max('salary') .then(console.log)// 결과[ &#123; 'max(`salary`)': 158220 &#125; ]knex('salaries') .max('salary as s') .then(console.log)// 결과[ &#123; s: 158220 &#125; ] GROUP BY &amp; HAVINGgroupBy 메소드를 통해 GROUP BY 구문을 빌드할 수 있습니다. 보통 위에서 다뤘던 집계함수와 함께 사용합니다. 12345678910111213knex('salaries') .select('emp_no') .max('salary as max_salary') .groupBy('emp_no') .limit(10) .toString()/*select `emp_no`, max(`salary`) as `max_salary`from `salaries`group by `emp_no`limit 10*/ having 메소드를 통해 HAVING 구문을 빌드할 수 있습니다. 사용법은 where 메소드와 비슷합니다. 12345678910111213knex('salaries') .select('emp_no') .max('salary as max_salary') .groupBy('emp_no') .having('max_salary', '&gt;', 150000) .toString()/*select `emp_no`, max(`salary`) as `max_salary`from `salaries`group by `emp_no`having `max_salary` &gt; 150000*/ JOINjoin 메소드를 이용해 INNER JOIN 구문을 빌드할 수 있습니다. 1234567891011knex('employees') .select('first_name', 'salary') .join('salaries', 'employees.emp_no', 'salaries.emp_no') .limit(10) .toString()/*select `first_name`, `salary` from `employees`inner join `salaries` on `employees`.`emp_no` = `salaries`.`emp_no`limit 10*/ 이 밖에 조인과 관련된 여러 메소드를 지원합니다. leftOuterJoin rightOuterJoin fullOuterJoin 자세한 사용법은 공식 문서를 참고해주세요. 서브쿼리단일 행 서브쿼리, 다중 행 서브쿼리 모두 자연스러운 방식으로 사용할 수 있습니다. Knex 인스턴스를 통해 작성한 쿼리 객체를, where 혹은 whereIn 메소드의 인자로 사용할 수 있습니다. 1234567891011121314151617// 1999년도 이전의 최고연봉보다 더 많은 연봉을 받은 사람들의 사원 번호를 출력합니다.const subquery = knex('salaries') .max('salary') .where('from_date', '&lt;', '1999-01-01')knex('salaries') .distinct('emp_no') .where('salary', '&gt;', subquery) .toString()/*select distinct `emp_no` from `salaries`where `salary` &gt; ( select max(`salary`) from `salaries` where `from_date` &lt; '1999-01-01')*/ 1234567891011121314151617// first_name = 'Georgi' 를 만족하는 사람들의 last_name을 출력합니다.const subquery = knex('employees') .select('emp_no') .where('first_name', 'Georgi')knex('employees') .select('last_name') .whereIn('emp_no', subquery) .toString()/*select `last_name` from `employees`where `emp_no` in ( select `emp_no` from `employees` where `first_name` = 'Georgi')*/ Utility Functions.first()Knex를 통해 쿼리를 실행하면 보통 배열이 반환됩니다. 이것은 limit(1) 처럼 하나의 행이 반환될 것이 확실한 경우에도 마찬가지입니다. 1234567knex('employees') .select('emp_no') .limit(1) .then(console.log)// 결과[ &#123; emp_no: 10001 &#125; ] 매 번 하나의 행이 들어있는 배열을 다루는 것은 불편하므로, 아래와 같이 Knex 인스턴스의 first 메소드를 이용해서 배열이 아닌 객체가 반환되도록 동작을 바꿀 수 있습니다. 1234567knex('employees') .select('emp_no') .first() .then(console.log)// 결과&#123; emp_no: 10001 &#125; 만약 반환된 행이 없다면 first의 결과는 undefined가 됩니다. .raw()MySQL과 같은 DBMS에는 기능이 굉장히 많고, 또 버전이 올라가면서 추가되는 기능들도 많습니다. Knex에는 많은 기능들이 내장되어 있지만, DBMS의 모든 기능을 지원하는 것은 아닙니다. Knex가 지원하지 않는 기능(내장함수 등)을 Knex를 통해 사용하기 위해서는 직접 쿼리를 작성하는 작업이 필요한데, 이를 위해 Knex는 아래와 같은 메소드들을 가지고 있습니다. raw whereRaw joinRaw havingRaw groupByRaw orderByRaw 이 중 raw 메소드를 이용하면 직접 작성한 쿼리를 여러 메소드에서 사용할 수 있습니다. 아래의 예제를 참고해주세요. 12345knex('users') .select(knex.raw('count(*) as user_count, status')) .where(knex.raw(1)) .orWhere(knex.raw('status &lt;&gt; ?', [1])) // &lt;&gt; 는 다르다는 의미이다. .groupBy('status') 주의! 위 예제와 같이 raw 관련 메소드들 특별한 방식으로 쿼리에 변수를 삽입하게 만들어져 있습니다. 쿼리 내에 변수를 삽입하고 싶은 경우에는 반드시 raw 메소드가 제공하는 방법을 통해서 해야 합니다. 예를 들어, 위 예제의 orWhere 안에 있는 raw 메소드를 아래와 같이 작성할 수도 있을 것입니다. knex.raw(‘status &lt;&gt; ?’, [1]) 1부분에 원하는 변수를 꼭 넣어야한다! 안의 값으로는 req.body, req.params 등과 같은 값들을 넣을 수 있다. 1234// 주의!const status = [1]knex.raw(`status &lt;&gt; $&#123;status&#125;`)// 이렇게 하면 절.대.로 안됩니다. 위와 같이 작성된 코드는 SQL injection 공격에 무방비로 노출되게 됩니다. 따라서, 쿼리 문자열 내에 변수를 삽입할 때는 절대로 ES2015의 template literal을 사용하지 마시고, raw 메소드가 제공하는 방식을 사용하세요. raw 메소드의 자세한 사용법은 공식 문서를 참고해주세요.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"knex","slug":"Node-js/knex","permalink":"http://yoursite.com/categories/Node-js/knex/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"kenx","slug":"kenx","permalink":"http://yoursite.com/tags/kenx/"}]},{"title":"Node-Knex-Schema","slug":"node-study-knex-schema","date":"2017-09-14T03:54:00.000Z","updated":"2017-09-30T13:08:52.000Z","comments":true,"path":"2017/09/14/node-study-knex-schema/","link":"","permalink":"http://yoursite.com/2017/09/14/node-study-knex-schema/","excerpt":"","text":"Node knex SchemaKnex - Schema BuilderKnex는 데이터를 읽어오고 조작하는 쿼리(DML, Data Manipulation Language) 뿐만 아니라 테이블을 생성하고 조작하는 쿼리(DDL, Data Definition Language)도 지원합니다. knex.schema로 반환되는 객체를 이용해 테이블을 만들고, 수정하고, 삭제하는 등의 작업을 할 수 있습니다. 여기서 schema는 getter function으로, 반환된 객체는 재사용이 불가능하다는 점에 주의하세요. CREATE TABLE다양한 타입의 컬럼을 만들 수 있습니다. 1234567891011121314151617181920212223242526272829knex.schema.createTable('table_name', function(table) &#123; // INTEGER table.integer('column_name') // TEXT table.text('column_name') // VARCHAR(255) (255 생략 가능) table.string('column_name', 255) // FLOAT(8, 2) (8, 2 생략 가능) table.float('column_name', 8, 2) // DECIMAL(8, 2) (8, 2 생략 가능) table.decimal('column_name', 8, 2) // 저장은 TINYINT 타입으로 되나 JS 측에서 boolean으로 사용 table.boolean('column_name') // DATETIME table.datetime('column_name') // TIMESTAMP (시각과 시간대를 같이 저장하는 타입) table.timestamp('column_name') // ENUM table.enum('column_name', ['M', 'F'])&#125;) 아래와 같이 제약 조건을 걸 수 있습니다. 12345678910111213141516171819202122232425262728293031323334knex.schema.createTable('table_name', function(table) &#123; // `id` 라는 이름의 INTEGER UNSIGNED 컬럼을 만들고, PRIMARY KEY 및 AUTO_INCREMENT 제약조건을 지정합니다. table.increments(); // `col1` 이라는 이름의 INTEGER 컬럼을 만들고, PRIMARY KEY 제약조건을 지정합니다. table.integer('col1').primary() // `col1`, `col2` 컬럼을 묶어서 PRIMARY KEY 제약조건을 지정합니다. table.primary(['col1', 'col2']) // `col2` 이라는 이름의 INTEGER UNSSIGNED 컬럼을 만듭니다. table.integer('col2').unssigned() // `col3` 이라는 이름의 INTEGER 컬럼을 만들고 기본값을 0으로 설정합니다. table.integer('col3').defaultTo(0) // `created_at` 컬럼을 만들고 기본값을 현재 시각으로 설정합니다. table.timestamp('creatd_at').defaultTo(knex.fn.now()) // `col4` 이라는 이름의 INTEGER 컬럼을 만들고 NOT NULL 제약조건을 지정합니다. table.integer('col4').notNullable() // `other_table_id` 컬럼을 `other_table` 테이블의 `id`에 대한 FOREIGN KEY로 지정합니다. table.foreign('other_table_id').references('other_table.id') // 참조하고 있는 `other_table`의 레코드가 삭제되었을 때 어떻게 동작할 것인지를 지정할 수도 있습니다. table.foreign('other_table_id').references('other_table.id').onDelete('RESTRICT') // `col1` 컬럼에 UNIQUE 제약조건을 지정합니다. table.unique('col1') // `col1`, `col2` 컬럼을 묶어서 UNIQUE 제약조건을 지정합니다. table.unique(['col1', 'col2'])&#125;) ALTER TABLE이미 만들어진 테이블을 수정할 수도 있습니다. 1234567891011knex.schema.alterTable('table_name', function(table) &#123; // 컬럼의 이름을 변경합니다. table.renameColumn('old_column_name', 'new_column_name') // 새 컬럼을 추가합니다. table.integer('new_int_column') // 컬럼을 새로 생성하는 것이 아니라 이미 존재하는 컬럼을 수정하는 것임을 명시하기 위해 // `alter` 메소드를 사용합니다. table.integer('old_int_column').notNullable().alter()&#125;) Knex는 이 외에도 많은 DDL 관련 기능을 지원합니다. 자세한 사용법은 공식 문서를 참고해주세요. 실습123456789101112131415// schema.jsconst knex = require('./knex')knex.schema.createTable('user', t =&gt; &#123; t.string('id').primary() t.string('password').notNullable()&#125;).then(() =&gt; knex.schema.createTable('url_entry', t =&gt; &#123; t.string('id', 8).primary() t.string('long_url').notNullable() t.string('user_id') t.foreign('user_id').references('user.id') t.timestamp('created_at').defaultTo(knex.fn.now())&#125;)).then(process.exit)// 실행 node src/schema.js 하면 DB에 생성된다. 123456789101112131415// knex.jsrequire('dotenv').config()module.exports = require('knex')(&#123; client: 'mysql', connection: &#123; host: 'localhost', user: 'root', password: '****', database: 'url_shortner' &#125;, debug: true&#125;)// node안에서 작성하는 구문 : knew = require('./src/knex) database의 이름을 맞춰야한다. 123456789101112131415// schema.jsconst knex = require('./knex')knex.schema.createTable('user', t =&gt; &#123; t.string('id').primary() t.string('password').notNullable()&#125;).then(() =&gt; knex.schema.createTable('url_entry', t =&gt; &#123; t.string('id', 8).primary() t.string('long_url').notNullable() t.string('user_id') t.foreign('user_id').references('user.id') t.timestamp('created_at').defaultTo(knex.fn.now())&#125;)).then(process.exit)// 실행 node src/schema.js 하면 DB에 생성된다. local환경이라면 session의 name은 각각 다르게 해줘야한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"knex","slug":"Node-js/knex","permalink":"http://yoursite.com/categories/Node-js/knex/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"kenx","slug":"kenx","permalink":"http://yoursite.com/tags/kenx/"}]},{"title":"Node-DataModeling","slug":"node-study-datamodeling","date":"2017-09-13T03:54:00.000Z","updated":"2017-10-04T11:41:10.000Z","comments":true,"path":"2017/09/13/node-study-datamodeling/","link":"","permalink":"http://yoursite.com/2017/09/13/node-study-datamodeling/","excerpt":"","text":"DataBase Modeling 회원 =&gt; 회원번호, 아이디, 패스워드, 이름, 전화번호, 성별, 생년월일, 가입일자, 탈퇴일자, 주소, 연령대 로그인 =&gt; 로그인 일시, IP, 회원번호 장바구니 =&gt; 장바구니 번호, 상품번호, 담은시간, 회원번호 상품 =&gt; 상품번호, 상품명, 가격, 사이즈 구매 =&gt; 회원번호, 구매시간, 상품번호 생일쿠폰 =&gt; 쿠폰번호, 회원번호 시나리오 회원가입을 통하여 이 쇼핑몰 사이트를 이용할 수 있다. 회원은 로그인을 할 때마다 로그인정보(로그인 일시, 아이디, IP, 회원번호)가 기록된다. 회원가입시 필요한 정보는 (회원번호, 아이디, 패스워드, 가입일자, 탈퇴일자, 주소, 전화번호, 연령대, 성별)이다. 회원은 물품을 검색할 수 있다. 검색된 물품은 (상품명, 가격, 사이즈)가 보여진다. 회원은 물품을 장바구니에 담을 수 있다. 회원은 물건을 구매할 경우 (구매시간, 회원번호, 상품번호) pk로 가지게 된다. 회원은 생일이면 생일 쿠폰을 받는다. ￼ ERD SQL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138-- MySQL Workbench Synchronization-- Generated: 2017-09-13 19:19-- Model: New Model-- Version: 1.0-- Project: Name of the project-- Author: 김세준SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='TRADITIONAL,ALLOW_INVALID_DATES';CREATE SCHEMA IF NOT EXISTS `mydb` DEFAULT CHARACTER SET utf8 ;CREATE TABLE IF NOT EXISTS `mydb`.`User` ( `u-number` INT(11) NOT NULL COMMENT ' \\n', `id` VARCHAR(45) NOT NULL COMMENT ' ', `pwd` VARCHAR(45) NOT NULL, `name` VARCHAR(45) NOT NULL, `call` INT(11) NOT NULL, `gender` VARCHAR(45) NULL DEFAULT NULL, `birth` INT(11) NOT NULL, `join-date` DATETIME NOT NULL, `session-date` DATETIME NULL DEFAULT NULL, `address` VARCHAR(45) NOT NULL, `ages` VARCHAR(45) NULL DEFAULT NULL, PRIMARY KEY (`u-number`))ENGINE = InnoDBDEFAULT CHARACTER SET = utf8;CREATE TABLE IF NOT EXISTS `mydb`.`Login` ( `login-date` DATETIME NOT NULL, `IP` VARCHAR(45) NULL DEFAULT NULL, `User_u-number` INT(11) NOT NULL, PRIMARY KEY (`login-date`, `User_u-number`), INDEX `fk_Login_User1_idx` (`User_u-number` ASC), CONSTRAINT `fk_Login_User1` FOREIGN KEY (`User_u-number`) REFERENCES `mydb`.`User` (`u-number`) ON DELETE NO ACTION ON UPDATE NO ACTION)ENGINE = InnoDBDEFAULT CHARACTER SET = utf8;CREATE TABLE IF NOT EXISTS `mydb`.`Basket` ( `basket-number` INT(11) NOT NULL, `select-date` DATETIME NULL DEFAULT NULL, `User_u-number` INT(11) NOT NULL, `Product_product-number` INT(11) NOT NULL, PRIMARY KEY (`basket-number`, `User_u-number`, `Product_product-number`), INDEX `fk_Basket_User1_idx` (`User_u-number` ASC), INDEX `fk_Basket_Product1_idx` (`Product_product-number` ASC), CONSTRAINT `fk_Basket_User1` FOREIGN KEY (`User_u-number`) REFERENCES `mydb`.`User` (`u-number`) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT `fk_Basket_Product1` FOREIGN KEY (`Product_product-number`) REFERENCES `mydb`.`Product` (`product-number`) ON DELETE NO ACTION ON UPDATE NO ACTION)ENGINE = InnoDBDEFAULT CHARACTER SET = utf8;CREATE TABLE IF NOT EXISTS `mydb`.`Product` ( `product-number` INT(11) NOT NULL, `product-name` VARCHAR(45) NULL DEFAULT NULL, `price` VARCHAR(45) NULL DEFAULT NULL, `size` VARCHAR(45) NULL DEFAULT NULL, PRIMARY KEY (`product-number`))ENGINE = InnoDBDEFAULT CHARACTER SET = utf8;CREATE TABLE IF NOT EXISTS `mydb`.`Buy` ( `buy-date` DATETIME NOT NULL, `Product_product-number` INT(11) NOT NULL, `User_u-number` INT(11) NOT NULL, PRIMARY KEY (`buy-date`, `Product_product-number`, `User_u-number`), INDEX `fk_Buy_Product1_idx` (`Product_product-number` ASC), INDEX `fk_Buy_User1_idx` (`User_u-number` ASC), CONSTRAINT `fk_Buy_Product1` FOREIGN KEY (`Product_product-number`) REFERENCES `mydb`.`Product` (`product-number`) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT `fk_Buy_User1` FOREIGN KEY (`User_u-number`) REFERENCES `mydb`.`User` (`u-number`) ON DELETE NO ACTION ON UPDATE NO ACTION)ENGINE = InnoDBDEFAULT CHARACTER SET = utf8;CREATE TABLE IF NOT EXISTS `mydb`.`Coupon` ( `coupon-number` INT(11) NOT NULL, `User_u-number` INT(11) NOT NULL, PRIMARY KEY (`coupon-number`, `User_u-number`), INDEX `fk_생일쿠폰_User_idx` (`User_u-number` ASC), CONSTRAINT `fk_생일쿠폰_User` FOREIGN KEY (`User_u-number`) REFERENCES `mydb`.`User` (`u-number`) ON DELETE NO ACTION ON UPDATE NO ACTION)ENGINE = InnoDBDEFAULT CHARACTER SET = utf8;SET SQL_MODE=@OLD_SQL_MODE;SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;use mydb;SELECT * FROM user;INSERT INTO user VALUES (1,'sejune','kim','kimsejune','01045401088','men','930907','170913', null, '경기도 시흥시 정왕동', '25');SELECT*FROM login;INSERT INTO login VALUES(now(), '192.168.0.1', 1);SELECT*FROM coupon;INSERT INTO coupon VALUES(1, 1);SELECT * FROM Product;INSERT INTO product VALUES(1, '슬렉스(검정)', '200000', '29');SELECT * FROM buy;INSERT INTO buy VALUES (now(), 1, 1);SELECT * FROM Basket;INSERT INTO basket VALUES(1, now(), 1, 1);","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"DataModeling","slug":"Node-js/DataModeling","permalink":"http://yoursite.com/categories/Node-js/DataModeling/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"DataModeling","slug":"DataModeling","permalink":"http://yoursite.com/tags/DataModeling/"}]},{"title":"Node-Database","slug":"node-study-database","date":"2017-09-11T03:54:00.000Z","updated":"2017-09-22T13:03:45.000Z","comments":true,"path":"2017/09/11/node-study-database/","link":"","permalink":"http://yoursite.com/2017/09/11/node-study-database/","excerpt":"","text":"DataBase데이터베이스와 테이블의 생성CREATE DATABASE는 데이터베이스를 만드는 명령어입니다. 워크벤치에서 root 계정으로 로그인한 후, 아래의 SQL을 실행해보세요.12345-- 데이터베이스 생성CREATE DATABASE my_db;-- 모든 데이터베이스의 목록SHOW DATABASES; CREATE TABLE은 테이블을 만드는 명령입니다. 아래 명령을 차례로 실행해보세요.123456789101112131415161718-- 테이블 생성CREATE TABLE my_db.users ( -- `name`이라는 이름의 문자열 컬럼을 생성합니다. NULL을 허용하지 않습니다. name VARCHAR(30) NOT NULL, -- `job`이라는 이름의 문자열 컬럼을 생성합니다. NULL을 허용합니다. job VARCHAR(30), -- `age`라는 이름의 양수 컬럼을 생성합니다. NULL을 허용합니다. age INTEGER UNSIGNED, -- `name` 컬럼을 기본 키로 지정합니다. PRIMARY KEY (name));-- my_db 데이터베이스에 있는 모든 테이블의 목록SHOW TABLES FROM my_db;-- my_db.users 테이블에 대한 자세한 정보DESCRIBE my_db.users;SHOW CREATE TABLE post; USE [database]는 기본 데이터베이스를 설정하는 명령입니다. 즉, SQL을 작성할 때 데이터베이스 이름을 생략할 수 있게 만들어줍니다. 워크벤치에서는 사이드바의 데이터베이스 이름을 더블 클릭해도 같은 동작을 합니다. 기본 데이터베이스를 선택한 후 아래 명령을 실행해보세요.1DESCRIBE my_table; 데이터 추가하기12345678910-- 하나의 레코드 추가하기INSERT INTO users (name, job, age)VALUES ('윤민지', '프론트엔드 개발자', 32);-- 여러 개의 레코드 추가하기INSERT INTO users (name, job, age)VALUES ('한주원', '프론트엔드 개발자', 39),('박현숙', '백엔드 개발자', 48),('정병언', NULL, 25),('임동면', '디자이너', NULL); 데이터 불러오기1234-- 모든 컬럼을 포함시켜 불러오기SELECT * FROM users;-- 특정 컬럼만 포함시켜 불러오기SELECT name, job FROM users; 데이터 수정하기123UPDATE usersSET job = '프로그래머'WHERE name = '정병언'; 데이터 삭제하기12DELETE FROM usersWHERE name = '정병언'; 데이터베이스와 테이블의 삭제1234567DROP DATABASE, DROP TABLE 명령은 각각 데이터베이스와 테이블을 삭제하는 명령입니다. 아래의 명령을 차례대로 실행해보세요.-- users 테이블 삭제DROP TABLE users;-- my_db 데이터베이스 삭제DROP DATABASE my_db; 관계형 데이터베이스의 구성요소Database (데이터베이스) 테이블 및 다른 구성요소들을 모아놓은 집합입니다. 스키마라고도 불리는데, 스키마라는 용어는 ‘데이터베이스’를 의미하기도 하고 ‘데이터베이스의 구조’를 의미하기도 합니다. 하나의 DBMS는 여러 개의 데이터베이스를 가질 수 있으며, 데이터베이스 단위로 권한 설정이 이루어집니다. User &amp; Privilege (사용자 &amp; 권한) 하나의 DBMS는 여러 개의 사용자 계정을 가질 수 있습니다. DBMS를 사용하려면 사용자 계정을 이용해 DBMS에 접속해야 합니다. 사용자 계정은 데이터베이스 별로 다른 권한을 가집니다. root 유저는 DBMS 초기 설치 시에 만들어지는 계정이며, DBMS에 대한 모든 권한을 부여받습니다. Connection 사용자 계정을 이용해 데이터베이스에 접속하면, 새 커넥션이 만들어집니다. 세션과 유사한 개념입니다. 커넥션 별로 여러가지 옵션을 설정할 수 있고, 트랜잭션도 커넥션 단위로 수행됩니다. 하나의 클라이언트에서 여러 개의 트랜잭션을 수행하기 위해 여러 커넥션을 이용할 수 있습니다. Table (테이블) 하나의 데이터베이스는 여러 개의 테이블을 가질 수 있습니다. 표 형태로 구조화된 데이터가 테이블에 저장됩니다. 테이블의 행(row)은 개별적인 레코드를 나타내며, 테이블의 열(column)은 레코드의 속성을 나타냅니다. 각각의 열에는 미리 정의된 자료형에 해당하는 데이터만 저장될 수 있습니다. 테이블의 각 행은 기본 키(primary key)를 이용해 식별하고, 테이블 내에서 유일한 값이어야 합니다. 기본 키는 다른 테이블과의 관계를 나타낼 때 사용됩니다. Constraint (제약 조건)제약 조건을 지정하면 테이블에 특정한 방식으로만 데이터가 저장될 수 있도록 할 수 있습니다. 아래 제약 조건들이 자주 사용됩니다. NOT NULL : 컬럼에 NULL 값이 저장되지 못하도록 막습니다. UNIQUE : 한 테이블 내에서 컬럼에 저장된 모든 값이 유일하도록 강제합니다. PRIMARY KEY : NOT NULL과 UNIQUE가 동시에 적용됩니다. PRIMARY KEY 제약 조건이 걸린 컬럼은 각 행의 식별자로 사용됩니다. FOREIGN KEY : 다른 테이블의 primary key를 참조합니다. 해당 primary key를 가진 레코드가 변경되었을 때 특정 동작을 강제할 수 있습니다. DEFAULT : INSERT 구문을 사용해서 레코드를 추가할 때, 컬럼에 아무런 값도 지정하지 않으면 DEFAULT 제약 조건으로 지정한 기본값이 저장되도록 합니다. CHECK : 레코드가 주어진 계산식을 만족해야만 하도록 CHECK 제약 조건을 지정할 수 있습니다. 123456CREATE TABLE adult ( name varchar(255) NOT NULL, nationality varchar(255) DEFAULT '대한민국', age int, CHECK (age &gt;= 18)); Primary Key, Foreign KeyPrimary Key(기본 키)로 지정된 컬럼에 저장되어 있는 값은 테이블에 저장되어 있는 레코드의 식별자 역할을 합니다. Foreign Key(외래 키)로 지정된 컬럼에는 다른 테이블의 기본 키 값이 저장되며, 다른 테이블의 레코드를 참조함으로써 해당 테이블과의 관계를 나타냅니다. 여러 컬럼이 한꺼번에 기본 키로 지정될 수도 있습니다. 이를 Composite primary key(한국어로는 합성키, 혹은 슈퍼키라고 부름)라고 합니다. 테이블 생성테이블을 생성할 때는 CREATE TABLE 구문을 사용합니다. 123456789101112131415161718192021222324252627CREATE TABLE my_table ( -- 일반적인 컬럼은 아래와 같의 정의합니다. 이 컬럼에는 NULL 값이 저장될 수 있습니다. my_col1 INTEGER, -- 컬럼의 기본값을 지정합니다. my_col2 INTEGER DEFAULT 0, -- 컬럼에 NULL 값이 저장될 수 없도록 제한을 둡니다. my_col3 INTEGER NOT NULL, -- UNIQUE 제약조건: 컬럼의 값은 테이블 내에서 유일해야 합니다. my_col4 INTEGER UNIQUE, -- 다양한 옵션을 한 번에 지정할 수 있습니다. my_col5 INTEGER NOT NULL DEFAULT 1, my_col6 INTEGER NOT NULL UNIQUE, -- 1부터 시작하는 식별자를 아래와 같이 정의합니다. -- PRIMARY KEY는 기본적으로 NOT NULL, UNIQUE 규칙이 적용됩니다. my_id INTEGER UNSIGNED AUTO_INCREMENT PRIMARY KEY, -- 컬럼 정의와 별도로, 여러가지 제약 조건과 인덱스를 아래에 지정할 수 있습니다. -- 제약 조건과 인덱스에 대해서는 추후 배울 것입니다. FOREIGN KEY (my_id) REFERENCES your_table(your_id) ON DELETE CASCADE, INDEX my_idx (my_col1, my_col2), ...) 테이블이 이미 존재하는 경우에도 구문이 에러 없이 실행되도록 IF NOT EXISTS 구문을 사용할 수 있습니다. 123CREATE TABLE IF NOT EXISTS table_name ( ...) 테이블 수정1234567ALTER TABLE table_nameRENAME new_table_name, -- 테이블 이름 변경ADD COLUMN column_name INTEGER NOT NULL, -- 컬럼 추가ADD CONSTRAINT UNIQUE, -- 제약 조건 추가CHANGE old_column_name new_column_name INTEGER, -- 컬럼 이름 변경MODIFY column_name NEW_TYPE -- 컬럼 타입 변경DROP COLUMN column_name; -- 컬럼 제거 자세한 사용법은 공식 문서를 참고해주세요. MySQL 데이터 타입문자열VARCHAR짧은 문자열을 저장하기 위해 가장 널리 사용되는 타입입니다. 컬럼 타입으로 지정할 때는 아래와 같이 문자열의 길이(바이트)를 명시해야 합니다. 1VARCHAR(255) -- 255는 가장 널리 사용되는 길이입니다. TEXT긴 문자열을 저장하기 위해 사용되는 타입입니다. TEXT 타입의 컬럼에는 64MB까지 저장할 수 있습니다. 요구사항에 따라 크기가 다른 다양한 종류의 TEXT 타입(TINYTEXT, TEXT, MEDIUMTEXT, LONGTEXT)을 사용할 수 있습니다. 수정수, 고정 소수점, 부동 소수점을 위한 타입이 있습니다. 모든 수 타입은 양수만을 저장하기 위해 타입 뒤에 UNSIGNED 지시자를 사용할 수 있습니다. INTEGER정수를 위한 타입입니다. INT로 줄여 쓸 수도 있습니다. 요구사항에 따라 크기가 다른 다양한 종류의 INT 타입(TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT)을 사용할 수 있습니다. 1INTEGER UNSIGNED -- INTEGER 타입의 양수를 저장할 수 있습니다. MySQL에는 참, 거짓을 나타내는 boolean 관련 타입이 없습니다. 대신 TINYINT를 사용합니다. DECIMAL고정 소수점 수를 위한 타입입니다. 십진수의 정확한 계산이 필요할 때 사용합니다. 정수부(최대 65), 소수부(최대 30, 정수부보다 짧거나 같아야 함)의 최대 길이를 각각 지정할 수 있습니다. 1DECIMAL(5, 2) -- 12345.67과 같은 수를 저장할 수 있습니다. DOUBLE부동 소수점 수를 위한 타입입니다. 소수의 빠른 계산과 효율적 저장이 필요할 때 사용합니다. 시각MySQL에는 시각의 저장을 위한 타입들이 준비되어 있습니다. 주로 사용되는 아래의 두 타입은 시간대 정보를 저장하지 않기 때문에, 사용에 주의를 요합니다. DATEDATE 타입은 날짜를 위한 타입입니다. DATETIMEDATETIME 타입은 날짜와 시각을 같이 저장해야 할 때 사용합니다. 기타ENUM: 열거형을 위한 타입입니다.JSON: MySQL 5.7에 JSON 지원이 추가되었으나, 널리 사용되지는 않습니다.POINT, GEOMETRY : 공간 정보를 위한 타입입니다. 계정 만들기실습하기에 앞서, employees 데이터베이스에만 접속할 수 있는 emplyees_user 계정을 만든 후 그 계정을 이용해 MySQL에 접속해봅시다. SELECT가장 단순한 SELECT 구문을 실행해보겠습니다. 1SELECT * FROM employees; 실행 후, 아래와 같이 결과가 나오면 성공입니다. employees 테이블에는 어떤 컬럼들이 있는지, 각 컬럼에는 어떤 형태의 데이터가 저장되고 있는지 파악해두도록 합시다. MySQL Workbench는 레코드의 갯수가 많을 경우에 1000개 단위로 페이지를 끊어서 보여주는 기능을 가지고 있습니다. 이미지의 우측 상단에 빨갛게 표시된 버튼들을 눌러서 페이지를 이동할 수 있습니다. 이제 테이블의 일부 컬럼만 불러오는 구문을 실행해보겠습니다. 1SELECT first_name FROM employees; 위 명령은 employees 테이블에서 first_name 컬럼만을 불러옵니다. 아래와 같이 여러 개의 컬럼을 선택적으로 불러올 수 있습니다. 1SELECT first_name, last_name FROM employees; 또는 SQL 실행 결과로 출력되는 테이블의 컬럼의 이름을 바꾸어 출력할 수도 있습니다. 아래와 같이 각 컬럼의 이름 뒤에 AS 구문을 사용하면 됩니다. backtick(`) 문자를 사용해 컬럼의 이름에 MySQL 예약어나 공백 문자를 넣을 수 있습니다. (권장되지는 않습니다.) 1SELECT first_name AS `family name`, last_name AS `given name` FROM employees; AS를 생략하고 써도 같은 의미입니다. 1SELECT first_name `family name`, last_name `given name` FROM employees; 정렬하기ORDER BY 구문을 사용하면 특정 컬럼에 대한 정렬 기준을 세워 테이블을 출력할 수 있습니다. 아래와 같이 hire_date 컬럼을 기준으로 오름차순 정렬을 시킬 수 있습니다. 12SELECT emp_no, hire_date, birth_date FROM employeesORDER BY hire_date; ORDER BY 구문에 포함된 컬럼이 꼭 SELECT 구문에 포함될 필요는 없습니다. 아래와 같이 SELECT 구문에서 hire_date를 생략해도 문제 없습니다. 12SELECT emp_no FROM employeesORDER BY hire_date; ORDER BY 구문은 여러 개의 컬럼에 대해서 정렬하는 기능도 지원합니다. 아래와 같이 여러 개의 컬럼을 쉼표로 구분해서 ORDER BY 구문에 넣어 주면 됩니다. 이 때, hire_date로 먼저 오름차순 정렬 되고 난 후, 같은 hire_date를 가진 레코드끼리 birth_date를 기준으로 오름차순 정렬이 이루어집니다. 12SELECT emp_no, hire_date, birth_date FROM employeesORDER BY hire_date, birth_date; ORDER BY 구문은 기본적으로 오름차순 정렬을 하게끔 되어 있습니다. 아래와 같이 DESC 구문을 사용하면 특정 컬럼에 대해서 내림차순 정렬을 하도록 명령할 수 있습니다. DESC와 ASC는 각각 ‘descending’과 ‘ascending’의 약자입니다. 12SELECT first_name, hire_date, birth_date FROM employeesORDER BY hire_date DESC, birth_date ASC; -- ASC는 생략 가능 Character Set &amp; CollationMySQL은 날짜, 숫자 뿐 아니라 문자열에 대한 정렬도 지원합니다. 아래와 같이 이름을 이용해 정렬을 할 수도 있습니다. 12SELECT first_name, last_name FROM employeesORDER BY last_name, first_name; MySQL은 다양한 언어와 문자셋을 지원합니다. 그런데 언어나 문자셋별로 문자열의 정렬 기준이 달라야 할 필요가 있습니다. 이러한 정렬 기준을 MySQL에서는 collation이라고 부릅니다. 한글의 경우, 문자셋은 utf8, collation은 utf8mb4_general_ci를 사용하면 됩니다. MySQL 사용 중에 불러온 문자열이 깨져 보인다거나 정렬이 제대로 되지 않는다면, 문자셋과 collation의 설정이 잘못되었을 확률이 높습니다. 현재 데이터베이스의 기본 문자셋과 collation을 확인하려면, 아래와 같이 워크벤치 좌측 데이터베이스 목록의 ‘i’ 모양 아이콘을 클릭하세요. 일부만 가져오기LIMIT 구문을 사용하면 레코드의 일부분만 불러올 수 있습니다. 12SELECT * FROM employeesLIMIT 5; LIMIT 구문은 정렬 순서에 영향을 받습니다. 예를 들어, 생일이 가장 빠른 1명의 기록을 불러오고 싶다면 아래와 같이 하면 됩니다. 123SELECT first_name, birth_date FROM employeesORDER BY birth_dateLIMIT 1; OFFSET 구문을 사용하면 앞쪽 기록의 일부분을 생략하고 나머지 기록들을 불러올 수 있습니다. 예를 들어, 생일이 열 번째로 빠른 1명의 기록을 불러오고 싶다면 아래와 같이 하면 됩니다. 123SELECT first_name, birth_date FROM employeesORDER BY birth_dateLIMIT 1 OFFSET 9; 중복되는 값 제거하기DISTINCT 구문을 사용하면 컬럼 내에 중복되는 값을 하나로 합쳐서 보여줍니다. 아래 두 쿼리의 결과를 비교해보세요. 12345SELECT first_name FROM employeesORDER BY first_name;SELECT DISTINCT first_name FROM employeesORDER BY first_name; 필터링과 연산자WHERE 구문을 사용하면 특정 조건을 만족하는 기록만을 선택적으로 불러올 수 있습니다. 12SELECT * FROM employeesWHERE first_name = 'Shahid' AND hire_date &gt; '1997-09-12'; 위와 같이 WHERE 구문에서는 조건을 나타내기 위해 연산자를 사용합니다. WHERE 구문 내에서 자주 사용되는 연산자와 그 뜻을 아래 표에서 확인할 수 있습니다. 연산자 우선순위여느 프로그래밍 언어가 그렇듯이 SQL에도 연산자 우선순위가 존재합니다. 예를 들어, OR보다 AND가 먼저 연산되기 때문에 아래와 같이 사용할 때는 주의해야 합니다. 1234-- first_name이 'Jeong' 혹은 'Shahid'인 사람들 중, 입사일이 '1997-09-12' 이후인 사람들을 불러오기 (틀림)SELECT * FROM employeesWHERE first_name = 'Jeong' OR first_name = 'Shahid' AND hire_date &gt; '1997-09-12';-- 뒤쪽의 AND가 먼저 연산되어, 원래 의도와는 다르게 first_name이 'Jeong'인 모든 사람들이 포함된 결과가 나옵니다. 아래와 같이 괄호를 사용해서 특정 연산이 먼저 실행되도록 할 수 있습니다. 123-- first_name이 'Jeong' 혹은 'Shahid'인 사람들 중, 입사일이 '1997-09-12' 이후인 사람들을 불러오기SELECT * FROM employeesWHERE (first_name = 'Jeong' OR first_name = 'Shahid') AND hire_date &gt; '1997-09-12'; 연산자 우선순위의 전체 목록을 확인하려면 공식 문서를 참고하세요. DATE, DATETIME 리터럴DATE 타입과 DATETIME 타입을 요구하는 문맥에서 아래와 같은 형태의 문자열을 사용하면, 자동으로 DATE와 DATETIME 형태로 해석됩니다. 12'YYYY-MM-DD HH:MM:SS' -- DATETIME을 나타내는 문자열 형식'YYYY-MM-DD' -- DATE를 나타내는 문자열 형식 문자열을 사용해서 아래와 같이 hire_date와 같은 DATE 형태의 컬럼에 대해 필터링을 할 수 있습니다. 12SELECT * FROM employeesWHERE hire_date &gt; '1997-09-12'; NULLNULL 값은 ‘데이터가 없음’을 나타내기 위한 목적으로 다루어지는 값입니다. 그런데 이 값은 연산 과정에서 특별하게 취급됩니다. 대부분의 연산자에 대해, 어떤 연산의 피연산자가 NULL이면 해당 연산의 결과는 무조건 NULL이 되게 됩니다. 1231 &gt; NULL -- 결과는 NULL이 됩니다.1 = NULL -- 결과는 NULL이 됩니다.NULL = NULL -- 심지어 이것도 NULL이 됩니다! 따라서, NULL 값을 허용하는 컬럼에 대해 연산을 할 때는 주의해야 합니다. 특히, 어떤 컬럼의 값이 NULL인지 아닌지 확인하기 위해서는 = 연산자 대신에 IS 혹은 IS NOT 연산자를 사용해야 합니다. 이를 테스트해보기 위해 NULL 값이 포함된 컬럼을 하나 추가합시다. 12INSERT INTO titles (emp_no, title, from_date, to_date)VALUES (10001, 'new title', '2017-09-11', NULL); TRUE 혹은 FALSE를 써야하는 문맥에 NULL을 쓰면, FALSE로 취급됩니다. 아래 SQL 명령의 결과를 비교해보시기 바랍니다. 123456789101112-- 이렇게 하면 안 됩니다!SELECT * FROM titlesWHERE to_date = NULL; -- 무조건 FALSE로 취급됨-- 반드시 이렇게 해야 합니다.SELECT * FROM titlesWHERE to_date IS NULL;-- 이렇게 하면 안 됩니다!SELECT * FROM titlesWHERE to_date != NULL; -- 무조건 FALSE로 취급됨-- 반드시 이렇게 해야 합니다.SELECT * FROM titlesWHERE to_date IS NOT NULL; salaries 테이블실습용 employees 데이터베이스의 salaries 테이블에는 각 사원의 연봉 변동 내역이 저장되어 있습니다. 본 문서에서는 salaries 테이블을 이용해 실습합니다. 집계 함수 (Aggregate Function)MySQL은 여러가지 집계 함수를 지원합니다. 집계 함수 의미MAX(col_name) 최대값MIN(col_name) 최소값SUM(col_name) 합계AVG(col_name) 평균COUNT(col_name) 컬림에 NULL이 아닌 값이 저장되어 있는 행의 갯수COUNT(*) 행의 갯수 123456SELECT MAX(salary) FROM salaries;SELECT MIN(salary) FROM salaries;SELECT SUM(salary) FROM salaries;SELECT AVG(salary) FROM salaries;SELECT COUNT(*) FROM employees; GROUP BY그룹이란 특정 컬럼에 같은 값을 갖고 있는 행들의 집합입니다. GROUP BY 구문을 사용해서, 위에서 했던 집계 작업을 그룹 단위로 수행할 수 있습니다. 123-- 각 사원이 연봉을 가장 많이 받을 때 얼마를 받았는지를 가져옵니다.SELECT emp_no, max(salary) FROM salariesGROUP BY emp_no; 12345-- 각 사원의 연봉이 총 몇 번 변경되었는지를 가져옵니다.-- AS 구문을 이용해 집계 컬럼의 이름을 변경할 수 있습니다.SELECT emp_no, count(*) AS salary_count FROM salariesGROUP BY emp_no;ORDER BY 구문을 사용해 그룹 집계의 결과를 정렬할 수도 있습니다. 12345-- 각 사원의 연봉이 총 몇 번 변경되었는지를 가져오고, 많이 변경된 순서대로 출력합니다.SELECT emp_no, count(*) AS salary_count FROM salariesGROUP BY emp_noORDER BY salary_count DESC;WHERE 구문을 사용해 집계에 포함될 레코드를 한정시킬 수도 있습니다. 12345-- 각 사원의 연봉이 1996년부터 2000년까지 총 몇 번 변경되었는지를 가져오고, 많이 변경된 순서대로 출력합니다.SELECT emp_no, count(*) AS salary_count FROM salariesWHERE from_date BETWEEN '1996-01-01' AND '2000-12-31'GROUP BY emp_noORDER BY salary_count DESC; HAVING그룹 집계의 결과에서 특정 그룹을 필터링한 결과를 출력할 수도 있습니다. HAVING 구문을 사용하면 되고, 문법은 WHERE 구문과 비슷합니다. 12345-- 최고 연봉이 15만 달러 이상인 사원의 사원 번호와 최고 연봉을 출력합니다. SELECT emp_no, max(salary) AS max_salary FROM salariesGROUP BY emp_noHAVING max_salary &gt; 150000ORDER BY max_salary DESC; WHERE, GROUP BY, HAVING, ORDER BY을 모두 사용한 쿼리입니다. 각 구문은 아래와 같은 순서대로 사용되어야 합니다. 123456-- 1996년과 2000년 사이에 받았던 최고 연봉이 15만 달러보다 높았던 사원의 사원 번호와 최고 연봉을 출력합니다.SELECT emp_no, max(salary) as max_salary FROM salariesWHERE from_date BETWEEN '1996-01-01' AND '2000-12-31'GROUP BY emp_noHAVING max_salary &gt; 150000ORDER BY max_salary DESC; 문자열 연산CONCAT 함수를 이용해 문자열을 이어붙일 수 있습니다. 1SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM employees; LOWER 함수와 UPPER 함수는 각각 문자열을 소문자/대문자로 바꾸어줍니다. 12SELECT UPPER(first_name) FROM employees;SELECT LOWER(first_name) FROM employees; LENGTH 함수는 문자열의 길이를 반환합니다. 12SELECT first_name, LENGTH(first_name) AS length_first_name FROM employeesORDER BY length_first_name DESC; SUBSTRING 함수는 문자열의 일부분을 반환합니다. SUBSTRING(문자열, 자를 인덱스, 자를 길이)와 같이 사용합니다. 자를 인덱스는 1부터 시작합니다. 1SELECT SUBSTRING(first_name, 1, 3) FROM employees; -- 앞의 세 글자를 반환 수 연산ABS 함수는 절대값을 반환합니다. 1SELECT ABS(-1); ROUND 함수는 반올림한 결과를 반환합니다. 1SELECT ROUND(1.5); 기타CURRENT_DATE 함수는 오늘 날짜를 DATE 형식을 반환합니다. NOW 함수는 현재 시각을 DATETIME 형식으로 반환합니다. 12SELECT CURRENT_DATE();SELECT NOW(); COALESCE 함수는 인자들 중 처음으로 NULL이 아닌 값을 반환합니다. 이 함수는 NULL 값과 NULL이 아닌 값이 모두 저장되어있는 컬럼을 불러올 때, NULL 값을 대체하기 위해 사용됩니다. 12345678-- 1이 출력됨SELECT COALESCE(NULL, 1);-- 2가 출력됨SELECT COALESCE(2, 1);-- 만약 nullable_column에 NULL이 저장되어 있으면 'DEFAULT_VALUE`를 반환하고, 아니면 컬럼에 저장되어있는 값을 그대로 반환SELECT COALESCE(nullable_column, 'DEFAULT_VALUE') FROM some_table; FROM, WHERE 구문을 통한 조인FROM 뒤에 여러 개의 테이블 이름을 적어서, 테이블을 합칠 수 있습니다. 12SELECT salaries.salary, salaries.from_date, employees.first_nameFROM salaries, employees; 이렇게 테이블을 합칠 수 있지만, 뭔가 이상합니다. 모든 사원의 연봉 변동 기록이 같은 것으로 나옵니다. 사실 위 코드는 틀린 코드입니다. 테이블을 어떻게 합칠 것인지 지정해주지 않았기 때문에, 결과는 두 테이블의 단순한 Cartesian product(곱집합)으로 나오게 됩니다. 그러면 테이블을 어떻게 합칠 것인지 지정해보겠습니다. 123SELECT salaries.salary, salaries.from_date, employees.first_nameFROM salaries, employeesWHERE salaries.emp_no = employees.emp_no; 이제야 잘 나오는 것 같습니다. 이렇게 테이블을 합칠 때에는 어떻게 합칠 지를 직접 명시해주어야 합니다. 이렇게 JOIN 구문을 사용하지 않고 FROM과 WHERE만을 사용해 조인하는 것을 암시적 조인(implicit join)이라고 합니다. JOIN 구문위의 예제처럼 테이블을 합칠 수도 있지만, 보통의 경우 JOIN 구문을 이용해서 조인을 하는 것이 관례입니다. (조인을 하고 있다는 것을 명확히 알 수 있고, 읽기도 쉽기 때문입니다.) 이렇게 직접 JOIN 구문을 사용해서 조인을 하는 것을 명시적 조인(explicit join)이라고 합니다. 아래의 예제는 바로 위의 암시적 조인과 완전히 같은 동작을 합니다. 123SELECT salaries.salary, salaries.from_date, employees.emp_no, employees.first_nameFROM salariesJOIN employees ON employees.emp_no = salaries.emp_no; FROM에 적었던 두 번째 테이블의 이름을 JOIN 바로 뒤에 적어주었습니다. 이렇게 FROM 구문으로 지정한 하나의 테이블에 JOIN 구문을 사용해서 다른 테이블을 합칠 수 있습니다. 이전에 WHERE를 이용해 적어주었던 기준은 ON 구문을 이용해 지정해줍니다. SELECT 구문 뒤에 오는 컬럼 이름 앞에는 테이블 이름을 table_name.column_name과 같은 형식으로 붙여줍니다. 만약 컬럼 이름이 여러 테이블에 걸쳐서 유일하다면 테이블 이름을 아래와 같이 생략할 수 있습니다. 1234-- `emp_no`는 두 테이블 모두 가지고 있기 때문에, 앞에 붙이는 테이블 이름을 생략할 수 없습니다.SELECT first_name, salary, from_date, employees.emp_noFROM salariesJOIN employees ON employees.emp_no = salaries.emp_no; AS 구문을 이용해서 테이블 이름에도 별칭을 붙일 수 있습니다. 1234SELECT first_name, salary, from_date, emp.emp_noFROM salaries AS salJOIN employees AS emp ON emp.emp_no = sal.emp_no;INNER JOIN &amp; OUTER JOIN 위의 예제에서 ‘사원 테이블’과 ‘연봉 변동 내역 테이블’은 우리의 의도대로 잘 합쳐졌습니다. 그런데 조인의 기준을 충족시키지 못하는 레코드들, 다시 말해서 일치하는 emp_no가 없거나, 어느 한 쪽의 emp_no 컬럼에 NULL이 저장되어 있는 경우는 어떻게 될까요? 위에서 사용한 SQL 명령을 그대로 쓰면, 조인의 기준을 충족시키지 못하는 레코드들은 아예 출력 결과에 포함이 되지 않습니다. 이와 같은 조인 방식을 INNER JOIN이라고 합니다. 사실 위 SQL 명령은 다음과 완전히 같은 의미입니다. 1234SELECT first_name, salary, from_date, emp.emp_noFROM salaries AS salINNER JOIN employees AS emp ON emp.emp_no = sal.emp_no;-- `INNER JOIN`과 `JOIN`은 같은 의미입니다. 그런데 가끔, 조인의 기준을 충족시키지 못하는 레코드들도 결과에 포함시켜야 하는 경우가 있습니다. 이러한 조인 방식을 OUTER JOIN이라고 합니다. 이 문서에서는 OUTER JOIN을 다루지 않으나, 가끔 필요한 경우가 있으니 아래의 문서를 참고해주세요. LEFT OUTER JOINRIGHT OUTER JOINFULL OUTER JOIN 세 개 이상의 테이블 조인하기아래와 같이 JOIN 구문을 여러 번 써서, 세 개 이상의 테이블을 합치는 것도 가능합니다. 123456-- departments 테이블에는 부서 번호와 부서 이름이 저장되어 있습니다.-- dept_emp 테이블에는 사원의 전보 내역이 기록되어 있습니다.SELECT employees.first_name, dept_emp.from_date, departments.dept_nameFROM employeesJOIN dept_emp ON employees.emp_no = dept_emp.emp_noJOIN departments ON departments.dept_no = dept_emp.dept_no; SQL에는 쿼리 안에 쿼리를 중첩시켜서 중첩된 쿼리의 결과를 바깥쪽 쿼리에서 활용할 수 있는 기능이 있는데, 이렇게 내부에 중첩된 쿼리를 서브쿼리라고 부릅니다. 단일 행 서브쿼리단일 행 서브쿼리는 하나의 행을 반환하는 서브쿼리입니다. 단일 행 서브쿼리는 바깥쪽 쿼리의 WHERE 구문에서 비교를 위해 사용될 수 있습니다. 아래는 ‘1997년도 이전에 최고 연봉을 받은 사람의 이름’을 구하기 위한 쿼리입니다.1234567891011121314151617SELECT emp_no, first_name FROM employeesWHERE emp_no = ( SELECT emp_no FROM salaries WHERE YEAR(from_date) &lt;= '1997' ORDER BY salary DESC LIMIT 1);``` 아래와 같이 `튜플`을 사용해서 여러 컬럼을 동시에 비교할 수도 있습니다. ```sql-- 튜플을 사용하는 서브쿼리의 예를 보여드리기 위한 쿼리이며, 별 의미는 없습니다.SELECT emp_no, first_name FROM employeesWHERE (emp_no, first_name) = ( SELECT emp_no, first_name FROM employees LIMIT 1); 다중 행 서브쿼리다중 행 서브쿼리는 여러 개의 행을 반환하는 서브쿼리입니다. 다중 행 서브쿼리는 바깥쪽 쿼리의 WHERE 구문에서 IN 연산자와 함께 사용됩니다. 아래는 최고 연봉 15만 달러를 달성한 적이 있는 사람들의 이름을 가져오기 위한 쿼리입니다. 12345SELECT first_name FROM employeesWHERE emp_no IN ( SELECT emp_no FROM salaries WHERE salary &gt;= 150000); 서브쿼리와 조인서브쿼리로 짠 쿼리를 조인을 이용해서 짤 수 있는 경우도 있습니다. 위의 첫 번째 예제를 조인을 이용해 다시 작성하면 다음과 같이 됩니다. 123456-- '1997년도 이전에 최고 연봉을 받은 사람의 이름'을 구하기 위한 쿼리SELECT first_name FROM employeesJOIN salaries ON salaries.emp_no = employees.emp_noWHERE YEAR(salaries.from_date) &lt;= '1997'ORDER BY salary DESCLIMIT 1; 다만 모든 서브쿼리를 조인으로 대체할 수 있는 것은 아닙니다. 다음과 같이 서브쿼리를 써야만 가능한 쿼리도 있습니다. 123456789-- '1997년도 이전의 최고 연봉보다 더 많은 연봉을 받은 사람들의 이름'을 구하기 위한 쿼리SELECT DISTINCT first_name FROM employeesJOIN salaries ON salaries.emp_no = employees.emp_noWHERE salary &gt; ( SELECT salary FROM salaries WHERE YEAR(salaries.from_date) &lt;= '1997' ORDER BY salary DESC LIMIT 1); 같은 작업을 하는 쿼리를 조인으로 짤 수도 있고, 서브쿼리로도 짤 수 있다면 둘 중에 어떤 것을 써야 할까요? IN 연산자에 들어가는 서브쿼리의 결과가 크면 연산 속도가 조인에 비해 느려집니다. 123456-- 0.0021 secSELECT first_name FROM employeesWHERE emp_no IN ( SELECT emp_no FROM salaries)LIMIT 1000; 1234-- 0.00075 secSELECT first_name FROM employeesJOIN salaries ON salaries.emp_no = employees.emp_noLIMIT 1000; 대개의 경우, IN 연산자에 들어가는 서브쿼리의 길이가 굉장히 긴 (수십 만 행 이상) 경우에는 조인을, 짧은 경우에는 서브쿼리를 사용하는 것이 빠릅니다. 이것을 외우기 귀찮다면, 조인을 쓸 수 있는 상황에서는 조인을 쓰고, 아니라면 서브쿼리를 쓴다고 외워 두어도 무방합니다. 인덱스 생성하기CREATE INDEX구문을 사용해서 인덱스를 생성할 수 있습니다. 1CREATE INDEX ix_from_date ON salaries(from_date); 다중 컬럼 인덱스를 생성할 수도 있습니다.1CREATE INDEX ix_from_date_to_date ON salaries(from_date, to_date); 인덱스 확인하기앞에서 생성된 인덱스를 SHOW INDEX 구문으로 확인할 수 있습니다. 1SHOW INDEX FROM salaries; Primary Key, Foreign Key기본 키와 외래 키에 대해서는 자동으로 인덱스가 생성되기 때문에, 별도의 인덱스를 만들어줄 필요가 없습니다. Unique 인덱스특정 컬럼(혹은 다중 컬럼)의 값을 유일하게 만드는 제약 조건을 걸고 싶을 때 UNIQUE INDEX를 사용합니다. 1CREATE UNIQUE INDEX ix_uniq_column ON table_name(col_name); 인덱스 제거하기DROP INDEX 구문을 이용해 인덱스를 제거할 수 있습니다. 1DROP INDEX index_name ON table_name; 인덱스의 설계인덱스는 테이블과는 별도로 저장됩니다. 즉, 인덱스도 디스크의 용량을 차지합니다. 또한 미리 정렬을 시켜둬야 하는 인덱스의 성질때문에, 인덱스를 생성한 뒤에는 데이터의 추가나 수정이 느려집니다. 다시 말해서, 인덱스는 읽기 효율을 높이는 대신 쓰기 효율을 희생시킵니다. 테이블에 쓰기가 극단적으로 많이 일어나는 경우에는 인덱스 사용을 재고해보는 것이 좋습니다. 그렇지 않은 경우라면, WHERE 혹은 ORDER BY 구문에서 자주 사용되는 컬럼에 대해서는 인덱스를 걸어두는 것이 좋습니다. 또한 AND 연산으로 엮여서 자주 검색되는 컬럼들에 대해서는 다중 컬럼 인덱스를 생성하는 것이 좋습니다. 실행 계획작성한 쿼리가 인덱스를 잘 활용하고 있는지 확인하려면 EXPLAIN 구문을 사용해서 실행 계획을 확인할 수 있습니다. employees 데이터베이스에 대해 여러 쿼리를 작성해 보고, 해당 쿼리의 실행계획을 확인해보세요. 트랜잭션의 필요성데이터베이스에서는 여러 쿼리에 걸쳐서 데이터를 안전하게 다루기 위해 트랜잭션이라는 기능을 사용합니다. 트랜잭션의 필요성을 말씀드리기 위해 간단히 예를 들어보겠습니다. 한 은행에서 계좌 정보를 관리하기 위해 데이터베이스를 사용하고 있습니다. 한 계좌에서 다른 계좌로 1000원을 옮기기 위해서는, 아래와 같이 데이터베이스에 두 개의 쿼리를 날려야 합니다. 1234-- 첫 번째 쿼리는 'from_account' 계좌에서 1000원을 인출합니다.UPDATE accountSET balance = balance - 1000WHERE account_id = 'from_account'; 1234-- 두 번째 쿼리는 'to_account' 계좌에 1000원을 입금합니다.UPDATE accountSET balance = balance + 1000WHERE account_id = 'to_account' 두 쿼리가 모두 성공적으로 수행된다면, 우리가 처음에 의도했던 작업이 잘 완료됐다고 볼 수 있습니다. 하지만 계좌에 잔액이 부족하거나, 네트워크 오류 혹은 정전 등의 이유로 하나의 쿼리만 실행되고 나머지 하나는 실행이 되지 않는 상황이 발생할 수 있습니다. 즉, 인출은 됐는데 입금이 되지 않은 (혹은 그 반대의) 결과가 나옵니다. 언제 생길 지 알 수 없는 오류 때문에 데이터를 신뢰할 수 없다면, 은행과 같은 기업의 입장에서는 데이터베이스를 사용할 수 없을 것입니다. 이렇게 데이터베이스를 다루다 보면 “여러 쿼리에 걸친 데이터 조작의 신뢰성”을 확보할 필요성이 있습니다. 이를 위해 트랜잭션이라는 기능을 사용합니다. 트랜잭션을 사용하면, 여러 개의 쿼리 중 하나라도 실패했을 때 데이터베이스의 상태를 원상복귀 시킬 수 있습니다. 트랜잭션의 사용START TRANSACTION 구문을 사용하면 현재 커넥션에 대해 트랜잭션이 시작됩니다. 1START TRANSACTION; 트랜잭션을 시작한 다음에는 평소처럼 쿼리를 실행할 수 있습니다. 12INSERT INTO employees (emp_no, birth_date, first_name, last_name, gender, hire_date)VALUES (876543, '1980-03-05', 'Georgi', 'Jackson', 'M', '2017-09-11'); 여러 번의 쿼리를 통해 필요한 작업을 완료한 뒤에는, COMMIT 구문으로 현재까지의 변경사항을 데이터베이스에 반영해주어야 합니다.1COMMIT; 만약, 쿼리를 하는 도중에 이제까지 트랜잭션 안에서 했던 모든 작업을 취소하고 싶은 경우에는 ROLLBACK 구문을 사용하면 됩니다.1ROLLBACK; 트랜잭션의 격리커밋하기 전에는 트랜잭션 내에서 변경된 사항을 다른 커넥션에서 볼 수 없습니다. (단, READ COMMITTED 이상의 격리 수준인 경우에 한정) 이런 성질을 트랜잭션의 격리(isolation) 라고 부릅니다. MySQL은 다양한 격리 수준(isolation level)을 지원합니다. 자세한 사항은 공식문서 및 이 글을 참고해주세요. 123-- 위의 INSERT 쿼리를 실행하고 COMMIT을 하지 않은 경우에, 아무 결과도 안 뜹니다.SELECT * FROM emplyeesWHERE emp_no = 876543; ACID의 성격에 대해서 알아둬야한다. 데이터 모델링데이터 모델링은 현실 세계의 개념을 데이터베이스의 세계에서 다룰 수 있도록 재해석하는 작업을 말합니다. 데이터 모델링을 하기 위해서는 먼저 모델링의 대상이 되는 현실 세계를 잘 이해할 필요가 있습니다. 이를 위해 데이터 요구사항을 정리하고, 관계자와 인터뷰를 하는 등의 활동을 통해 현실 세계에서의 작업이 어떤 절차를 통해 이루어지는지를 자세히 파악해야 합니다. 이 문서에서는 널리 사용되는 모델링 방법인 개체-관계 모델을 다룰 것입니다. 개체-관계 모델을 통해 모델링을 할 때에는, 위에서 파악한 절차로부터 아래의 요소들을 이끌어 내게 됩니다. 개체 (entity) : 절차에 관여하는 어떤 것(thing). 식별 가능한 사람, 장소, 사물, 사건 등속성 (attribute) : 개체가 가지는 성질관계 (relationship) : 개체 간에 가지는 관계데이터베이스에는 각각 아래와 같은 형태로 저장될 수 있습니다. 개체 - 테이블속성 - 개체를 나타내는 테이블의 컬럼관계 - 외래 키, 혹은 관계 테이블 관계의 차수(Cardinality)두 개체 간 관계에서 각 개체의 참여자 수를 차수(cardinality)라고 부릅니다. 차수는 일반적으로 1:1, 1:N, M:N의 세 가지 형태로 분류합니다. 1:1 관계데이터베이스에서는 1:1 관계에 있는 두 엔티티를 하나의 테이블에 저장하거나, 두 엔티티를 각각 다른 테이블에 저장하고 한 테이블의 기본 키를 다른 테이블에 대한 외래 키로 지정하는 등의 방법을 사용해서 1:1 관계를 표현합니다. 1:N 관계데이터베이스에서는 1:N 관계에 있는 두 엔티티를 각각 다른 테이블에 저장하고, N 측의 테이블에 다른 테이블에 대한 외래 키를 둬서 1:N 관계를 표현합니다. M:N 관계데이터베이스에서는 외래 키 하나만 가지고는 M:N 관계를 표현할 수 없으므로, 별도의 관계 테이블을 두고 관계 테이블에 두 개의 외래 키를 두는 방법으로 M:N 관계를 표현합니다. 정규화 (Normalization)정규화란 데이터의 중복을 최소화할 수 있도록 데이터를 구조화하는 작업을 말합니다. 일반적으로, 정규화가 잘 된 데이터베이스는 작고 잘 조직된 여러 개의 테이블로 나누어집니다. 예를 들어서, 어떤 학원의 성적 관리 데이터베이스에서는 성적 데이터를 아래와 같이 저장할 수 있을 것입니다. 정규화를 거치고 나서 테이블이 나뉘어져서 조금 더 복잡해졌지만, 중복되는 데이터가 없어져서 데이터를 관리하기도 쉬워지고 또 데이터가 차지하는 용량도 줄어들었습니다. 보통 데이터 모델링을 할 때에는 정규화 과정을 통해 중복을 없애주는 것이 좋습니다. 다만 성능상의 이유로 일부러 데이터를 중복시켜 저장하는 경우도 있는데, 이를 반정규화라고 합니다. Entity Relationship DiagramERD(Entity Relationship Diagram)은 개체, 속성, 관계를 도표로 나타내는 방법으로, 데이터 모델링의 결과를 시각화하기 위해 널리 사용됩니다. MySQL Workbench을 통해 ERD를 그려볼 수 있습니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Database","slug":"Node-js/Database","permalink":"http://yoursite.com/categories/Node-js/Database/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Database","slug":"Database","permalink":"http://yoursite.com/tags/Database/"}]},{"title":"Node-GraphQL","slug":"node-study-http-cache","date":"2017-09-06T03:54:00.000Z","updated":"2017-09-21T02:17:13.000Z","comments":true,"path":"2017/09/06/node-study-http-cache/","link":"","permalink":"http://yoursite.com/2017/09/06/node-study-http-cache/","excerpt":"","text":"HTTP CacheCache컴퓨터 분야에서의 캐시는(주로 접근 속도의 개선을 위해) 데이터를 미리 복사해 놓는 임시 저장소, 혹은 그 임시 저장소에 데이터를 저장하는 행위를 가리킴 cache 혹은 caching이라는 용어 자체는 특정 기술을 가리키는 것이 아니라,접근 속도를 개선하기 위해 따로 저장소를 두는 ‘방법’을 가리킴 컴퓨터의 아주 많은 부분(CPU, GPU, HDD, 네트워크, 웹, 데이터베이스…)에서 사용되고 있음 HTTP Cache 자원의 효율적 로딩을 위한 웹 표준 서버에서 가져온 자원(HTML, CSS, JS, 이미지, …)을 가까운 곳(브라우저, 혹은 다른 서버)에 저장해놓고 재사용 캐시를 할 것인지 말 것인지, 어떻게 할 것인지를 결정하는 규칙이 복잡하고, 브라우저마다 조금씩 다름 Common Problem캐시된 자원과 실제 자원의 내용이 달라지는 문제를 어떻게 해결할 것인가? SolutionExpiration(만료) 정해진 시간이 지나면 캐시가 자동으로 삭제되도록 설정 Validation(검증) 서버에 요청을 보내서 캐시를 계속 사용할 수 있는지 확인 Cache 관련 헤더Cache 범주Conditionals 범주 Cache-Control (요청, 응답) 캐시와 관련된 다양한 기능을 하는 지시자를 포함. no-cache, max-age가 많이 사용됨. no-cache, max-age=0 지시자는 캐시를 사용하지 않도록 하거나, 캐시를 아직도 쓸 수 있는지 검증하기 위해 사용됨 각각의 자세한 의미 ETag (응답) 캐시의 검증을 위해 사용되는 자원의 식별자. 주로 자원의 해시값이 사용되나, 마지막으로 수정된 시각, 혹은 버전 넘버를 사용하기도 함 Expires (응답) 캐시를 만료시킬 시각을 서버에서 명시적으로 지정 Last-Modified (응답) 원래 자료가 마지막으로 수정된 시각 If-None-Match (요청) 검증을 위해 사용됨. 이전에 저장해두었던 자원의 ETag 값을 If-None-Match 헤더의 값으로 요청에 포함시켜서 보내면, 서버는 해당 경로에 있는 자원의 ETag와 비교해보고 자원의 전송 여부를 결정 If-Modified-Since (요청) 검증을 위해 사용됨. 이전에 저장해두었던 자원의 Last-Modified 값을 If-Modified-Since 헤더의 값으로 요청에 포함시켜서 보내면, 서버는 해당 경로에 있는 자원의 Last-Modified와 비교해보고 자원의 전송 여부를 결정 브라우저 실습Link Response의 etag와 Request의 if-none-match가 일치하면 브라우저와 서버가 자원의 변경이 없다는 것을 알 수 있다 그러면 HTML파일을 다시보낼 필요가 없으니 304응답이 되는 것이다 (304통신이란? 통신이 되어서 헤더는 이동해도 HTML은 이동하지 않는다) 이것을 검증작업이라고 한다. cache를 사용하지 않을 경우 Disable cache를 사용한다. cache를 새로고침하려면 command+shift+r을 누르면 된다. Cacheable MethodsPOST 메소드는 Cacheable 범주에 포함되기는 하지만, 특별한 조건을 만족시켜야 하며 실무에서는 POST cache가 거의 사용되지 않습니다. Get, Head만 cache가 가능하다. 캐시의 사용 브라우저는 이미 캐시를 잘 활용하도록 만들어져 있습니다. Express는 이미 캐시를 잘 활용하도록 만들어져 있습니다. 일단은 별다른 추가작업 없이도 편하게 캐시 기능을 사용할 수 있지만, 우리가 원하는대로 캐시가 동작하지 않을 때 그 원인을 파악하기 위해 캐시 관련 헤더는 숙지해두는 것이 좋습니다. 그리고 HTTP method를 용도에 맞게 사용하는 것도 중요합니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"http-cache","slug":"Node-js/http-cache","permalink":"http://yoursite.com/categories/Node-js/http-cache/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"cache","slug":"cache","permalink":"http://yoursite.com/tags/cache/"}]},{"title":"Node-SPA(Single Page Application)","slug":"node-study-spa","date":"2017-09-06T03:54:00.000Z","updated":"2017-09-21T02:18:50.000Z","comments":true,"path":"2017/09/06/node-study-spa/","link":"","permalink":"http://yoursite.com/2017/09/06/node-study-spa/","excerpt":"","text":"Node Single-page ApplicationSPA의 구조 ejs를 사용하여서 웹개발을 하게되면 전체를 다시 새로고침을 해야한다. SPA 구조를 사용하면 Ajax를 통하여 부분만 고쳐준다. SPA 실습Link data 부분을 node.js module로 빼뒀다. npm으로 설치한 module은 경로지정이 없어도 불러와 지지만 직접만든 module은 경로를 입력해줘야한다. send, end를 통해서 SPA를 구현한다. (redirect, render가 필요없다) 비관적 업데이트(pessimistic) event 발생시 ajax 요청을 보낼때 실패 or 성공을 모른다 ajax응답을 기다리다가 응답이 온뒤에 화면을 갱신 낙관적 업데이트(optimistic) ajax 요청과 화면 갱신을 같은 단계에 한다 그리고 미리 화면을 갱신하는데 이것은 ajax요청이 성공하면 끝난다. ajax요청이 실패하면 취소 or 에러처리 요즘 자주 사용한다. 개선 예시 title 수정 기능 ‘기한’ 디자인 개선 로그인 cookie session사용. 데이터 유지","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"SPA","slug":"Node-js/SPA","permalink":"http://yoursite.com/categories/Node-js/SPA/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"SPA","slug":"SPA","permalink":"http://yoursite.com/tags/SPA/"}]},{"title":"Node-GraphQL","slug":"node-study-graphql","date":"2017-09-06T03:54:00.000Z","updated":"2017-09-21T02:17:10.000Z","comments":true,"path":"2017/09/06/node-study-graphql/","link":"","permalink":"http://yoursite.com/2017/09/06/node-study-graphql/","excerpt":"","text":"Node GraphQLREST API의 단점 각각의 자원마다 경로가 따로 있음. 즉, 여러 자원이 동시에 필요한 경우에는 요청을 여러 번 보내야 함 (요청의 횟수 면에서 비효율적) (보통의 경우) 자원의 필요한 속성만 얻어올 수 없음. 즉, 일부 속성의 필요하더라도 전체 속성을 가져와야만 함 (요청의 용량 면에서 비효율적) GraphQL Facebook에서 2015년 공개한 데이터 질의 언어 REST API를 대체하기 위해 만들어짐 클라이언트에서 필요한 데이터의 구조를 GraphQL 언어로 정의한 후 질의할 수 있고, 서버는 그에 맞게 구조화된 데이터를 응답 서버에서는 GraphQL 질의를 해석하기 위해 별도의 해석기가 필요하며, 여러 언어의 구현체가 나와있는 상태 Example1234567// request&#123; human(id:\"1000\")&#123; name height &#125;&#125; 123456789//response&#123; \"data\": &#123; \"human\":&#123; \"name\": \"Luke Skywalker\", \"height\":1.72 &#125; &#125;&#125; 내가 원하는 자료만 받아 올 수 있다. Github Graph API 실습Link 참고 링크 https://dev-blog.apollodata.com/graphql-vs-rest-5d425123e34b http://graphql.org/learn/","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"GraphQL","slug":"Node-js/GraphQL","permalink":"http://yoursite.com/categories/Node-js/GraphQL/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"GraphQL","slug":"GraphQL","permalink":"http://yoursite.com/tags/GraphQL/"}]},{"title":"Node-CORS","slug":"node-study-cors","date":"2017-09-05T03:54:00.000Z","updated":"2017-09-21T02:17:02.000Z","comments":true,"path":"2017/09/05/node-study-cors/","link":"","permalink":"http://yoursite.com/2017/09/05/node-study-cors/","excerpt":"","text":"Node CORS보내는쪽과 받는쪽의 Domain이 다를때 발생하는 문제 Some-origin Plicy(동일 출처 정책) 웹페이지에서 리소스를 불러올 때, 리소스의 출처가 웹페이지의 출처와 같으면 안전하다고 보고, 출처가 다르면 해당 리소스는 안전하지 않다고 보는 원칙 여기서 &#39;출처&#39;란 &#39;프로토콜 + 도메인 + 포트번호&#39;의 결합을 가리킴. 즉, 세 개가 다 같아야 동일 출처라고 할 수 있고, 셋 중에 하나라도 다르면 동일 출처로 간주되지 않음 웹 보안의 기본 원칙으로, 웹 브라우저의 많은 요소에 적용됨 Same-origin Policy 실습12345678910111213&gt; const child = window.open('http://www.fastcampus.co.kr')// 새로 열린 웹 페이지의 콘솔에서&gt; window.foo = 'bar'// 이전 웹 페이지의 콘솔에서&gt; child.foo// 출처가 같다면 접근 가능, 아니면 불가// fastcampus 홈페이지에서 naver를 오픈한다.&gt; const naver = window.open('https://naver.com') // naver가 실행되는데 naver의 콘솔에서 만든 foo는 적용이 안된다.&gt; foo = 'bar'// fastcampus쪽에서 naver.foo를 하면 에러가난다.&gt; naver.foo // error 이러한 에러를 same-origin policy 이라고 한다. Content-Security-PolicyContent-Security-Policy 헤더를 이용하면, 동일하지 않은 출처에 대한 리소스를 불러올지 말지 결정할 수 있음 CORSCross-Origin Resource Sharing 클라이언트 측 cross-origin 요청을 안전하게 보낼 수 있는 방법을 정한 표준 쉽게 말하면, 스크립트가 전혀 다른 출처를 갖는 API 서버를 사용하려고 하는 상황에서는 뭔가 추가적인 처리를 해주어야 한다는 것! 도메인이 다를때 서로 통신하는 방법 Cross-origin 요청의 위험성아래 상황을 가정해봅시다. mywebsite.com에서 서비스 중인 웹 사이트는 mywebsite.com/api 에서 REST API를 통해 필요한 정보를 얻습니다. mywebsite.com/api 경로에 대한 인증은 쿠키로 이루어지고 있습니다. 그런데 만약 evil.com 웹 사이트의 스크립트에서 mywebsite.com API에 요청을 마음대로 보낼 수 있다면, 이미 my-website.com 도메인에 대해 브라우저에 저장된 쿠키를 이용해서 API를 마음대로 호출할 수 있을 것입니다. 쿠키는 요청을 하기만하면 자동으로 보내진다. Cross-origin 요청 예제 IE8 이상의 모던 웹 브라우저는 cross-origin 요청에 대해 여러가지 제한을 두고 있음 cross-origin 요청을 허용하려면, 서버가 특별한 형태의 응답을 전송해야 함 만약 서버가 cross-origin 요청을 허용하지 않으면, 웹 브라우저는 에러를 발생시킴 어느 웹페이지는 허락하고 거절할지에 대해서 서버단에서 설정할 수 있다.Link 참고express를 비롯한 일반적인 웹 서버는 별도의 설정을 하지 않으면 cross-origin 요청을 모두 불허(즉 웹브라우저가 거부)하도록 만들어져 있습니다. 그런데 json-server는 개발자의 편의를 위해 쿠키가 포함되어있지 않은 모든 cross-origin 요청을 허용하도록 만들어져 있습니다. 본 예제의 원활한 진행을 위해, json-server가 일반적인 웹 서버와 같이 cross-origin 요청을 허용하지 않도록 설정한 부분이 wpsn-axios-example의 코드를 보시면 나와있습니다. get은 그냥 보내는데 나머지는 options로 보낸다. CORS에 관여하는 응답 헤더 Access-Control-Allow-Origin 서버를 허용해 줄 때 Access-Control-Expose-Headers Access-Control-Max-Age Access-Control-Allow-Credentials 쿠키를 추가하는 명령도 받는다. Access-Control-Allow-Methods 특정 Method만 받는다. Access-Control-Allow-Headers 특정 Header만 받는다. CORS에 관여하는 요청 헤더 Origin Access-Control-Request-Method (preflighted 전용) Access-Control-Request-Headers (preflighted 전용) CORS - Safe, Unsafe GET, HEAD 요청은 safe(읽기 전용)이기 때문에 서버에 요청이 도달한다고 해서 서버의 상태에 영향을 미칠 일은 없으므로, 웹 브라우저는 일단 해당 요청을 보내본다. 만약 서버가 cross-origin 요청을 허용한다고 응답하면 응답을 그대로 사용하고, 그렇지 않으면 에러를 낸다. POST, PUT, PATCH, DELETE 등의 메소드는 요청이 서버에 전송되는 것 자체가 위험하므로, 실제 요청을 보내기 전에 서버가 cross-origin 요청을 허용하는지를 알아보기 위해 시험적으로 요청을 한 번 보내본다.(options) 이 요청을 preflighted request라고 한다. (단, 기존 HTML form의 동작방식인 application/x-www-form-urlencoded 혹은multipart/form-data 형태의 POST 요청은 preflighted request가 발생하지 않음) safe, unsafe 말고도 다른 원인에 의해 preflighted request가 발생하는 경우가 있는데, 자세한 사항은 MDN 문서를 참고해주세요. CORS with credentialscross-origin 요청에는 기본적으로 쿠키가 포함되지 않으나, XMLHttpRequest 혹은 fetch를 통해서 요청을 보낼 때 쿠키를 포함시키는 옵션을 줄 수 있고 이 때 CORS 요건이 더 엄격해짐 (Access-Control-Allow-Credentials 헤더 설정 필요, Access-Control-Allow-Origin 헤더에 와일드카드 허용 안됨) cross-origin Ajax 요청에는 기본적으로 쿠키가 포함되지 않으나 옵션을 줘서 쿠키를 포함시켜서 보낼 수 있지만 보안 정책이 더욱 엄격해진다. 복잡하면 그냥… 프론트엔드와 API 서버를 같은 도메인으로 제공한다. 불가피하게 둘을 다른 도메인으로 제공해야 한다면 CORS를 허용한다 (cors 미들웨어를 사용하면 간단함) CORS를 허용했으므로 쿠키를 쓰지 않는다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"CORS","slug":"Node-js/CORS","permalink":"http://yoursite.com/categories/Node-js/CORS/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"CORS","slug":"CORS","permalink":"http://yoursite.com/tags/CORS/"}]},{"title":"Node-jwt","slug":"node-study-jwt","date":"2017-09-05T03:54:00.000Z","updated":"2017-10-04T11:41:45.000Z","comments":true,"path":"2017/09/05/node-study-jwt/","link":"","permalink":"http://yoursite.com/2017/09/05/node-study-jwt/","excerpt":"","text":"Node JWT쿠키의 단점 쿠키를 지원하는 클라이언트에서 밖에 사용할 수 없음 적절히 관리되지 않은 쿠키는 보안에 취약하며, 관리를 하려고 해도 CORS 대응이 복잡함 Token Based Auth 토큰이란, 사용자의 자격증명(아이디, 패스워드 등)을 통해 인증이 이루어진 후, 특정 자원에 대한 자격증명으로서 대신 사용되는 인증 수단 서버에 요청을 할 때마다 토큰을 요청에 직접 포함시켜서 전송 (주로 Authorization 헤더에 넣어서 전송) Cookie vs Token token을 사용할때는 프론트와 백엔드가 다른 url을 사용할때 자주 사용된다. client side의 js가 token 정보를 기억한다. 토큰 사용의 장점 다양한 인증 수단(전화번호, 공인인증서, 생체정보 등)의 인증 결과를 토큰이라는 하나의 수단으로 통일할 수 있음 쿠키를 사용하지 않음으로써 CORS 관련 문제를 회피할 수 있음 토큰 사용의 단점 매 요청에 토큰이 포함되게 되므로 적당히 짧은 길이를 유지해야 함 토큰 유출에 대한 대비책이 필요 (토큰에 유효기간을 두거나, 유출된 토큰을 강제로 무효화하는 등의 방법을 사용) 쿠키와는 다르게, 클라이언트에서 직접 토큰을 저장하고 관리해야 함 Web Storage 브라우저에서 키-값 쌍을 저장할 수 있는 저장소 쿠키에 비해 사용하기 편리하고 저장 가능한 용량도 큼(10MB 가량) 브라우저 탭이 닫히면 내용이 삭제되는 sessionStorage, 브라우저 탭이 닫혀도 내용이 유지되는 localStorage가 있음 localStorage.setItem(‘foo’, ‘bar’) // key value 저장가능 보안 상 주의사항 토큰을 localStorage에 저장하게 되면 자바스크립트로 토큰을 탈취할 수 있게 되므로, 웹사이트에 악성 스크립트를 삽입하는 공격(XSS)에 노출되지 않도록 신경써야 함 직접 DOM API를 사용하는 대신 EJS, React 같은 템플릿 언어를 사용하기만 해도 XSS에 대한 방어는 충분함 token 기반으로 사용할 때는 서명을 해주면 보안성을 높힐수있다. 암호화는 성능을 많이 낭비하게된다. JSON Web Token 최근 널리 사용되고 있는 토큰 형식의 표준 토큰 안에 JSON 형식으로 정보를 저장함 보안을 위해 서명 또는 암호화를 사용할 수 있음jwt.io JWT 실습Link server.js를 다이해해두는 것이 좋다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101const express = require('express')const bodyParser = require('body-parser')/** * JWT의 사용을 위해 두 패키지가 필요합니다. * jsonwebtoken: JWT의 생성과 검증을 위한 범용 패키지입니다. 여기에서는 JWT 생성을 위해 사용하고 있습니다. * express-jwt: JWT가 요청에 포함되어 서버에 들어왔을 때, 해당 토큰을 검증 및 변환해서 `req.user`에 저장해주는 express 미들웨어입니다. */ // token만들때 사용하는 비밀키 SECRET을 넣어줘야한다.const jwt = require('jsonwebtoken')const expressJwt = require('express-jwt')// 토큰의 서명을 위해 필요한 비밀 키를 저장해둡니다.const SECRET = 'mysecret'const app = express()const jsonMiddleware = bodyParser.json()app.use(express.static('public'))/** * 인증 미들웨어 생성 * * `expressJwt()`로 생성된 미들웨어의 기능은 다음과 같습니다. * * 1. `Authorization: Bearer &lt;token&gt;` 형태로 jwt가 들어왔는지 검사하고 * 2. 토큰이 없으면 401 Unauthorized 응답을 보낸다. * 3. 토큰이 있으면 토큰에 들어있는 JSON 정보를 객체로 변환한 후 `req.user`에 저장한다. * * 미들웨어 생성 시에 서명에 필요한 secret을 전달해 줍니다. */const authMiddleware = expressJwt(&#123;secret: SECRET&#125;)const users = [ &#123; username: 'fast', password: 'campus', isAdmin: true &#125;, &#123; username: 'foo', password: 'bar' &#125;]/** * `/auth` 경로로 들어온 사용자 이름과 비밀번호를 users 배열과 대조한 후 * 일치하는 계정이 있다면 해당 계정 정보를 가지고 JWT 토큰을 만들어서 응답한다. */app.post('/auth', jsonMiddleware, (req, res) =&gt; &#123; const &#123;username, password&#125; = req.body const matched = users.find(user =&gt; user.username === username &amp;&amp; user.password === password) if (matched) &#123; // `jwt.sign` 메소드는 새로운 JWT 토큰을 생성한다. // 토큰에 넣을 객체와 서명에 필요한 secret을 전달한다. const token = jwt.sign(&#123;username, isAdmin: matched.isAdmin&#125;, SECRET) res.send(&#123; ok: true, token &#125;) &#125; else &#123; // 일치하는 계정이 없으면 400 응답 res.status(400) res.send(&#123; ok: false, error: 'No matched user' &#125;) &#125;&#125;)/** * 토큰에 들어있는 정보를 그대로 반환하는 라우트 핸들러 */app.get('/auth', authMiddleware, (req, res) =&gt; &#123; res.send(req.user)&#125;)/** * JWT로 인증이 된 요청만 API를 사용할 수 있게 해준다. */app.get('/some-api', authMiddleware, (req, res) =&gt; &#123; res.send(&#123; ok: true, message: 'Hello JWT!' &#125;)&#125;)let count = 0app.post('/count', authMiddleware, (req, res) =&gt; &#123; count += 1 res.send(&#123; ok: true, count &#125;)&#125;)app.listen(3000, () =&gt; &#123; console.log('listening...')&#125;) const token = jwt.sign({username, isAdmin: matched.isAdmin}, SECRET) 서명을 할때 SECRET이라는 비밀키를 생성한다 Axios는 get, header, delete 같은 읽기전용은 인자를 2개만 받는데 post, fetch, 이런값들은 인자를 3개를 받는다. 2번째 인자로 받을 데이터를 넣는다. 123456789101112131415161718192021222324252627282930313233// 토큰 받아오기let token;axios.post('/auth', &#123; username: 'fast', password: 'campus'&#125;).then(res =&gt; &#123; token = res.data.token console.log(`token: $&#123;token&#125;`)&#125;)// 토큰으로 요청하기 1axios.get('/auth', &#123; headers: &#123; 'Authorization': `Bearer $&#123;token&#125;` &#125;&#125;).then(res =&gt; &#123; prettyPrint(res.data)&#125;)// 토큰으로 요청하기 2axios.get('/some-api', &#123; headers: &#123; 'Authorization': `Bearer $&#123;token&#125;` &#125;&#125;).then(res =&gt; &#123; prettyPrint(res.data)&#125;)// 토큰으로 요청하기 3axios.post('/count', null, &#123; headers: &#123; 'Authorization': `Bearer $&#123;token&#125;` &#125;&#125;).then(res =&gt; &#123; prettyPrint(res.data)&#125;) 중복되는 값을 제거하기 위한 방법으로는 Axios instance를 만들면 된다. 123456789101112131415// Axios.createconst authedAxios = axios.create(&#123; headers: &#123; 'Authorization': `Bearer $&#123;token&#125;` &#125;&#125;)authedAxios.get('/auth').then(res =&gt; &#123; prettyPrint(res.data)&#125;)authedAxios.get('/some-api').then(res =&gt; &#123; prettyPrint(res.data)&#125;)authedAxios.post('/count').then(res =&gt; &#123; prettyPrint(res.data)&#125;) 참고링크 https://jwt.io/introduction/ https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage https://blog.outsider.ne.kr/1160 https://velopert.com/2448 https://auth0.com/blog/json-web-token-signing-algorithms-overview/","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"JWT","slug":"Node-js/JWT","permalink":"http://yoursite.com/categories/Node-js/JWT/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"JWT","slug":"JWT","permalink":"http://yoursite.com/tags/JWT/"}]},{"title":"Node-Ajax","slug":"node-study-ajax","date":"2017-09-05T03:54:00.000Z","updated":"2017-10-04T11:40:44.000Z","comments":true,"path":"2017/09/05/node-study-ajax/","link":"","permalink":"http://yoursite.com/2017/09/05/node-study-ajax/","excerpt":"","text":"Node AjaxAjax비동기적인 웹 어플리케이션의 제작을 위한 클라리언트 측 웹 개발 기법요즈음은 의미가 변형되어 웹 브라우저에서 XMLHttpRequest 혹은 fetch를 이용해서 보내는 HTTP 요청을 통칭하기도 함 Ajax Model Ajax의 장점 화면 전체를 다시 로드하지 않고도 내용을 갱신할 수 있어 더 나은 사용자 경험 제공 서버의 응답을 기다리는 동안에도 여전히 웹 어플리케이션을 사용 가능 필요한 자원만 서버에서 받아오게 되므로 트래픽이 줄어듬 Ajax의 단점 클라이언트 구현이 굉장히 복잡해짐 Ajax Library ComparisonAxios를 사용한다. Axios Promise based HTTP client 브라우저와 Node.js에서 모두 사용 가능 XMLHttpRequest, fetch에 비해 사용하기 편하고 기능이 더 많음 fetch는 취소가안되서 Axios를 더 사용하게된다. Axios + json-server 예제Link GET 자료읽기POST 자료 생성PUT 자료 갱신(값을 통째로 다 바꾼다 = 치환)PATCH 자료 갱신DELETE 삭제 Axios는 기본적으로 json을 받는다. 12345678axios.get('/api/todos/1') .then(res =&gt; &#123; console.log(`status code: $&#123;res.status&#125;`) console.log('headers:') prettyPrint(res.headers) console.log('data:') prettyPrint(res.data) &#125;) 상태 코드(res.status), 응답 헤더 (res.headers), 데이터 쿠키를 통한 인증 예제Link AxiosAxios는 최근 인기를 끌고 있는 HTTP client입니다. 브라우저에서 사용하면 XMLHttpRequest를 사용하여 Ajax 요청을 보내고, Node.js에서 사용하면 내장 http 모듈을 이용해 요청을 보냅니다. 사용법이 아주 간단하며 Promise 기반으로 깔끔한 코드를 작성할 수 있습니다. 상단의 Show 버튼을 누르고 개발자 도구의 콘솔을 열어 예제 코드를 입력해보세요. axios 변수가 미리 로드되어 있습니다. json-server + express이 프로젝트는 json-server 패키지를 사용해 REST API를 제공하고 있습니다. json-server는 내부적으로 express를 사용하고 있어서 커맨드라인을 통해서 json-server를 실행시키지 않고 직접 자바스크립트 파일에서 불러와 사용할 수 있습니다. 보통의 express 객체를 사용하듯이 사용할 수 있어서 필요한 경로에 미들웨어를 마음대로 추가할 수 있습니다. server.js 파일을 참고해주세요. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 const jsonServer = require('json-server')const fs = require('fs')const cookieSession = require('cookie-session')const bodyParser = require('body-parser')// json-server의 구성요소들을 생성합니다.const server = jsonServer.create()const router = jsonServer.router('.data/db.json')const middlewares = jsonServer.defaults()// 쿠키를 glitch에서 사용하기 위해 필요한 설정입니다.server.set('trust proxy', 1)// cookie-session 미들웨어를 주입합니다.server.use(cookieSession(&#123; name: 'session', secret: 'secret'&#125;))// json-server가 제공하는 미들웨어를 주입합니다.server.use(middlewares)// 사용자 데이터를 관리할 데이터베이스가 필요한데// json-server로 관리되는 데이터에 접근하기 어렵기 때문에// 사용자 데이터만 아래와 같이 따로 배열로 관리합니다.const users = [ &#123;username: 'fast', password: 'campus'&#125;, &#123;username: 'node', password: 'js'&#125;, &#123;username: 'react', password: 'facebook'&#125;]// 인증을 위한 라우트 핸들러입니다.// bodyParser.json json을 다루는 미들웨어이다.server.post('/auth', bodyParser.json(), (req, res) =&gt; &#123; const &#123;username, password&#125; = req.body // const username = req.body.username // const password = req.body.password const matched = users.find(user =&gt; user.username === username &amp;&amp; user.password === password) if (matched) &#123; req.session.username = username res.send(&#123;ok: true, data: &#123;users&#125;&#125;) // res.end() &#125; else &#123; res.status(400) res.send(&#123;ok: false, message: '400 Bad Request'&#125;) // res.end() &#125;&#125;)// 로그아웃을 위한 라우트 핸들러입니다.server.delete('/auth', (req, res) =&gt; &#123; req.session = null res.end()&#125;)// `/api` 경로의 인증을 담당하는 미들웨어입니다.function authMiddleware(req, res, next) &#123; if (!req.session.username) &#123; res.status(401) res.send('401 Unauthorized') &#125; else &#123; next() &#125;&#125;server.use('/api', authMiddleware, router)server.listen(3000, () =&gt; &#123; console.log('JSON Server is running')&#125;) 쿠키를 통한 인증 예제현재 authMiddleware로 인해 /api 경로로 요청을 해도 401 응답이 오는 상태입니다. /auth 경로로 인증 요청을 보낸 후, 쿠키의 변경사항을 확인하시고 /api 경로로 요청을 보내보세요. 모든 요청을 보낸 후에 로그아웃 요청을 보낸 후, 로그아웃이 잘 되었는지 확인해보세요. 로그인1234567// 로그인axios.post('/auth', &#123; username: 'fast', password: 'campus'&#125;).then(res =&gt; &#123; prettyPrint(res.data)&#125;) 12345678로그아웃// 로그아웃axios.delete('/auth') .then(res =&gt; &#123; prettyPrint(res.data) &#125;)아래부터는 이전 예제와 동일한 내용입니다. 1234567GET /api/todos// GETaxios.get('/api/todos') .then(res =&gt; &#123; prettyPrint(res.data) &#125;) 1234567POST /api/todos// POSTaxios.post('/api/todos', &#123;title: \"ajax 공부\"&#125;) .then(res =&gt; &#123; prettyPrint(res.data) &#125;) 1234567PATCH /api/todos/3// PATCHaxios.patch('/api/todos/3', &#123;title: \"axios 공부\"&#125;) .then(res =&gt; &#123; prettyPrint(res.data) &#125;) 12345678DELETE /api/todos/3// DELETEaxios.delete('/api/todos/3') .then(res =&gt; &#123; prettyPrint(res.data) &#125;)GET /api/todos/?title=react axios 요청 메소드의 두 번째 인자로 config 객체를 넘길 수 있습니다. config 객체를 통해 요청의 쿼리 스트링, 요청 헤더, 쿠키 포함 여부 등 많은 것들을 설정할 수 있습니다. 12345678910111213// config 객체axios.get('/api/todos', &#123; params: &#123; // query string title: 'react 공부' &#125;, headers: &#123; // 요청 헤더 'X-Api-Key': 'my-api-key' &#125;, timeout: 1000 // 1초 이내에 응답이 오지 않으면 에러로 간주&#125;).then(res =&gt; &#123; prettyPrint(res.data) &#125;)응답 객체 응답 객체를 통해 응답의 여러 정보에 접근할 수 있습니다. 123456789// config.paramsaxios.get('/api/todos/1') .then(res =&gt; &#123; console.log(`status code: $&#123;res.status&#125;`) console.log('headers:') prettyPrint(res.headers) console.log('data:') prettyPrint(res.data) &#125;) Not a Number문자열을 정수로 변경하는 방법 1 : undefined 1 를하면 NaN이 나오는 문제가 발생한다. NaN을 판별할때는 isNaN을 사용해야한다. parseInt","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Ajax","slug":"Node-js/Ajax","permalink":"http://yoursite.com/categories/Node-js/Ajax/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"Node-fetchApi","slug":"node-study-fetchapi","date":"2017-09-05T03:54:00.000Z","updated":"2017-09-21T02:17:07.000Z","comments":true,"path":"2017/09/05/node-study-fetchapi/","link":"","permalink":"http://yoursite.com/2017/09/05/node-study-fetchapi/","excerpt":"","text":"Node Fetch APIFetch API 웹 브라우저의 XMLHttpRequest를 대체하기 위해 만들어진 새로운 HTTP client 표준 비교적 최근에 도입되어 IE 및 구형 안드로이드 브라우저(4.x)는 지원하지 않음 Fetch Polyfill 최신기술로써 지원하지 않는 브라우저가 많지만 Fetch Polyfill을 사용하면 사용가능하다. isomorphic-fetch npm library이다. Axios vs Fetch API Instance와 같이 설정을 재사용하거나 요청중인 연결을 취소하는 등의 편의기능이 Fetch API에는 없음 현재로서는 Axios를 사용하는 것이 좋은 선택 다만, Axios는 내부적으로 XMLHttpRequest를 사용하고 있는데 Service Worker 등의 웹 최신 기술이 XMLHttpRequest를 지원하지 않으므로, Service Worker를 사용할 예정에 있는 프로젝트에서는 Axios를 사용할 수 없음 Fetch APIFetch API","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Fetch","slug":"Node-js/Fetch","permalink":"http://yoursite.com/categories/Node-js/Fetch/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Fetch","slug":"Fetch","permalink":"http://yoursite.com/tags/Fetch/"}]},{"title":"Node-Express-Middleware","slug":"node-study-node-Express-Middleware","date":"2017-09-04T03:54:00.000Z","updated":"2017-09-16T11:11:26.000Z","comments":true,"path":"2017/09/04/node-study-node-Express-Middleware/","link":"","permalink":"http://yoursite.com/2017/09/04/node-study-node-Express-Middleware/","excerpt":"","text":"Node Express MiddlewareMiddleware?1234567// 미들웨어 = 함수function helloMiddleware(res, req, next) &#123; console.log('hello') next()&#125;app.use(helloMiddleware) 요청이 발생할 때 마다 console.log(‘hello’)가 나타난다. Middleware 함수, 즉 안에서 어떤 작업이든 가능 request 객체, response 객체, next 함수를 인자로 받음 request 객체, response 객체를 조작해서 기능 구현 다음 미들웨어를 동작시키기 위해 next 함수를 인자 없이 호출 미들웨어는 등록된 순서가 중요하다 먼저 등록된 것이 먼저 시작되기 때문이다. 등록된 순서대로 실행됨 app.use미들웨어를 앱 전체에서 동작하도록 주입1app.use(helloMiddleware) 특정 경로에서만 동작하도록 주입1app.use('/some-path', helloMiddleware)\\ 한번에 여러 개 주입 1app.use(middleware1, middleware2, middleware3, ...) 미들웨어로 하는 일 로깅 HTTP body를 객체로 변환 사용자 인증 권한 관리 Why middleware?미들웨어로 할 수 있는 모든 일은 라우트 핸들러에서도 할 수 있으나, 여러 라우터에서 사용해야 하는 기능을 중복 작성하는 불편을 덜고 코드를 재사용하기 위해 미들웨어를 사용하는 것 미들웨어 생태계Express resourceNPM search 미들웨어 예제Link Express 미들웨어 예제 middlewares.js 파일에서 작성한 미들웨어를 server.js에서 불러와 사용하고 있습니다. 각각 어떤 방식으로 미들웨어를 사용하고 있는지 확인해보세요. next? 미들웨어는 req, res에 더해서 next라는 함수를 추가로 인자로 받습니다. next 함수를 호출하면 다음 미들웨어로 처리를 넘기는 효과가 있습니다. 만약에 미들웨어가 next 함수를 호출하지도 않고, 응답도 보내지 않으면 클라이언트는 응답을 받지 못하게 되므로 주의하세요! App Local, Response Local app.locals와 res.locals는 특별한 객체를 담고 있습니다. 템플릿에서는 res.render를 통해 명시적으로 주입받지 않아도 저 두 객체의 속성에 바로 접근할 수 있습니다. 템플릿을 가리지 않고 사용되는 정보들, 예를 들어 ‘현재 로그인 중인 사용자 정보’ 같은 것을 res.render에 매번 인자로 넘기는 것은 귀찮을 뿐더러 빠뜨리기도 쉽습니다. 그런 정보들을 템플릿에서 쉽게 사용하기 위해, app.locals나 res.locals에 우리가 원하는 이름으로 속성을 주입할 수 있습니다. app.locals는 앱 단위로 공통적으로 쓰이는 정보를 담는 목적으로 사용됩니다. res.locals는 각 요청마다 달라지는 정보를 담는 목적으로 사용됩니다. app.local 객체를 조작하는 것은 매우 쉽습니다. res 객체는 매 요청마다 새로 생성되어 미들웨어 바깥에서 접근할 수 있는 방법이 없으므로, res.locals를 조작하려면 미들웨어를 사용해야 합니다. 미들웨어에서도 직접 res.send를 통해서 값을 보낼 수 도있다 next or res.send 둘중하나는 꼭 해줘야한다. app.locals는 변하지 않는 값을 쓸때 사용하고 res.locals는 변경가능한 값을 쓸때 사용한다. 12345678910111213141516171819202122function makeAdder(x) &#123; return function(y) &#123; return x + y &#125;&#125;undefinedadd1 = makeAdder(1)ƒ (y) &#123; return x + y &#125;add1(2)3// 값이 이렇게 사용해도되는데 이것을 currying이라고 한다.makeAdder(3)(4)7 // 위의 함수와 같은 역할을 한다.makeAdder2 = x =&gt; y =&gt; x+yx =&gt; y =&gt; x+ymakeAdder2(4)(4)8 closure를 사용하여서 함수를 2가지를 사용한다 currying이라고도 불린다. 12345678910111213141516171819202122232425262728293031323334353637383940//server.jsconst express = require('express')const &#123; ipLoggingMiddleware, urlLoggingMiddleware, resLocalMiddleware, lock&#125; = require('./middlewares')const app = express()app.set('view engine', 'ejs')// 앱 단위 미들웨어는 모든 라우트 핸들러에서 실행됩니다.// 미들웨어는 등록된 순서대로 실행됩니다.// 아래 미들웨어 적용 순서를 바꿔보세요.app.use(urlLoggingMiddleware)app.use(ipLoggingMiddleware)// 라우트 단위 미들웨어는 적용된 라우트에서만 실행됩니다.app.get('/', resLocalMiddleware, (req, res) =&gt; &#123; res.render('index.ejs')&#125;)app.get('/secret', lock('thisisthekey'), (req, res) =&gt; &#123; res.send('my secret is...')&#125;)// 요청이 라우트 핸들러가 등록된 어떤 경로와도 일치하지 않을 때,// 맨 마지막 미들웨어를 실행시킬 수 있습니다. 이를 이용해 우리만의 404 페이지를 보여줄 수 있습니다.// 아래에 작성해보세요. (참고: http://expressjs.com/ko/starter/faq.html)app.use((req, res, next) =&gt; &#123; res.render('404.ejs')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) 12345678910111213141516171819202122232425//middlewares.jsexports.ipLoggingMiddleware = (req, res, next) =&gt; &#123; console.log(`request ip: $&#123;req.ip&#125;`) next()&#125;exports.urlLoggingMiddleware = (req, res, next) =&gt; &#123; console.log(`request url: $&#123;req.originalUrl&#125;`) next()&#125;exports.resLocalMiddleware = (req, res, next) =&gt; &#123; res.locals.myVar = 'FASTCAMPUS!' next()&#125;exports.lock = key =&gt; (req, res, next) =&gt; &#123; if (req.query.key === key) &#123; next() &#125; else &#123; res.status(403) res.send('403 Forbidden') &#125;&#125; 404관련 페이지는 가장 밑에서 실행해야한다. 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;%= myVar %&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 미들웨어 vs 라우트 핸들러 라우트 핸들러도 미들웨어 즉, next함수를 인자로 받는 것이 가능 1234567app.get('/', (req, res, next) =&gt; &#123; if (!someCondition) &#123; next() // 요청을 처리를 하지 않고 다른 핸들러로 넘김 &#125; else &#123; res.send('hello') &#125;&#125;) 오류 핸들러를 설정하는 방법 오류 처리 미들웨어는 다른 미들웨어와 동일한 방식으로 정의할 수 있지만, 다음과 같이 오류 처리 함수는 3개가 아닌 4개의 인수, 구체적으로 말하면 (err, req, res, next) 시그니처를 갖는다는 점이 다릅니다. bugsnag sentry 1234app.use(function(err, req, res, next) &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;);","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Express-Middlware","slug":"Node-js/Express-Middlware","permalink":"http://yoursite.com/categories/Node-js/Express-Middlware/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://yoursite.com/tags/Express/"},{"name":"Middleware","slug":"Middleware","permalink":"http://yoursite.com/tags/Middleware/"}]},{"title":"Node-Cookie","slug":"node-study-node-cookie","date":"2017-09-04T03:54:00.000Z","updated":"2017-09-16T11:07:34.000Z","comments":true,"path":"2017/09/04/node-study-node-cookie/","link":"","permalink":"http://yoursite.com/2017/09/04/node-study-node-cookie/","excerpt":"","text":"Node Cookie쿠키의 필요성 개별 클라이언트의 여러 요청에 걸친 정보의 유지 장바구니 로그인/로그아웃 방문 기록 HTTP Cookie 서버가 응답을 통해 웹 브라우저에 저장하는 이름+값 형태의 정보 웹 브라우저는 쿠키를 저장하기 위한 저장소를 가지고 있음 저장소는 자료의 유효기간과 접근 권한에 대한 다양한 옵션을 제공 쿠키 전송 절차 서버는 브라우저에 저장하고 싶은 정보를 응답과 같이 실어 보낸다(Set-Cookie 헤더) 12HTTP/1.1 200 OKSet-Cookie: cookieName=cookieValue; Secure; Max-Age=60000 브라우저는 같은 서버에 요청이 일어날 때마다 해당 정보를 요청에 같이 실어서 서버에 보낸다 (Cookie 헤더) 12GET / HTTP/1.1Cookie: cookieName=cookieValue; anotherName=anotherValue Set-Cookie OptionsExpires, Max-Age 쿠키의 지속 시간 설정 Secure HTTPS를 통해서만 쿠키가 전송되도록 설정 HttpOnly 자바스크립트에서 쿠키를 읽지 못하도록 설정 Domain, Path 쿠키의 scope 설정 (쿠키가 전송되는 URL을 제한) Express + Cookie쿠키 읽기 - req.cookies 요청에 실려온 쿠키가 객체로 변환되어 req.cookies에 저장됨(cookie-parser middleware 필요) 쿠키 쓰기 - res.cookie(name, value) 쿠키의 생성 혹은 수정 쿠키 예제Link 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const express = require('express')const cookieParser = require('cookie-parser')const app = express()app.set('trust proxy', 1)app.use(cookieParser())app.get('/', (req, res) =&gt; &#123; res.send(req.cookies)&#125;)app.get('/somePath', (req, res) =&gt; &#123; res.send(req.cookies)&#125;)// 별다른 옵션 없이 쿠키를 저장하는 응답을 보냅니다.app.get('/set', (req, res) =&gt; &#123; res.cookie('cookieName', 'cookieValue') res.redirect('/')&#125;)// httpOnly 옵션은 해당 쿠키를 자바스크립트에서 접근할 수 없게 합니다. 즉 보안성이 향상app.get('/httpOnly', (req, res) =&gt; &#123; res.cookie('httpOnlyCookie', 'value', &#123; httpOnly: true &#125;) res.redirect('/')&#125;)// secure 옵션은 http 프로토콜을 통한 요청에는 쿠키가 포함되지 않게 합니다. (https로 했을 때만 포함시킴)app.get('/secure', (req, res) =&gt; &#123; res.cookie('secureCookie', 'value', &#123; secure: true &#125;) res.redirect('/')&#125;)// maxAge 옵션은 쿠키가 해당 시간이 지났을 때 삭제되도록 합니다.app.get('/maxAge', (req, res) =&gt; &#123; res.cookie('maxAgeCookie', 'value', &#123; maxAge: 5000 &#125;) res.redirect('/')&#125;)// domain 옵션은 해당 도메인 및 서브도메인으로 쿠키가 전송되도록 합니다.app.get('/domain', (req, res) =&gt; &#123; res.cookie('domainCookie', 'value', &#123; domain: 'glitch.me' &#125;) res.redirect('/')&#125;)// path 옵션은 쿠키가 지정된 경로 및 그 하위 경로에 요청이 일어났을 때만 전송되도록 합니다.// 루트에서는 안보이고 somePath에서는 보인다.app.get('/path', (req, res) =&gt; &#123; res.cookie('pathCookie', 'value', &#123; path: '/somePath' &#125;) res.redirect('/')&#125;)// 여러 옵션을 한꺼번에 지정할 수도 있습니다.app.get('/multiple-options', (req, res) =&gt; &#123; res.cookie('multipleOption', 'value', &#123; secure: true, httpOnly: true, maxAge: 5000 &#125;) res.redirect('/')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) JavaScript + Cookie자바스크립트로도 쿠키를 읽고 쓰는 방법이 존재하지만, 보안 상 문제를 일으킬 수 있으므로 이런 접근 방식은 거의 사용되지 않는다. 자바스크립트에서 쿠키에 접근하지 못하도록 HttpOnly를 항상 설정하는 것이 best practice 쿠키의 한계점 US-ASCII 밖에 저장하지 못함. 보통 percent encoding을 사용 4000 바이트 내외(영문 4000자, percent encoding 된 한글 444자 가량)밖에 저장하지 못함 브라우저에 저장됨. 즉, 여러 브라우저에 걸쳐 공유되어야 하는 정보, 혹은 웹 브라우저가 아닌 클라이언트(모바일 앱)에 저장되어야 하는 정보를 다루기에는 부적절","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Cookie","slug":"Node-js/Cookie","permalink":"http://yoursite.com/categories/Node-js/Cookie/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"}]},{"title":"Node-Session","slug":"node-study-node-session","date":"2017-09-04T03:54:00.000Z","updated":"2017-09-16T11:12:55.000Z","comments":true,"path":"2017/09/04/node-study-node-session/","link":"","permalink":"http://yoursite.com/2017/09/04/node-study-node-session/","excerpt":"","text":"Node SessionSession사전적 의미 (특정한 활동을 위한) 시간 (의회 등의)회기; (법정의) 개정 (기간) 실질적 의미시작 조건과 종료조건이 있는 시간, 또는 회기정보 교환이 지속되는 시간, 또는 회기 세션의 예 HTTP session요청 - 응답 클라이언트가 TCP 연결을 수립합니다(또는 전송 계층이 TCP가 아닌 다른 적당한 연결로). 클라이언트는 요청을 전송한 뒤 응답을 기다립니다. 서버는 요청에 대해 처리하고 그에 대한 응답을 상태 코드 그리고 요청에 부합하는 데이터와 함께 돌려보냅니다. 로그인 세션로그인 - 로그아웃 Google Analytics 세션페이지 접속 - 30분간 접속이 없으면 종료로 간주 (커스터마이징 가능) 웹 서비스를 위한 세션의 구현 세션이 시작되면, 세션이 시작되었다는 사실을 쿠키에 저장 세션에 대한 정보를 여러 요청에 걸쳐서 지속시키기 위해, 정보를 어딘가에 저장 세션이 만료되면, 세션이 만료되었다는 사실을 쿠키에 반영 위 방식은 널리 사용되는 방식일 뿐, 반드시 위와 같이 구현해야 하는 것은 아닙니다. 세션 스토어세션에 대한 정보를 저장하는 어딘가 쿠키 데이터베이스 파일 기타 정보를 저장할 수 있는 곳 어디든 세션 스토어의 선택서비스의 요구사항에 맞춰서 적절한 저장소를 선택하면 됨 정보의 형태가 간단하고 자주 바뀔 일이 없으면 쿠키 저장해야 할 정보의 양이 많으면 데이터베이스 정보가 굉장히 자주 변경되면 메모리 기반 저장소 세션? 세션 스토어?&#39;세션&#39;과 &#39;세션 스토어&#39;는 엄연히 다른 말이지만 혼용되는 경우가 많습니다. &#39;세션에 정보를 저장한다&#39;는 말은 &#39;세션 스토어에 정보를 저장한다&#39;는 말과 같은 뜻이라고 생각하면 됩니다. Express + Sessioncookie-session 쿠키에 모든 정보를 저장하는 세션 스토어. 첫 방문시 무조건 세션 시작express-session 쿠키에는 세션 식별자만 저장하고 실제 정보의 저장은 외부 저장소(데이터베이스 등)를 이용하는 세션 스토어. 외부 저장소에 대한 별도의 설정 필요 cookie-session 예제Link cookie-session NPM 패키지는 쿠키를 세션 스토어로 사용할 수 있도록 해주며 세션 스토어를 쉽게 사용할 수 있는 방법을 제공합니다. server.js 파일과 앱을 열어 어떤 방식으로 동작하는 앱인지 확인하고, 크롬 개발자 도구를 이용해 쿠키가 전달되고 저장되는 모습을 확인하세요. cookie-session 동작 방식 cookie-session 미들웨어는 첫 요청이 일어났을 때 빈 세션 정보(빈 객체)를 req.session에 주입합니다. 프로그래머는 세션과 관련된 정보를 req.session에 저장합니다. req.session은 보통의 자바스크립트 객체로, JSON으로 표현될 수 있는 자료라면 뭐든지 저장할 수 있습니다. cookie-session 미들웨어는 응답이 일어나기 직전에 req.session 객체를 문자열로 바꾼 뒤(JSON &amp; base64), 쿠키에 저장합니다. cookie-session 미들웨어는 다음 번 요청부터 쿠키에 저장된 정보를 자바스크립트 객체로 변환해 req.session에 주입합니다. 프로그래머는 req.session 객체를 이용해 세션 정보를 읽을 수 있습니다. 또한 세션 정보를 통째로 삭제하기 위해 미들웨어 또는 라우트 핸들러에서 req.session = null을 대입할 수 있습니다. session.sig? 서명!session 쿠키에 저장된 정보는 일반인은 알아볼 수 없지만 프로그래머라면 쉽게 복원하거나 변경할 수 있습니다. (base64 디코더로 session 쿠키를 변환해보세요) 만약에 세션에 계정 정보가 들어있고, 악의적인 해커가 쿠키의 값을 변경해서 세션 스토어를 조작할 수 있다면, 마치 다른 사람인 척 행세할 수 있고 그에 따라 정보를 탈취당할 수도 있을 것입니다. 그래서, cookie-session 미들웨어는 보안 유지를 위해 서명(signature)을 활용하고 있습니다. 컴퓨터 분야에서의 서명이란, 비밀 키를 이용해 정보를 특별한 알고리즘(hashing)으로 변형시킨 것을 말합니다. 서명의 가장 중요한 성질은, 같은 비밀 키로 같은 정보를 서명했을 때 언제나 같은 결과가 나온다는 것, 그리고 비밀 키나 정보 중 어느 한 쪽만 바뀌어도 서명의 결과가 크게 달라진다는 것입니다. 비밀 키와 서명을 활용하면 정보가 조작되었는지의 여부를 알 수 있습니다. 어떤 정보를 서명과 함께 공개하고 비밀 키는 숨기면, 누군가가 정보를 조작해서 올바른 정보인 척 흉내를 내려고 해도 비밀 키를 모르기 때문에 서명을 할 수 없어서 금방 조작인 것이 탄로가 나겠죠. cookie-session 미들웨어는 응답을 보낼 때 session 쿠키에 저장된 문자열을 비밀 키로 서명해서 그 결과를 session.sig 쿠키에 저장합니다. 만약에 요청에 포함된 session 쿠키를 다시 같은 비밀 키로 서명했는데 session.sig 쿠키와 일치하지 않는다면, 정보가 조작된 것을 알아채고 세션을 아예 삭제해버리는 방식으로 조작을 막습니다! 서명을 활용할 때 주의할 점이 있습니다. 비밀 키는 당연히 공개되지 않도록 관리해야 합니다. 비밀 키와 서명 알고리즘이 공개되면 서명이 조작될 수 있습니다. 키의 길이를 충분히 길게 해야 합니다. 해커가 서명 알고리즘을 알고 있다면, 짧은 비밀 키는 어렵지 않게 계산해낼 수 있습니다. 서명은 정보의 조작을 막아주지만, 정보의 공개를 막아주지는 않습니다. session 쿠키만 하더라도 base64 디코딩만 거치면 어떤 정보가 들어있는지 바로 확인할 수 있죠. 따라서 비밀번호나 신용카드 번호 등은 cookie-session이 제공하는 세션 스토어에 저장하면 안 됩니다. 참고로, 이전에 다뤘던 cookie-parser 미들웨어도 옵션을 활성화하면 서명을 사용하여 조작을 방지할 수 있습니다. 곧 배울 JWT도 보안을 위해 서명을 사용하고 있습니다. 서명 과정을 직접 시험해보고 싶다면 여기를 참고하세요. 12345678910111213141516171819202122232425262728293031323334353637383940414243const express = require('express')const cookieSession = require('cookie-session')const app = express()app.set('trust proxy', 1) app.set('view engine', 'ejs')// cookie-session 설정// name: 쿠키 이름으로 사용할 문자열// secret: 세션 정보를 서명할 때 사용할 키// 여러가지 옵션을app.use(cookieSession(&#123; name: 'session', secret: process.env.SECRET&#125;))// req.session.count를 처리하는 미들웨어const countMiddleware = (req, res, next) =&gt; &#123; if ('count' in req.session) &#123; // count 속성이 있으면 1으. req.session.count += 1 &#125; else &#123; // count 속성이 없으면 처음 방문한 것이므로 1로 설정한다. req.session.count = 1 &#125; next()&#125;// 첫 방문 후, 쿠키 관련 헤더가 요청과 응답에 잘 포함되는지 살펴보고,// 실제로 쿠키가 어떻게 저장되어있는지 살펴보세요.app.get('/', countMiddleware, (req, res) =&gt; &#123; res.render('index.ejs', &#123;count: req.session.count&#125;)&#125;)app.post('/reset-count', (req, res) =&gt; &#123; delete req.session.count res.redirect('/')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) req.session에다가 값을 저장하면 cookie value에 값이 저장된다. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;%= count %&gt;번 째 방문하셨습니다. &lt;/div&gt; &lt;form action=\"/reset-count\" method=\"post\"&gt; &lt;button type=\"submit\"&gt; 초기화 &lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 인증(Authentication)과 인가(Authorization)인증(Authentication)은 클라이언트가 누구인지를 확인하는 과정입니다. 지금은 ‘인증과 로그인은 같은 말’이라고 생각하셔도 무방합니다. 인가는 클라이언트가 하려고 하는 작업이 해당 클라이언트에게 허가된 작업인지를 확인하는 과정입니다. ‘권한 설정’이라고 생각하셔도 무방합니다. 예를 들어 다음 카페나 네이버 클럽에서는 관리자만이 게시판을 만들거나 없앨 수 있도록 인가됩니다. 인증 구현 전략인증은 여러가지 방식으로 구현될 수 있으며, 여기에서는 우리가 쓰고 있는 cookie-session 의 기능에 맞추어서 구현해보도록 하겠습니다. cookie-session이 제공하는 미들웨어는 첫 방문시 바로 세션을 시작하고 (이를 guest session이라 부릅니다) 쿠키에 빈 세션 정보(빈 객체)를 저장합니다. 그래서 첫 방문자에 대해서도 session 객체를 바로 쓸 수 있습니다. 아래와 같은 규칙으로 인증을 구현해보도록 합니다. req.session.username === undefined이면 로그인된 사용자가 없는 것으로 간주합니다. 사용자가 로그인 폼을 전송하면 accounts 배열에 저장된 계정 정보 중에 일치하는 것이 있는지 확인하고, 있다면 req.session.username에 해당 사용자 이름을 저장합니다. 만약 일치하는 계정이 없으면 400 Bad Request 응답을 보냅니다. req.session.username에 저장된 값이 있다면 해당 사용자로 로그인이 되어 있다고 간주합니다. 로그아웃을 하기 위해 req.session = null와 같이 대입해서 세션을 초기화합니다. (인증이 된 뒤에는 req.user와 res.locals.user에 계정 객체를 주입해서 라우트 핸들러와 템플릿에서 편하게 접근할 수 있도록 미리 코드를 짜 두었습니다.) 인가 구현 전략관리자만이 비밀 정보(/secret)에 접근할 수 있도록 해 보겠습니다. 사용자가 관리자인지 아닌지의 여부는 계정 객체의 admin 속성에 저장되어 있습니다. 로그인한 정보를 맞는지 확인하여서 값을 찾아낸다.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//server.jsconst express = require('express')const cookieSession = require('cookie-session')const bodyParser = require('body-parser')const app = express()const urlencodedMiddleware = bodyParser.urlencoded(&#123;extended: false&#125;)app.set('trust proxy', 1) app.set('view engine', 'ejs')const accounts = [ &#123; username: 'tpwns', password: 'kim', name: '김세준' &#125;, &#123; username: 'fast', password: 'campus', name: '패스트캠퍼스', admin: true &#125;]app.use(cookieSession(&#123; name: 'session', secret: process.env.SECRET&#125;))app.use((req, res, next) =&gt; &#123; if (req.session.username) &#123; req.user = res.locals.user = accounts.find(acc =&gt; acc.username === req.session.username) &#125; else &#123; req.user = res.locals.user = null &#125; next()&#125;)app.get('/', (req, res) =&gt; &#123; res.render('index.ejs')&#125;)app.post('/login', urlencodedMiddleware, (req, res) =&gt; &#123; const account = accounts.find(acc =&gt; acc.username === req.body.username &amp;&amp; acc.password === req.body.password) // 인증 과정을 작성해주세요. if(account)&#123; req.session.username = account.username res.redirect('/') &#125;else &#123; res.status(400) res.send('400 Bad Request') &#125; &#125;)function onlyAdminMiddleware(req, res, next) &#123; // `/secret`에 접속했을 때 이 미들웨어가 작동합니다. // 관리자가 아니면 403 Forbidden 응답을 보내도록 작성해주세요. // 위에서 req.session.username에 저장한 값을 통해 비교한다. const manage = accounts.find(acc =&gt; acc.username === req.session.username) if(manage.admin == true)&#123; // next를 통하여 전달한다. next() &#125;else &#123; res.status(403) res.send('403 Forbidden') &#125;&#125;app.get('/secret', onlyAdminMiddleware, (req, res) =&gt; &#123; res.send('It is my secret')&#125;)app.post('/logout', urlencodedMiddleware, (req, res) =&gt; &#123; req.session = null res.redirect('/')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) MiddleWare에서는 성공시 next로 보내줘야한다. session.sig을 통하여 session의 보안성이 지켜진다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Session","slug":"Node-js/Session","permalink":"http://yoursite.com/categories/Node-js/Session/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Session","slug":"Session","permalink":"http://yoursite.com/tags/Session/"}]},{"title":"Node-Web-Form","slug":"node-study-web-form","date":"2017-08-30T03:54:00.000Z","updated":"2017-09-21T02:18:35.000Z","comments":true,"path":"2017/08/30/node-study-web-form/","link":"","permalink":"http://yoursite.com/2017/08/30/node-study-web-form/","excerpt":"","text":"Node Web FormHTML FormHTML form의 기본 동작HTML form을 전송하면, 입력된 정보가 기본적으로 percent encoding 되어 요청됨 GET method 이름=값 형식으로 간다.12GET /search?query=%EA%B0%9C&amp;sort=latest HTTP/1.1... Post method 이름=값 형식으로 간다. urlencoded로는 파일을 보내기에 부적절해서 다른 Content-type인 multipart를 사용한다. 12345POST /form HTTP/1.1Content-Type: application/x-www-form-urlencoded...home=Cosby&amp;favorite+flavor=flies multipart/ form-data 기본 설정(percent encoding)으로는 폼으로 파일을 업로드하는 것은 불가능 (클라이언트 측) form 태그에 enctype=&quot;multipart/form-data&quot;속성을 적용하면 파일 업로드 가능 (서버 측) body-parser 미들웨어는 multipart/form-data 형태의 요청을 지원하지 않음 (multer 필요) json, url-encoded형식을 req.body에서 사용하기 위해서는 body-parser가 필요하다. HTML Form 예제 Link UUID Redirection after submission Form validation 클라이언트 측 validation을 잘하면 사용자가 사용하기에 편하다. 클라이언트 측 validation 구현방법 1&lt;input required type=\"text\" name=\"title\"&gt; redirect(‘/‘)는 300(301 Moved Permanently302 Found) 번대 에러가 발생했을 때 다른 곳으로 보내준다. post 응답이 redirect가아닌 새로고침을 하면 같은 값이 계속 간다. Ajax를 사용할때는 redirect를 하지 않아도 괜찮다. 301과 302의 차이 301응답이란? 사용자가 보내면 web browser는 그걸을 기억했다가 똑같은 요청이 온다면 web browser가 서버에 요청을 하지않고 web browser에서 그전의 저장한 정보를 보낸다. res.redirect는 302 상태코드로 응답합니다. UUID 범용 공용 식별자 : 어디에서든지 유니크한 아이디 128bit의 숫자로 이루어져 있으며","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Web Form","slug":"Node-js/Web-Form","permalink":"http://yoursite.com/categories/Node-js/Web-Form/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Web Form","slug":"Web-Form","permalink":"http://yoursite.com/tags/Web-Form/"}]},{"title":"Node-Service-Develop","slug":"node-study-service-develope","date":"2017-08-30T03:54:00.000Z","updated":"2017-09-15T14:50:58.000Z","comments":true,"path":"2017/08/30/node-study-service-develope/","link":"","permalink":"http://yoursite.com/2017/08/30/node-study-service-develope/","excerpt":"","text":"Node Service DevelopURL Shortener goo.gl bit.ly urlo.cc 요구사항 긴 URL을 짧은 URL로 변경하는 것은 한 명의 관리자만 만들 수 있음 짧은 URL은 누구나 이용할 수 있음 시나리오 설계화면 설계데이터 설계프로젝트 세팅 npm init -y .gitignore 추가 Express 앱 세팅 npm install –save express 템플릿 엔진 설 npm script 추 static 라우트 설 템플릿, CSS 파일 추가 로깅과 인증 morgan 설정 express-basic-auth 설정 초기 데이터 작업 randomstring 표로 보여주기 .ejs extension 설치 emmet 사용법 템플릿 작성 짧은 URL의 리디렉션 핸들러 작성 (301 Moved Permanently) Redirection cache 짧은 URL 링크 만들기 폼 body-parser 인증 설정 폼, 핸들러 작성 스타일링 Bootstrap CSS now.sh를 통한 배포 now 설치 환경변수란? dotenv 관리자 계정을 포함시켜 배포 Discussion 최적의 개발 순서? 적절한 커밋의 단위는?","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Service Develop","slug":"Node-js/Service-Develop","permalink":"http://yoursite.com/categories/Node-js/Service-Develop/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Service Develop","slug":"Service-Develop","permalink":"http://yoursite.com/tags/Service-Develop/"}]},{"title":"Node-Http","slug":"node-study-http","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-14T13:25:48.000Z","comments":true,"path":"2017/08/29/node-study-http/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-http/","excerpt":"","text":"HTTP History APIHTTP History API history.back() window.history.back(); history.forward() window.history.forward(); history.go() 히스토리에서 특정 위치로 가기 history.pushState() 히스토리 엔트리의 추가 및 변경 이 메서드들은 window.onpopstate 이벤트와 연동하여 동작합니다. HTTP 까보기 WireShark https를 사용하는 사이트는 wireshark로 찾아볼 수 없다. Chrome Devtools 검사탭 -&gt; Network HTTP 웹 브라우저와 웹 서버 간의 통신을 위해 개발된 통신규약 최근에는 REST API의 부상와 함꼐 다른 용도로도 널리 사용됨 모바일 앱 - 서버 간 통신 서버 - 서버 간 통신 80번 포트를 기본으로 사용 클라이언트의 요청(requert)과 서버의 응답(response)으로 이루어짐 HTTPS HTTP over SSL HTTP 통신을 암호화해 주고받는 내용을 중간에서 가로챌 수 없도록 함 443번 포트를 기본으로 사용 HTTP/2 구글의 SPDY 프로토콜을 기반으로 2015년에 확정된 새로운 HTTP 표준 속도 개선에 중점을 두고 개발됨 반드시 HTTPS를 사용해야 함 현재 전체 웹사이트 중 16% 이상이 사용중 HTTP 구성요소Request &amp; Response 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보냄 그에 따라 서버는 클라이언트에 응답(response)를 보냄 웹 브라우저의 경우, HTML 문서 형태의 응답이 오면 해당 문서를 분석한 후, 문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보냄 (이미지, 동영상, 오디오, CSS, JS, 폰트, …) Request Methods HTTP 명세에는 8 종류가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있음 GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH HTTP request methods 웹 브라우저는 특정 상황에서 특정 메소드로 요청을 보내도록 강제되어져 있음 Ajax와 같이 요청을 보내는 코드를 직접 짤 때는 요청 메소드를 선택할 수 있음 자료의 본문을 요청하는 GET메소드와, 새로운 자료를 등록하는 POST 메소드가 가장 많이 쓰임 (서버가 충족시켜야 하는) 메소드의 성질Safe 요청이 서버의 상태에 영향을 미치지 않아야 함. 즉, 읽기 전용 Idempotent 여러 번 같은 요청을 해도 한 번 요청한 것과 같은 효과여야 함. 네트워크가 불안정해도 안전하게 요청을 보낼 수 있음 Cacheable (특정 조건을 만족하면) 응답을 클라이언트에 저장해두었다가 다음 번 요청 때 다시 쓸 수 있음 fetch는 일부분만 바꿀때 사용하며, put은 전체를 바꿀때 사용한다, link 반드시 이 성질을 따르도록 서버를 구현해야 하는 것은 아니나, 구현했을 때의 이점이 있으므로 이대로 구현하는 것이 좋다 URL 2,3,4는 domain영역이다. 4(TOP)는 특별한 기관에서 관리를한다. Percent Encoding URL은 ASCII 문자(128개의 영문자+특수문자+제어문자)밖에 사용하지 못하기 때문에, non-ASCII 문자를 위한 표현방법이 필요함 # Percent encoding은 non-ASCII 문자를 위한 웹 표준 인코딩 방법으로, JavaScript에 관련 기능이 포함되어 있음 1234&gt; encodeURIComponent(\"한글\")\"%ED%95%9C%EA%B8%80\"&gt; decodeURIComponent(\"%ED%95%9C%EA%B8%80\")\"한글\" 1234const encoded = encodeURIComponent('패스트캠퍼스')undefineddecodeURIComponent(encoded)\"패스트캠퍼스\" Request Target일반적인 경우 아래와 같은 구조가 사용됨 absolute path + query string + fragment id 1GET /path/to/resource?foo=bar&amp;spam=hoge#fragid HTTP/1.1 Response Status 응답의 성공, 실패 여부와 종류를 나타내며, 상태 코드 + 상태 메시지의 형태로 응답에 포함됨 1HTTP/1.1 200 OK HTTP Status Codes Status Category2xx 성공 3xx 추가 작업이 필요함 4xx 실패 - 클라이언트 책임 5xx 실패 - 서버 책임 Status Code - 2xx200 ok 성공 201 Created 자료가 성공적으로 생성됨 Status Code - 3xx301 Moved Permanently (Redirection) 자료가 완전히 다른 곳으로 이동했음 302 Found (Redirection) 자료가 일시적으로 다른 곳에 있음 304 Not Modified (Cache) 클라이언트가 이미 가지고 있던 자료가 수정되지 않았음 (그대로 사용하면 됨) Status Code - 4xx400 Bad Request 요청의 형태가 잘못되어 응답할 수 없음 403 Forbidden 요청한 자료에 접근할 권한이 없음 404 Not Found 요청한 자료가 없음 Status Code - 5xx500 Internal Server Error 요청을 처리하던 중에 예상치 못한 오류가 발생함 503 Service Unavailable 서버가 일시적으로 응답을 할 수 없음 Header 요청과 응답에 대한 추가 정보를 표현하는 데 사용됨 인증, 캐싱, 쿠키, 보안, 내용협상, 프록시 등 웹 표준에 정의된 많은 기능을 제어하는 데 사용됨 Authorization 요청의 인증 정보 User-Agent 요청 중인 클라이언트의 정보 Location 301, 302 응답에서 자료의 위치 Accept 요청이 어떤 형태의 자료를 원하는지 나타냄 Content-Type 요청 혹은 응답이 어떤 형태의 자료인지 나타냄 Content Negotiation 요청의 Accept, Accept-Language 등의 헤더를 보고 서버가 그에 맞는 형태의 자료를 응답하는 절차를 content negotiation(내용협상)이라고 함","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Http","slug":"Node-js/Http","permalink":"http://yoursite.com/categories/Node-js/Http/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Http","slug":"Http","permalink":"http://yoursite.com/tags/Http/"}]},{"title":"Node-Express","slug":"node-study-express","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-16T11:08:16.000Z","comments":true,"path":"2017/08/29/node-study-express/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-express/","excerpt":"","text":"Node Express 실습환경Glitch Tutorial 나의 Glitch Express Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크 내장하고 있는 기능은 매우 적으나, 미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음 공식 매뉴얼 한국어 번역 Express 앱의 기본 구조12345678910111213141516// Express Instance 생성const app = express()// 미들웨어 주입app.use(sessionMiddleware())app.use(authenticationMiddleware())// router handler registerapp.get('/', (request, response) =&gt; &#123; response.send('Hello express!')&#125;)// Server Startapp.listen(3000, ()=&gt;&#123; console.log('Example app listening on port 3000!')&#125;) Routing1234567891011121314151617181920212223const app = express()// HTTP Request Method (GET, POST, DELETE, PUT, ...)app.get('/articles', (req, res) =&gt; &#123; res.send('Hello Routing!')&#125;)// 특정 경로에만 미들웨어를 주입하는 것도 가능app.post('/articles', bodyParserMiddleware(), (req, res) =&gt; &#123; database.articles.create(req.body) // 요청한 body를 넣어둔다. .then(() =&gt; &#123; res.send(&#123;ok: true&#125;) &#125;)&#125;)// 경로의 특정 부분을 함수의 인자처럼 입력받을 수 있음app.get('/articles/:id', (req, res)=&gt; &#123; database.articles.find(req.params.id) // 'req.params.id'에 요청한 사람의 id가 저장된다. .then(article =&gt; &#123; res.send(article) &#125;)&#125;) Request 객체req.body requset.body를 적절한 형태의 자바스크립트 객체로 변환하여 이곳에 저장 (body-parser 미들웨어에 의해 처리됨) req.ip 요청한 쪽의 IP req.params route parameter req.query query string이 객체로 저장됨 Response 객체res.status(...) 응답의 상태 코드를 지정하는 메소드 res.append(...) 응답의 헤더를 지정하는 메소드 res.send(...) 응답의 바디를 지정하는 메소드 인자가 텍스트면 text/html, 객체면 application/json타입으로 응답 숫자를 send에 넣으면 error가 발생한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Express","slug":"Node-js/Express","permalink":"http://yoursite.com/categories/Node-js/Express/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://yoursite.com/tags/Express/"}]},{"title":"Node-Template-Language","slug":"node-study-template-language","date":"2017-08-29T03:54:00.000Z","updated":"2017-09-15T14:51:19.000Z","comments":true,"path":"2017/08/29/node-study-template-language/","link":"","permalink":"http://yoursite.com/2017/08/29/node-study-template-language/","excerpt":"","text":"Node Template LanguageStatic Web Page누가 어떻게 요청하든 미리 저장되어 있던 HTML 파일을 그대로 응답 Dynamic Web Page요청한 사람과 요청한 내용에 따라 각각 다른 내용으로 편집한 HTML을 응답 Template Engine템플릿과 데이터를 결합해 문서를 생성하는 프로그램, 혹은 라이브러리템플릿을 작성할 때 사용하는 언어를 템플릿 언어라고 함 EJSEmbedded JavaScript Template # Node.js 생태계에서 가장 많이 사용되는 템플릿 엔진 문법이 단순 JavaScript 코드를 템플릿 안에서 그대로 쓸 수 있음 .ejs VSCode Extension 1234567891011121314&lt;%# index.ejs %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"message\"&gt; &lt;%= message %&gt; &lt;/div&gt; &lt;% if (showSecret) &#123; %&gt; &lt;div&gt;my secret&lt;/div&gt; // showSecret이 true면 my secret을 보여주고 false면 보여주지 말아라. &lt;% &#125; %&gt; &lt;/body&gt;&lt;/html&gt; &lt;%= title %&gt; 을 사용하여서 데이터의 title을 가진 값을 집어 넣는다. Express에서 EJS 사용하기ejs 설치1$ npm install --save ejs template engine 설정1app.set('view engine', 'ejs') res.render()123456const data = &#123; title: 'Template Language', message: 'Hello EJS!', showSecret: true&#125;res.render('index.ejs', data) Serving Static Files 템플릿 파일에서 참조할 수 있다. 변하지 않는 파일들을 넣어서 보관해둔다.1234567// `public` 폴더에 있는 파일을 `/static` 경로 아래에서 제공app.set('view engine', 'ejs')app.use('/static', express.static('public'))&lt;!-- 템플릿 파일에서 참조할 수 있음 --&gt;&lt;link rel=\"stylesheet\" href=\"/static/index.css\"&gt;&lt;script type=\"text/javascript\" src=\"/static/index.js\"&gt;&lt;/script&gt;","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Template Language","slug":"Node-js/Template-Language","permalink":"http://yoursite.com/categories/Node-js/Template-Language/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"template Language","slug":"template-Language","permalink":"http://yoursite.com/tags/template-Language/"}]},{"title":"Node-Rest-API","slug":"node-study-restapi","date":"2017-08-28T03:54:00.000Z","updated":"2017-09-14T13:23:54.000Z","comments":true,"path":"2017/08/28/node-study-restapi/","link":"","permalink":"http://yoursite.com/2017/08/28/node-study-restapi/","excerpt":"","text":"Node Rest API 실습PostMan REST API를 시험해볼 수 있는 도구 다양한 편의기능 제공 Github Rest API https://api.github.com/users/KimSejune 나의 정보를 받아올수있다.Rest API link HTTP의 전송 GET/user/repo Authorization은 Basic, Digest, Bearer 3가지로 이루어져있다. Node.js NVM을 통하여 새로운 노드를 추가적으로 설치한다. nvm 설치방법curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash 터미널을 종료한 후에 123 export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 12345# 주석: `#`으로 시작하는 명령은 bash에서 무시됩니다.# 아래 명령을 한 줄씩 차례대로 입력하세요$ nvm install 8.4$ nvm use 8.4$ nvm alias default 8.4 # nvm-windows는 필요없음 다시 돌아가는 방법 nvm ls를 하고 nvm use system을 하면 원래사용하던 node로 돌아온다. nvm use default를 통해서 nvm으로 돌아온다. 1234567891011// 여러 줄에 나눠서 입력하기&gt; function factorial2(n) &#123;... return n &lt; 1 ? 1 : n * factorial(n-1)... &#125;undefined&gt; factorial2(4)24// `.exit`를 입력하거나 `Ctrl+C`를 두 번 입력해서 나가기&gt; .exit node.js module을 사용한다. 123456789// Node.js module 사용하기&gt; const os = require('os') // 급할땐 `os = ...`undefined&gt; os.platform()'darwin'&gt; os.freemem()658300928 운영체제에 상관없이 경로를 사용할 수 있게 해준다.node.js path api Node.js로 파일 실행시키기1$ node (파일 경로) Node js의 이론 node.js 는 js의 runtime이며 chrome의 Javascript V8 engine을 사용한다. event-drive, non-blocking I/O model을 사용한다. JavaSCript runtime js는 언어 js runtime은 js를 구동하기 위해 필요한 실행 환경 프로그래머는 런타임이 제공하는 도구를 응용해서 프로그램을 개발 웹 브라우저(chrome, edge)나 Node.js도 JavaScript 런타임의 일종 Chrome이 제공하는 웹 브라우저용 런타임 Node.js가 제공하는 서버용 런타임 MongoDB가 제공하는 데이터 처리용 런타임 Photoshop이 제공하는 전용 런타임 V8 JavaScript Engine JIT(Just-In-Time) compilation Code Optimization Used in Google Chrome Node.js MongoDB … js가 V8 js engine을 통하여 속도가 대폭 향상되었다. Event-driven Programming 프로그램의 흐름이 외부 요인에 의해 일어나는 사건에 의해 결정되는 프로그래밍 양식 약속된 방식으로 이벤트 핸들러를 작성함으로써 외부 이벤트가 일어났을 때 코드를 실행 마우스 입력 키보드 입력 다른 프로그램/컴퓨터로부터의 통신 123456789101112// DOM 이벤트 핸들러 등록 (웹 브라우저)domElement.addEventListener('click', function(e) &#123; e.stopPropagation() alert('hello')&#125;)// 서버도 똑같이 합니다.// (단, 프레임워크를 쓸 때는 직접 이벤트를 다룰 일이 별로 없음)// HTTP 응답 이벤트 핸들러 등록 (Node.js)httpResponse.on('data', data =&gt; &#123; console.log(data)&#125;) node.js를 할 때 직접적으로 이벤트를 다룰 일은 별로 없다. Non-blocking I/O Blocking I/O는 스레드가 입력/출력이 완료될 때까지 기다렸다가 다음 코드를 실행 Non-blocking I/O는 스레드가 입력/출력을 기다리지 않고 코드를 계속 실행 I/O 성능 향상 &amp; 복잡한 코드 Node.js Module123456789101112131415// name.js// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음module.exports = &#123; familyName: '김', givenName: '승하', fullName: function() &#123; return this.familyName + this.givenName &#125;&#125;// calc.js// `exports`로도 참조 가능exports.add = (x, y) =&gt; x + yexports.sub = (x, y) =&gt; x - y name.js에서 저장한 module.exports의 값들을 다른 파일에서 사용할 수 있게한다. module.exports 안에는 빈객체가 들어있어서 exports. ~~ 를해도 코드가 작동한다. module를 생략해도된다. 단) 객체를 통째로 생성할때는 module을 붙여준다. 123456789101112131415&gt; const name = require('./name.js')undefined&gt; name&#123; familyName: '김', givenName: '세준', fullName: [Function: fullName] &#125;&gt; name.familyName'김'&gt; name.givenName'세준'&gt; name.fullName[Function: fullName]&gt; name.fullName()'김세준'&gt; 객체를 내가원하는 함수에다가 바로 넘길수도 있다 ReceiveObjsct(require(&#39;./name.js&#39;)) node.js는 module마다 각각의 scope가 존재한다. 그래서 전역에다가 저장이 안되고 module scope에다가 저장을 한다. 다른 module에서 사용하려면 무조건 export안에 들어있어야한다. REPL에서 불러오기 Node.js 패키지 관리 도구 + 클라우드 패키지 저장소 의존 패키지 관리 스크립트 실행 패키지 설정 NPM에 패키지 배포 Node.js 종합 작업 도구 Hello NPM1234567891011121314151617$ mkdir hello-npm$ cd hello-npm$ npm init -y$ code .// package.json&#123; \"name\": \"hello-npm\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\"&#125; package.json 패키지 정보를 담고 있는 파일 dependencies npm install --save 명령으로 설치한 패키지가 기록됨 scripts 원래 목적은 패키지 생명주기마다 자동으로 실행되는 명령을 등록하기 위함이나, 개발자 편의를 위해 자주 사용되는 명령을 등록하는 용도로 더 많이 사용됨 1234567891011$ npm install --save randomstring # node_modules에 저장됨// index.jsconst randomstring = require('randomstring')console.log(randomstring.generate())// package.json... \"scripts\": &#123; \"start\": \"node index.js\" &#125;...$ npm start // start라는 이름으로 script에 등록을 하여서 실행시킬수있다. Concurrency(동시성)Concurrency Model(동시성 모델) 프로그램이 생애 주기가 겹치는 여러 실행 과정을 통해 실행된다 하더라도 프로그램의 결과에는 영향을 미치지 않는 성질 생애 주기가 겹치는 여러 실행 과정이 자원을 공유할 때 어떻게 충돌이 생기지 않도록 할 것인가? Resources CPU Memory Network thread 코드 실행의 가장 작은 단위 프로그램은 하나 이상의 스레드로 이루어짐 CPU 코어 하나는 한 번에 하나의 스레드를 실행 thread 확인방법 1$ sysctl -n hw.ncpu // 시스템의 코어개수 운영체제 차원의 도구 Process Thread Mutex (Mutual Exclusion) 언어 차원의 도구 Python - asyncio Go - goroutine Erlang - actor JavaScript - …? 자바스크립트의 동시성(Single-Threaded Event Loop) 자바스크립트를 실행시키는 스레드가 하나 뿐임 실행 과정(보통 콜백 연쇄)의 생애 주기가 겹칠 수는 있지만 어떤 경우에도 두 자바스크립트 실행과정이 동시에 실행되는 경우는 없음 내부적으로 메시지 큐를 활용하고 있으나, 모든 처리가 자동으로 이루어짐MDN 장점 프로그래머가 동시성에 대해 신경쓸 필요가 없어짐 프로그램 작성이 쉬워짐 단점 CPU를 많이 쓰는 작업에 부적절 오래 걸리는 자바스크립트 코드가 실행되면 전체 프로그램에 영향을 미침 전략 오래 걸리는 일은 외부에 위임하고 넘어간 뒤, 나중에 결과를 받아 처리하기 Database Node.js-External libraries Web browser - webAssembly 긴 실행과정을 여러개의 함수로 쪼개서한 번의 함수 실행이 금방 끝나게 만들기 Ascynchronous JavaScript non-blocking하고 비슷한 개념이다. 코드의 작성법에 대한 개념이다. Ascynchronous Callback 함수를 호출할 떄, 콜백까지 같이 인자에 넣어서 호출하는 비동기 프로그래밍 양식 콜백에서 에러 인자를 받는 방식으로 에러 처리를 함 Node.js 내장 모듈 전체가 이 방식을 사용하도록 만들어져 있음 모든 콜백이 비동기인 것은 아님 12&gt; [1,2,3].map(x =&gt; x*x)[ 1, 4, 9 ] 계산을 기다렸다가 바로 출력한다. readFile fs라는 file에 내장되어있다. 첫번째 인자를 err로 받는다. 123456789101112// readFile.js 비동기식 코드const fs = require('fs') // Node.js 내장 모듈fs.readFile('./calc.js', 'utf8', (err, data) =&gt; &#123; console.log(data)&#125;)console.log('done!')// readFileSync.js 동기식 코드const fs = require('fs') // Node.js 내장 모듈const data = fs.readFileSync('./calc.js', 'utf8')console.log(data)console.log('done!') try, catch는 동기식에서만 에러처리를 할 수 있다. request 설치12$ # hello-npm 폴더 안에서 실행$ npm install --save request Github REST API 호출123456789101112131415161718192021222324252627282930313233// 유저 이름, 저장소, 할당된 이슈 갯수 출력하기const request = require('request')const apiUrl = 'https://api.github.com'const option = &#123; json: true, auth: &#123; 'user': 'username', 'pass': 'password', &#125;, headers: &#123; 'User-Agent': 'request' &#125;&#125;request.get(`$&#123;apiUrl&#125;/user`, option, function (error, response, body) &#123; const name = body.name if (error) console.error(error) // 콜백 안에 콜백 request.get(`$&#123;apiUrl&#125;/user/repos`, option, function (error, response, body) &#123; if (error) console.error(error) const repoNames = body.map(item =&gt; item.name) // 콜백 안에 콜백 안에 콜백 request.get(`$&#123;apiUrl&#125;/issues`, option, function (error, response, body) &#123; if (error) console.error(error) const issueNum = body.length console.log(`name: $&#123;name&#125;`) console.log('repos:') repoNames.forEach(name =&gt; &#123; console.log(name) &#125;) console.log(`num of assigned issues: $&#123;issueNum&#125;`) &#125;) &#125;)&#125;) request function이 만든사람이 error, response, body 를 parameter로 받는다. Callback Hell Callback의 Hell을 방지하기 위해서 Promise를 사용한다. Promise 비동기 작업의 결과를 담는 객체 정확히 언제가 될지 모르지만, 결국 성공 또는 실패의 상태를 갖게 됨 12345678910111213141516171819// tenSec.jsmodule.exports = function tenSec(value) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(value) &#125;, 10000) &#125;)&#125;// REPL&gt; const tenSec = require('./tenSec')&gt; const p = tenSec(1)&gt; p // 만든지 10초가 지나기 전Promise &#123; [pending], ...&gt; p // 만든지 10초가 지난 후Promise &#123; 1, ... export안에 함수를 넣어서 값이 함수로 나온다. 12345678&gt; tenSec('hello promise').then(value =&gt; &#123;... console.log(value)... &#125;)Promise &#123; // `then`은 Promise를 반환 [pending], ...&gt; // 10초 후'hello promise' then안에서 promise를 return하면 promise를 벗기고 안의 값만 들어간다. 1234567891011121314151617181920212223// chaining.jsconst tenSec = require('./tenSec')tenSec('hello promise') .then(value =&gt; &#123; console.log(value) return 1 // 위 `.then`은 값이 1인 Promise를 반환함 &#125;) .then(value =&gt; &#123; console.log(value) return tenSec('new promise') // Promise도 반환할 수 있음 &#125;) .then(value =&gt; &#123; console.log(value) &#125;) .then(() =&gt; &#123; throw new Error('error in promise') &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) .then(() =&gt; &#123; // 에러 처리 이후에도 코드 실행 가능 console.log('done') &#125;) catch 앞의 then 부분에서 에러가 발생하면 catch안의 값이 실행된다. 맨 위의 then에서 에러가나면 바로 catch로 넘어간다. promise.all([…]) 배열안의 넘기는 값들이 모두 성공해야지 성공한다. promise.rase([…]) 배열안의 값중에서 먼저 성공한것을 나타낸다. readFile - promise node.js v8부터 새로들어온 함수이다. 1234567891011// readfilePromise.jsconst &#123;promisify&#125; = require('util') // Node.js 8.0.0부터 추가됨const fs = require('fs')const readFile = promisify(fs.readFile)readFile('./calc.js', 'utf8') .then(data =&gt; &#123; console.log(data) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 파일을 다읽으면 반환하는 promise파일을 반환한다. Promise의 특징 이미 resolve 된 Promise에도 콜백을 실행할 수 있음 12&gt; const resolved = Promise.resolve(1)&gt; resolved.then(v =&gt; console.log(v)) .then에 넘겨진 콜백은 무조건 다음 루프에 실행됨 12345678&gt; (function() &#123;... Promise.resolve(1).then(v =&gt; console.log(v))... console.log(&apos;done!&apos;)... &#125;)()/* 출력:done!1*/ Promise.all1234567891011121314151617181920212223242526272829// npm install --save request-promiseconst rp = require('request-promise')const apiUrl = 'https://api.github.com'const option = &#123; json: true, auth: &#123; 'user': 'username', 'pass': 'password', &#125;, headers: &#123; 'User-Agent': 'request' &#125;&#125;const userPromise = rp.get(`$&#123;apiUrl&#125;/user`, option)const reposPromise = rp.get(`$&#123;apiUrl&#125;/user/repos`, option)const issuesPromise = rp.get(`$&#123;apiUrl&#125;/issues`, option)// 배열 내의 모든 Promise 객체가 완료되었을 때// resolve 되는 Promise를 만든다.Promise.all([userPromise, reposPromise, issuesPromise]) .then(([user, repos, issues]) =&gt; &#123; console.log(`name: $&#123;user.name&#125;`) console.log('repos:') repos.forEach(repo =&gt; &#123; console.log(repo.name) &#125;) console.log(`num of assigned issues: $&#123;issues.length&#125;`) &#125;) axiosfetch api fetch api, axios를 통하여 Ajax통신을 promise를 통하여 통신을 할 수 있게한다. Async/Await javascript의 문법을 바꾸어버렸다. 비동기 코드를 동기식 코드처럼 편하게 짤 수 있게 만든 것이다. async function은 무조건 promise를 반환하며 await가 완료될때 까지 기다린다.12345678910const tenSec = require('./tenSec')async function resolveAfterTenSec() &#123; await tenSec() return 1&#125;resolveAfterTenSec().then(value =&gt; &#123; console.log(value)&#125;) ES2017에서 도입되어, 비동기식 코드를 동기식 코드처럼 쓸 수 있는 문법 제공 Chrome 55, Node.js 8.0.0 부터 사용가능 async function 안에서 반환된 값은 최종적으로 Promise 객체로 변환되어 반환된다. async function 안에서 쓸 수 있는 await 키워드는 현재 함수를 중단시키고 Promise 객체가 충족될 때까지 기다리지만, 스레드를 block 하지 않는다. 에러 처리는 동기식 코드처럼 try, catch 블록을 통해서 한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"},{"name":"Rest-API","slug":"Node-js/Rest-API","permalink":"http://yoursite.com/categories/Node-js/Rest-API/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"RestAPI","slug":"RestAPI","permalink":"http://yoursite.com/tags/RestAPI/"}]},{"title":"JavaScript Scope","slug":"js-study-scope","date":"2017-08-03T03:54:00.000Z","updated":"2017-11-07T12:35:46.000Z","comments":true,"path":"2017/08/03/js-study-scope/","link":"","permalink":"http://yoursite.com/2017/08/03/js-study-scope/","excerpt":"","text":"Javascript Scope 3.Function scope자바스크립트의 Scope 종류 전역Scope(Global scope) 코드 어디에서든지 참조할 수 있다. 지역Scope(Local scope or Function-level scope) 정의된 함수 내에서만 참조할 수 있다. 변수의 Scope 종류 전역 변수 (Global variable) 전역 Scope를 갖는 변수. 지역 변수 (Local variable) 지역 Scope를 갖는 변수 변수는 선언 위치(전역 또는 지역)에 의해 Scope를 가지게 된다. 즉 전역에서 선언된 변수는 전역 Scope를 갖는 전역 변수이고, 지역(자바스크립트의 경우 함수 내부)에서 선언된 변수는 지역 Scope를 갖는 지역 변수가 된다. 전역 Scope를 갖는 전역 변수는 전역(코드 어디서든지)에서 참조할 수 있다. 지역(함수 내부)에서 선언된 지역 변수는 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다. javascript는 함수 코드블럭만 지역Scope로 인식하며, 그 외는 전역 Scope이다. 12345678910111213var x = 0; // global&#123; var x = 1; // global console.log(x); // 1&#125;console.log(x); // 1let y = 0; // global&#123; let y = 1; // local console.log(y); // 1&#125;console.log(y); // 0 let은 block-level-scope를 지원한다. 1. Global scope 전역 변수는 전역 객체 window의 프로퍼티이다.1234567891011var global = 'global'; // 전역 변수function foo() &#123; // 전역 함수 var local = 'local'; // this로 선언하면 함수외부에서도 참조가가능하다 but var는 안된다. console.log(global); console.log(local);&#125;foo();console.log(global); // window.global을 해도 같은 값이 나온다. 편의상 없앴다.console.log(local); // Uncaught ReferenceError: local is not defined 함수내부에 this로 선언한 변수들은 public 외부에서 참조가 가능하며 var로 선언한 변수들은 private하여 외부에서 참조가 불가능하다. 2. Non block-level scope -&gt; Function-level scope1234if (true) &#123; var x = 5; // function이 아니니깐 global하다.&#125;console.log(x); // 5가 나온다. 3. Function scope12345678var a = 10; // 전역변수(function () &#123; // IIFE 즉시실행함수이다. var b = 20; // 지역변수&#125;)();console.log(a); // 10console.log(b); // \"b\" is not defined 자바스크립트는 function-level scope를 사용한다. 즉 함수 내에서 선언된 매개변수와 변수는 함수 외부에서는 유효하지 않다. 따라서 변수 b는 지역 변수이다. 1234567891011121314var x = 'global';function foo() &#123; var x = 'local'; console.log(x); function bar() &#123; // 내부함수 console.log(x); // local &#125; bar();&#125;foo();console.log(x); // global Scope 체이닝이 발생한다. = 실행 컨텍스트 내부함수는 자신을 포함하고 있는 외부함수의 변수에 접근할 수 있다. 이는 매우 유용하다. 클로저에서와 같이 내부함수가 더 오래 생존하는 경우, 타 언어와는 다른 움직임을 보인다. 123456789var x = 'global';function foo() &#123; var x = 'local'; console.log(x);&#125;foo(); // localconsole.log(x); // global 123456789var x = 10;function foo() &#123; x = 100; console.log(x);&#125;foo(); // 100console.log(x); // 100 Q. 왜 100인가요?? 숫자는 지역값을 가져오나요? // A. 내부함수에 var가아닌 전역으로 선언해서 그렇다. 123456789101112131415var foo = function ( ) &#123; var a = 3, b = 5; var bar = function ( ) &#123; var b = 7, c = 11;// 이 시점에서 a는 3, b는 7, c는 11 a += b + c;// 이 시점에서 a는 21, b는 7, c는 11 &#125;;// 이 시점에서 a는 3, b는 5, c는 not defined bar( );// 이 시점에서 a는 21, b는 5 -&gt; a가 참조되어서 bar안에서 변경되서 a=21이며 b는 내부함수껏을 사용못하니깐 5이다.&#125;; 4. 암묵적 전역 var 키워드없이 선언을 하면 암묵적으로 전역번수가 된다. 5. Lexical scoping (Static scoping)123456789101112var i = 5;function foo() &#123; var i = 10; bar();&#125;function bar() &#123; // 선언된 시점에서의 scope를 갖는다! console.log(i);&#125;foo(); // 5 bar와 foo가 각각 scope이기에 bar는 전역변수 i=5를 가져와서 출력한다. 6. 변수명의 중복 i값이 서로 전역변수로 중복이 되기에 조심해야한다. 전역변수를 반드시 사용하여야 할 이유를 찾지 못한다면 지역변수를 사용하여야 한다. 변수의 범위인 스코프는 좁을수록 좋다. 7. 최소한의 전역변수 사용 전역변수 사용을 최소화하는 방법 중 하나는 애플리케이션에서 전역변수 사용을 위해 다음과 같이 전역변수 객체 하나를 만들어 사용하는 것이다. 12345678var MYAPP = &#123;&#125;;MYAPP.student = &#123; name: 'Lee', gender: 'male'&#125;;console.log(MYAPP.student.name); 8. 즉시실행함수를 이용한 전역변수 사용 억제 전역변수 사용을 억제하기 위해, 즉시 실행 함수(IIFE, Immediately-Invoked Function Expression)를 사용할 수 있다. 즉시 실행 함수는 즉시 실행되고 그 후 전역에서 바로 사라진다. 123456789101112(function () &#123; var MYAPP = &#123;&#125;; MYAPP.student = &#123; name: 'Lee', gender: 'male' &#125;; console.log(MYAPP.student.name); //사용가능&#125;());console.log(MYAPP.student.name); // 여기서 사용안된다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Scope","slug":"JavaScript/Scope","permalink":"http://yoursite.com/categories/JavaScript/Scope/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Scope","slug":"Scope","permalink":"http://yoursite.com/tags/Scope/"}]},{"title":"JavaScript This","slug":"js-study-this","date":"2017-08-03T03:54:00.000Z","updated":"2017-11-10T12:53:01.000Z","comments":true,"path":"2017/08/03/js-study-this/","link":"","permalink":"http://yoursite.com/2017/08/03/js-study-this/","excerpt":"","text":"Javascript this 자바스크립트의 함수는 호출될 때, 매개변수로 전달되는 인자값 이외에, arguments 객체와 this를 암묵적으로 전달 받는다. 12345678910function square(number) &#123; console.log(arguments); console.log(this); // browser에서는 window로 node에서는 global로 출력된다. // 전역이다. return number * number;&#125;var result = square(); This는 특별한 상황 2가지를 제외한 경우는 모두 전역변수를 의미한다. 예외 1. method로 호출될때 호출한 것이 this로 사용된다./ method의 내부함수도 전역 변수이다. 예외 2. 생성자 함수에서 생성된 객체의 경우 this는 생성자 함수가 생성할 객체를 가르킨다. 자바스크립트의 경우 자바와 같이 this에 바인딩되는 객체는 한가지가 아니라 해당 함수 호출 패턴에 따라 this에 바인딩되는 객체가 달라진다. 함수 호출 패턴과 this 바인딩 메소드 호출 패턴(Method Invocation Pattern) 함수 호출 패턴(Function Invocation Pattern) 생성자 호출 패턴(Constructor Invocation Pattern) apply 호출 패턴(Apply Invocation Pattern) 1. 메소드 호출 패턴(Method Invocation Pattern) this는 그 method를 소유한 객체를 가르킨다. 즉 그 method를 호출한 객체를 가르킨다. 123456789101112131415var obj1 = &#123; name: 'Lee', sayName: function() &#123; console.log(this.name); &#125;&#125;var obj2 = &#123; name: 'Kim'&#125;obj2.sayName = obj1.sayName;obj1.sayName(); // Leeobj2.sayName(); // kim 프로토타입 객체도 메소드를 가질 수 있다. 프로토타입 객체 메소드 내부에서 사용된 this도 일반 메소드 방식과 마찬가지로 해당 메소드를 호출한 객체에 바인딩된다. 즉 함수를 부른 객체에 적용이된다. Q. obj2에는 sayName함수가없는데 이것은 obj2proto, obj1proto가 같아서인가요?? 아니면 무슨이유인가요? A. this의 특징인 method를 호출한 객체를 가르키기 때문이다. 12345678910111213function Person(name) &#123; this.name = name;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;var me = new Person('Lee');console.log(me.getName()); // Lee -&gt; method를 호출한 객체를 가르키기 때문이다.Person.prototype.name = 'Kim';console.log(Person.prototype.getName()); // kim 2. 함수 호출 패턴(Function Invocation Pattern) 전역객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window, Server-side(Node.js)에서는 global 객체를 의미한다. 기본적으로 this는 전역객체(Global object)에 바인딩된다. 전역함수는 물론이고 심지어 내부함수의 경우도 this는 외부함수가 아닌 전역객체에 바인딩된다. method 내부의 내부함수의 this도 전역을 가르킨다. (설계상 결점) 12345678910111213141516var value = 1;var obj = &#123; value: 100, foo: function() &#123; console.log(\"foo's this: \", this); // obj console.log(\"foo's this.value: \", this.value); // 100 function bar() &#123; console.log(\"bar's this: \", this); // window console.log(\"bar's this.value: \", this.value); // 1 &#125; bar(); &#125;&#125;;obj.foo(); 콜백함수의 경우에도 this는 전역객체에 바인딩된다.(설계적 결함) 12345678910111213var value = 1;var obj = &#123; value: 100, foo: function() &#123; setTimeout(function() &#123; console.log(\"callback's this: \", this); // window console.log(\"callback's this.value: \", this.value); // 1 &#125;, 100); &#125;&#125;;obj.foo(); this의 전역객체 회피방법 12345678910111213141516171819var value = 1;var obj = &#123; value: 100, foo: function() &#123; var that = this; // Workaround : this === obj console.log(\"foo's this: \", this); // obj console.log(\"foo's this.value: \", this.value); // 100 function bar() &#123; console.log(\"bar's this: \", this); // window console.log(\"bar's this.value: \", this.value); // 1 console.log(\"bar's that: \", that); // obj console.log(\"bar's that.value: \", that.value); // 100 &#125; bar(); &#125;&#125;; var that = this; 여기서 this는 obj이다 즉 that은 obj이므로 이상해지면 that을 써준다. 3. 생성자 호출 패턴(Constructor Invocation Pattern) 생성자 함수를 생성시 new를 쓴것과 안쓴것은 차이가 있다. 3.1 생성자 함수 동작 방식 빈 객체 생성 및 this 바인딩 this를 통한 프로퍼티 생성 생성된 객체 반환 생성자 함수 내부에는 return을 안써주는 것이다. 암묵적으로 해주기에 안써주는것이다 쓰면 코드가 꼬인다. this는 생성자 함수가 생성할 객체를 가르킨다. 12345678var Person = function(name) &#123; // 생성자 함수 코드 실행 전 -------- 1 this.name = name; // --------- 2 // 생성된 함수 반환 -------------- 3&#125;var me = new Person('Lee');console.log(me.name); 3.3 생성자 함수에 new 연산자를 붙이지 않고 호출할 경우1234567891011var Person = function(name) &#123; // 전역객체에 name 프로퍼티를 추가 this.name = name;&#125;;// 일반 함수로서 호출되었기 때문에 객체를 생성하여 반환하지 않는다.// 일반 함수의 this는 전역객체를 가리킨다.var me = Person('Lee');console.log(me); // undefinedconsole.log(window.name); // Lee me에다가 값이 들어가지 않고 window에 값이 들어간다. 방어코드를 작성해서 new를 빼먹는 경우를 방어한다. 1234567891011121314151617181920// Scope-Safe Constructor Patternfunction A(arg) &#123; // 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈객체를 생성하고 this에 바인딩한다. /* this가 호출된 함수(arguments.callee, 본 예제의 경우 A)의 인스턴스가 아니면 new 연산자를 사용하지 않은 것이므로 이 경우 new와 함께 생성자 함수를 호출하여 인스턴스를 반환한다. arguments.callee는 호출된 함수의 이름을 나타낸다. 이 예제의 경우 A로 표기하여도 문제없이 동작하지만 특정함수의 이름과 의존성을 없애기 위해서 arguments.callee를 사용하는 것이 좋다. */ if (!(this instanceof arguments.callee)) &#123; // A에 의해 생성된 객체가 아니라면 return new arguments.callee(arg); // 강제로 new를 붙인다. &#125; this.value = arg ? arg : 0;&#125;var a = new A(100);var b = A(10);console.log(a.value);console.log(b.value); argument.callee는 생성자의 이름이 나타난다. 4. apply 호출 패턴(Apply Invocation Pattern) 유사배열 : 유사배열은 배열이아닌 객체라서 배열처럼 불를수있지만 원래의 순서가 보장이 안된다. func.apply는 func의 양부인 Function.prototype 객체의 메소드이다. []는 option을 나타낸다. 1234func.apply(thisArg, [argsArray])// thisArg: 함수 내부의 this에 바인딩할 객체// argsArray: 함수에 전달할 인자 배열 12345678910var Person = function (name) &#123; this.name = name;&#125;;var foo = &#123;&#125;;// apply 메소드는 생성자함수 Person을 호출한다. 이때 this에 객체 foo를 바인딩한다.Person.apply(foo, ['name']); // this로 쓸 객체 = foo, name은 Person의 인자배열 / call은 , 로 구분해서준다.console.log(foo); // &#123; name: 'name' &#125; 1234567891011121314function convertArgsToArray() &#123; console.log(arguments); // arguments 객체를 배열로 변환 // slice: 배열의 특정 부분에 대한 복사본을 생성한다. var arr = Array.prototype.slice.apply(arguments); // arguments.slice // var arr = [].slice.apply(arguments); // argument를 Array로 변환해서 arr에 저장해준다. console.log(arr); return arr;&#125;convertArgsToArray(1, 2, 3); argumetns 객체는 배열 객체는 아닌데 slice를 쓰게해달라고 해주는게 apply이다 그래서 배열객체의.prototype에 .apply를 통해서 argument가 쓰게해준다. 123Person.apply(foo, [1, 2, 3]);Person.call(foo, 1, 2, 3); call과 apply의 차이는 배열이냐 , 이냐의 차이이다. 1234567891011121314151617function Person(name) &#123; this.name = name;&#125;Person.prototype.doSomething = function(callback) &#123; if(typeof callback == 'function') &#123; // --------- 1 여기서 this는 method안에서 작동하니 Person을 가르킨다. callback(); &#125;&#125;;function foo() &#123; console.log(this.name); // --------- 2 전역 this&#125;var p = new Person('Lee');p.doSomething(foo); // undefined callback함수에다가 직접적으로 call에 this를 명시해줘서 일반함수가 callback을 사용할 수 있게 해준다. 12345678910111213141516function Person(name) &#123; this.name = name;&#125;Person.prototype.doSomething = function(callback) &#123; if(typeof callback == 'function') &#123; callback.call(this); &#125;&#125;;function foo() &#123; console.log(this.name);&#125;var p = new Person('Lee');p.doSomething(foo); // 'Lee'","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"This","slug":"JavaScript/This","permalink":"http://yoursite.com/categories/JavaScript/This/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"This","slug":"This","permalink":"http://yoursite.com/tags/This/"}]},{"title":"JavaScript Immutability","slug":"js-study-immutability","date":"2017-08-01T03:54:00.000Z","updated":"2017-11-06T13:38:45.000Z","comments":true,"path":"2017/08/01/js-study-immutability/","link":"","permalink":"http://yoursite.com/2017/08/01/js-study-immutability/","excerpt":"","text":"Javascript Immutability Immutability(변경불가성)이란? 객체가 생성된 이후 그 상태를 변경할 수 없는 디자인 패턴을 의미한다.레퍼런스를 참조한 다른 객체에서 객체를 변경하는 상황을 해결하는 방법 객체를 불변객체로 만들어 프로퍼티의 변경을 방지하며 객체의 변경이 필요한 경우에는 참조가 아닌 객체의 방어적 복사(defensive copy)를 통해 새로운 객체를 생성한 후 변경한다. 또는 Observer 패턴으로 객체의 변경에 대처할 수도 있다. Observer 패턴으로 객체의 변경에 대처할 수도 있다.Observer; 데이터 타입이 필요한이유 ? 메모리를 효율적으로 사용하기 위해서 1. immutable value vs. mutable value Javascript의 기본 자료형(primitive data type)은 변경 불가능한 값(immutable value)이다. Boolean null undefined Number String Symbol (New in ECMAScript 6) 객체 타입은 변경 가능한 값(mutable value)이다. 즉 객체는 새로운 값을 다시 만들 필요없이 직접 변경이 가능하다는 것이다. 123456var statement = 'I am an immutable value'; // string은 immutable valuevar otherStr = statement.slice(8, 17);console.log(otherStr); // 'immutable'console.log(statement); // 'I am an immutable value' slice() 메서드는 statement 변수에 저장된 문자열을 변경하는 것이 아니라 사실은 새로운 문자열을 생성하여 반환하고 있다.(immutable value) 12345var arr = [];console.log(arr.length); // 0var v2 = arr.push(2); // arr.push()는 메서드 실행 후 arr의 length를 반환console.log(arr.length); // 1 처리 후 결과의 복사본을 리턴하는 문자열의 메서드 slice()와는 달리 배열(객체)의 메서드 push()는 직접 대상 배열을 변경한다. 그 이유는 배열은 객체이고 객체는 immutable value가 아닌 변경 가능한 값이기 때문이다. 123456789101112131415var user = &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125;&#125;;var myName = user.name; // 변수 myName은 string 타입이다.// myName은 기본형이라서 user.name을 참조가아닌 복사를한다. user.name = 'Kim'; console.log(myName); // Lee -&gt; myName은 참조가아닌 복사를 하기때문에 kim이 반영이안됬다.myName = user.name; // 재할당console.log(myName); // Kim user.name의 값을 변경했지만 변수 myName의 값은 변경되지 않았다. 이는 user.name의 타입 string이 변경 불가능하기 때문이다. myName은 기본형으로써 값을 pass-by-value(복사)하기 때문에 user.name=’kim’이 바로 반영되지 않는다. 12345678910111213var user1 = &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125;&#125;;var user2 = user1; // user1이라는 객체를 pass-by-reference한것이다 변수 user2는 객체 타입이다.user2.name = 'Kim';console.log(user1.name); // Kimconsole.log(user2.name); // Kim var user2 = user1으로 인해서 user2가 객체 타입으로 변했기에 참조형으로 반영된다. 객체를 변경못하게 불변객체로 만들어야한다. 2. 불변 데이터 패턴(immutable data pattern) 의도하지 않은 객체의 변경을 막는 방법 : 객체를 불변객체로 만들어 프로퍼티의 변경을 방지하며 객체의 변경이 필요한 경우에는 참조가 아닌 객체의 방어적 복사(defensive copy)를 통해 새로운 객체를 생성한 후 변경한다. 2.1 Obejct.assign Object.assign은 타킷 객체로 소스 객체의 프로퍼티를 복사한다. 소스 객체의 프로퍼티와 동일한 프로퍼티를 가진 타켓 객체의 프로퍼티들은 소스 객체의 프로퍼티로 덮어쓰기된다. 리턴값으로 타킷 객체를 반환한다. copy의 역할을 한다. 12345678910111213141516171819202122232425// Copyconst obj = &#123; a: 1 &#125;;const copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125;console.log(obj == copy); // false// Mergeconst o1 = &#123; a: 1 &#125;;const o2 = &#123; b: 2 &#125;;const o3 = &#123; c: 3 &#125;;const merge1 = Object.assign(o1, o2, o3);console.log(merge1); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, 타겟 객체가 변경된다!// Mergeconst o4 = &#123; a: 1 &#125;;const o5 = &#123; b: 2 &#125;;const o6 = &#123; c: 3 &#125;;const merge2 = Object.assign(&#123;&#125;, o4, o5, o6);console.log(merge2); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o4); // &#123; a: 1 &#125; Object.assign을 사용하여 기존 객체를 변경하지 않고 객체를 복사하여 사용할 수 있다. 1234567891011121314151617const user1 = &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125;&#125;;const user2 = Object.assign(&#123;&#125;, user1); // user1을 &#123;&#125;에 Copyuser2.name = 'Kim';// 상기 2행은 아래와 동치이다.// &#123;name: 'Kim'&#125;은 user1에 병합되는 것이 아니라 첫번째 인자인 &#123;&#125;에 병합된다.// const user2 = Object.assign(&#123;&#125;, user1, &#123;name: 'Kim'&#125;);console.log(user1.name); // Leeconsole.log(user2.name); // Kim user1 객체를 빈객체에 복사하여 새로운 객체 user2를 생성하였다. user1과 user2는 어드레스를 공유하지 않으므로 한 객체를 변경하여도 다른 객체에 아무런 영향을 주지 않는다. 주의할 것은 user1 객체는 const로 선언되어 재할당은 할 수 없지만 객체의 프로퍼티는 보호되지 않는다. 다시 말하자면 객체의 내용은 변경할 수 있다. 2.2 Objet.freeze Object.freeze()를 사용하여 불변(immutable) 객체로 만들수 있다. 객체 내부의 객체는 얼리지 못한다. 12345678910111213141516171819const user1 = &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125;&#125;;const user2 = Object.assign(&#123;&#125;, user1, &#123;name: 'Kim'&#125;);console.log(user1.name); // Leeconsole.log(user2.name); // KimObject.freeze(user1);user1.name = 'Kim'; // 무시된다!console.log(user1); // &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125; &#125;console.log(Object.isFrozen(user1)); // true 하지만 객체 내부의 객체(Nested Object)는 변경가능하다. 즉 메소드의 내부내용은 변경가능하다. 1234567891011const user = &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125;&#125;;Object.freeze(user);user.address.city = 'Busan'; // 변경된다!console.log(user); // &#123; name: 'Lee', address: &#123; city: 'Busan' &#125; &#125; 내부 객체까지 변경 불가능하게 만들려면 Deep freeze를 하여야 한다. 12345678910111213141516171819202122232425function deepFreeze(obj) &#123; const props = Object.getOwnPropertyNames(obj); props.forEach((name) =&gt; &#123; const prop = obj[name]; if(typeof prop === 'object' &amp;&amp; prop !== null) &#123; deepFreeze(prop); &#125; &#125;); return Object.freeze(obj);&#125;const user = &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125;&#125;;deepFreeze(user);user.name = 'Kim'; // 무시된다user.address.city = 'Busan'; // 무시된다console.log(user); // &#123; name: 'Lee', address: &#123; city: 'Seoul' &#125; &#125; 2.3 Immutable.js 또 다른 대안으로 Facebook이 제공하는 Immutable.js를 사용하는 방법이 있다. Immutable.js는 List, Stack, Map, OrderedMap, Set, OrderedSet, Record와 같은 영구 불변 (Permit Immutable) 데이터 구조를 제공한다. npm으로 설치한다. 1npm install immutable Immutable.js의 Map 모듈을 임포트하여 사용한다. 12345const &#123; Map &#125; = require('immutable')const map1 = Map(&#123; a: 1, b: 2, c: 3 &#125;)const map2 = map1.set('b', 50)map1.get('b') // 2map2.get('b') // 50 map1.set(‘b’, 50)의 실행에도 불구하고 map1은 불변하였다. map1.set()은 결과를 반영한 새로운 객체를 반환한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Immutability","slug":"JavaScript/Immutability","permalink":"http://yoursite.com/categories/JavaScript/Immutability/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Immutability","slug":"Immutability","permalink":"http://yoursite.com/tags/Immutability/"}]},{"title":"JavaScript Prototype","slug":"js-study-prototype","date":"2017-08-01T03:54:00.000Z","updated":"2017-11-07T12:37:50.000Z","comments":true,"path":"2017/08/01/js-study-prototype/","link":"","permalink":"http://yoursite.com/2017/08/01/js-study-prototype/","excerpt":"","text":"Javascript Prototype12345678function Person(name) &#123; this.name = name; this.sayHello = function()&#123; console.log(this.name); &#125;&#125;var foo = new Person('Lee'); foo의 property는 name, sayHello를 가진다. name은 primitive(기본값이라서) = Lee가 존재하며 sayHello는 객체라서 참조가 되는것(참조값 func이 존재만한다)이지 바로저장되지는 않는다.foo가 친부를 찾을때는 foo.__proto__.costructor도 되지만 foo.constructor(표준)를 사용하면 프로토타입 체이닝에 의해서 Person.prototype의 property를 사용하여서 Person() 생성자 함수를 찾을 수 있다. 함수는 일반 객체와 달리 prototype이라는 property를 가지는데 자신이 생성한 객체의 아버지를 가르킨다. 1. 프로토타입 객체 자바스크립트의 모든 객체는 부모가 존재한다. Prototype 기반 객체로 나타낸다. 123456789var student = &#123; name: 'Lee', score: 90&#125;;// student에는 hasOwnProperty 메서드가 없지만 아래 구문은 동작한다.console.log(student.hasOwnProperty('name')); // trueconsole.dir(student); // student의 dir을 본다. hasOwnProperty는 obejct 객체안에 존재하기에 사용가능하다. 함수가 아니여서 prototype이 존재하지 않는다. __proto__ 와 [[Prototype]]은 같은 개념이다. student.__proto__ === Object.prototype // true이다. 2. [[Prototype]] 프로퍼티 vs prototype 프로퍼티 [[Prototype]] 프러퍼티는 자신의 프로토타입 객체를 가리키는 숨겨진 프로퍼티이다. [[Prototype]] 프로퍼티는 __proto__ 프로퍼티로 구현되어 있어 __proto__과 [[Prototype]]은 같은 개념이다. 함수도 객체이므로 [[Prototype]] 프로퍼티를 갖는다. 그런데 함수 객체는 일반 객체와는 달리 prototype 프로퍼티도 소유하게 된다. 함수객체는 일반객체와 달리 호출할 수 있다. prototype 프로퍼티는 함수를 생성하는 생성자가 가르키는 것을 나타내고 [[Prototype]] 프로퍼티는 생성자로 생성한 함수가 가르키는것을 나타낸다 모두 프로토타입 객체를 가리키지만 관점의 차이가 있다. 12345678function Person(name) &#123; this.name = name;&#125;var foo = new Person('Lee');console.dir(Person); // prototype 프로퍼티가 있다. / Person.prototype이 존재한다.console.dir(foo); // prototype 프로퍼티가 없다. [[Prototype]]프로퍼티 함수를 포함한 모든 객체가 가지고 있는 프로퍼티이다. 객체의 입장에서 자신의 양부 역할을 하는 프로토타입 객체을 가리키며 함수 객체의 경우 Function.prototype를 가리킨다. 123console.log(Person.__proto__ === Function.prototype);// Person의 부모는 Function.prototype이다. Funtion이라는 생성자가 존재한다.// Function 생성자함수는 Person의 친부모이다. Function.prototype의 __proto__는 Object.prototype이다. prototype 프로퍼티 함수 객체만 가지고 있는 프로퍼티이다. 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성될 객체의 부모 역할을 하는 객체(프로토타입 객체)를 가리킨다 1console.log(Person.prototype === foo.__proto__); 3. constructor 프로퍼티 프로토타입 객체는 constructor 프로퍼티를 갖는다. constructor 프로퍼티는 생성된 함수의 입장에서 생성자 함수를 찾아가기 위한 프로퍼티이다. 1234567891011121314function Person(name) &#123; this.name = name;&#125;var foo = new Person('Lee');// Person() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Person() 생성자 함수이다.console.log(Person.prototype.constructor === Person);// foo 객체를 생성한 객체는 Person() 생성자 함수이다. prototype chaining이다.console.log(foo.constructor === Person);// Person() 생성자 함수를 생성한 객체는 Function() 생성자 함수이다.console.log(Person.constructor === Function); 4. Prototype chain 해당객체의 property가 있는지 여부를 찾고 없으면 proto를 찾아서 부모에 있는지 살핀다. 이것이 프로토타입 객체 상속의 핵심이다. 4.1 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인 객체 생성 방법은 3가지이다. 객체 리터럴 생성자 함수 -&gt; 생성자.prototype으로 생성된다. Object() 생성자 함수 -&gt; 객체 리터럴로 생성하면 내부적으로 Object 생성자 함수로 객체가 생성된다. Object.prototype으로 생성된다. 함수 객체인 Object() 생성자 함수는 일반 객체와 달리 prototype 프로퍼티가 있다. 1234567891011121314var person = &#123; name: 'Lee', gender: 'male', sayHello: function()&#123; console.log('Hi! my name is ' + this.name); &#125;&#125;;console.dir(person);console.log(person.__proto__ === Object.prototype); // ① trueconsole.log(Object.prototype.constructor === Object); // ② trueconsole.log(Object.__proto__ === Function.prototype); // ③ trueconsole.log(Function.prototype.__proto__ === Object.prototype); // ④ true ; 결론적으로 객체 리터럴을 사용하여 객체를 생성한 경우 Object생성자로 객체를 생성한다. 그래서 객체의 프로토타입 객체는 Object.prototype이다. 4.2 생성자 함수로 생성된 객체의 프로토타입 체인 생성자 함수로 객체를 생성하기 위해서는 우선 생성자 함수를 정의하여야 한다. 함수를 정의하는 방식은 3가지 있다. 함수선언식 함수표현식 Function() 생성자 -&gt; 결론적으로 이걸로 내부에 생성된다. 123456789101112131415161718function Person(name, gender) &#123; this.name = name; this.gender = gender; this.sayHello = function()&#123; console.log('Hi! my name is ' + this.name); &#125;;&#125;var foo = new Person('Lee', 'male');console.dir(Person);console.dir(foo);console.log(foo.__proto__ === Person.prototype); // ① trueconsole.log(Person.prototype.__proto__ === Object.prototype); // ② trueconsole.log(Person.prototype.constructor === Person); // ③ trueconsole.log(Person.__proto__ === Function.prototype); // ④ trueconsole.log(Function.prototype.__proto__ === Object.prototype); // ⑤ true 생성자 함수에는 method 만들지말고 생성자.prototype에다가 method를 만들어라.불필요한 중복을 줄이기 위해서 이다. Obejct.prototype객체를 프로토타입 체인의 종점이라고 한다. 5. 프로토타입 객체의 확장 프로토타입 객체도 객체이므로 프로퍼티를 추가/삭제할 수 있다. 1234567891011function Person(name) &#123; this.name = name;&#125;var foo = new Person('Lee');Person.prototype.sayHello = function()&#123; console.log('Hi! my name is ' + this.name);&#125;; // foo 객체를 생성한 이후에 함수를 추가해도 되고 전에 써도 된다.foo.sayHello(); Person.prototype은 생성자 함수를 생성할때 즉 new를 사용할때 생성된다. 6. 기본자료형(Primitive data type)의 확장 자바스크립트에서 기본자료형(숫자, 문자열, boolean, null, undefined)을 제외한 모든것은 객체이다. 123456789101112var str = 'test'; // 리터럴 방식console.log(typeof str); // stringconsole.log(str.constructor === String); // trueconsole.dir(str);var strObj = new String('test'); // 객체형으로 생성console.log(typeof strObj); // objectconsole.log(strObj.constructor === String); // trueconsole.dir(strObj);console.log(str.toUpperCase()); // TESTconsole.log(strObj.toUpperCase()); // TEST 기본자료형은 상속개념이 없지만 객체는 상속개념이 있다. console.log(strObj.constructor === String); 를하면 기본자료형을 순간적으로 객체형으로 바꿔줬다가 다시 기본자료형으로 돌아온다. 그래서 str.toUpperCase()를 사용할 수 있다. String, Number은 이방식을 사용할 때가 있다. 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다. 기본자료형은 객체가 아니므로 프로퍼티나 메소드를 직접 추가할 수 없다.(에러발생은 않는다.) -&gt; 해결책 : 직접하면된다 String.prototype.myMethod 값을 공유함으로써 효율적인 메모리 사용이 가능해진다. 123456789var str = 'test';String.prototype.myMethod = function () &#123; // 이것을 통해서 직접추가가능 단 조심해야한다. return 'myMethod';&#125;;console.log(str.myMethod()); // myMethodconsole.log('string'.myMethod()); // myMethodconsole.dir(String.prototype); 표준이 아닌곳에 추가를 하기 때문에 옳은 방법은 아니다. 따로 모아서 만드는 것이 좋다. myLibrary라는 객체를 만들어서 사용하는 것이 좋다. 7. 프로토타입 객체의 변경 상속을 변경하고 싶을 경우 사용한다. 프로토타입 객체 변경 시점 이전에 생성된 객체기존 프로토타입 객체를 [[Prototype]] 프로퍼티에 바인딩한다. 프로토타입 객체 변경 시점 이후에 생성된 객체변경된 프로토타입 객체를 [[Prototype]] 프로퍼티에 바인딩한다. 12345678910111213141516function Person(name) &#123; this.name = name;&#125;var foo = new Person('Lee');// 프로토타입 객체의 변경Person.prototype = &#123; gender: 'male' &#125;;var bar = new Person('Kim');console.log(foo.gender); // undefinedconsole.log(bar.gender); // 'male'console.log(foo.constructor); // ① Person(name)console.log(bar.constructor); // ② Object() 프로토타입 객체 변경 후 constructor가 깨지기 때문에 이렇게는 하지않는다. prototype에 method가 아닌 객체의 변경이 이루어져서 깨진다. Q. 프로토타입 객체 변경 전 : foo.constructor가 Person(name)을 가르킨다는게 무슨이야기인지 모르겠습니다. Person.prototype.constructor가 Person() 생성자 함수아닌가요?? A. foo.constructor은 foo가 양부의 property를 사용하기에 가르킬수 있다. 8. 프로토타입 체인 동작 조건 객체의 프로퍼티를 참조하는 경우, 해당 객체에 프로퍼티가 없는 경우, 프로포타입 체인이 동작한다. 123456789101112131415161718function Person(name) &#123; this.name = name;&#125;Person.prototype.gender = 'male'; // ①var foo = new Person('Lee');var bar = new Person('Kim');console.log(foo.gender); // ① 'male'console.log(bar.gender); // ① 'male'// 1. foo 객체에 gender 프로퍼티가 없으면 프로퍼티 동적 추가// 2. foo 객체에 gender 프로퍼티가 있으면 해당 프로퍼티에 값 할당foo.gender = 'female'; // ②console.log(foo.gender); // ② 'female'console.log(bar.gender); // ① 'male'","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Prototype","slug":"JavaScript/Prototype","permalink":"http://yoursite.com/categories/JavaScript/Prototype/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Prototype","slug":"Prototype","permalink":"http://yoursite.com/tags/Prototype/"}]},{"title":"JavaScript Function","slug":"js-study-function","date":"2017-08-01T03:54:00.000Z","updated":"2017-11-05T04:25:05.000Z","comments":true,"path":"2017/08/01/js-study-function/","link":"","permalink":"http://yoursite.com/2017/08/01/js-study-function/","excerpt":"","text":"Javascript Function 함수란 어떤 특정 작업을 수행하기 위해 필요한 일련의 구문들을 그룹화하기 위한 개념이다.(코드의 재사용) 함수의 기능 특정 작업을 수행하는 구문들의 집합을 정의하고 필요시에 호출하여 필요한 값 또는 수행 결과를 얻는다. 객체 생성, 객체의 행위 지정(메서드) 정보의 구성 및 은닉, 클로저, 모듈화 등의 기능을 수행할 수 있다. 함수는 구문(statement)의 집합으로 모듈화의 근간이 된다. 함수도 객체이다. 다른 객체와 구분될 수 있는 특징은 호출할 수 있다는 것이다. 변수나 객체, 배열 등에 저장될 수 있고 다른 함수에 전달되는 인수로도 사용될 수 있으며 함수의 반환값이 될 수도 있다. 호출 : 함수를 실행시키는 행위 1. 함수 정의 함수선언식(Function declaration) 함수표현식(Function expression) Function() 생성자 함수 1.1 함수선언식(Function declaration) 함수선언식을 사용한 함수 정의는 function 키워드와 이하의 내용으로 구성된다. 함수명 : 함수명은 생략할 수 없다. 식별자의 역할을 한다. 매개변수 목록 : 0개 이상의 목록으로 괄호로 감싸고 콤마로 분리한다. 자료형 체크가 필요할 수 있다. tpyeof로 자료형을 체크한다. typeof num===’number’ &amp;&amp; !!num 이렇게 비교한다. 함수 몸체 : 중괄호({ })로 구문들을 감싸고 return 문으로 결과값을 반환할 수 있다. 이를 반환값(return value)라 한다. 123 function square(number) &#123; return number * number;&#125; number = 매개변수 = parameter 1.2 함수표현식(Function expression) 자바스크립트의 함수는 일급객체이다. 무명의 리터럴로 표현이 가능하다. 변수나 자료 구조(객체, 배열…)에 저장할 수 있다. 함수의 파라미터로 전달할 수 있다. 반환값(return value)으로 사용할 수 있다. 함수표현식이란? 함수 리터럴 방식으로 함수를 정의하고 변수에 할당하는 방식이다. 123var square = function(number) &#123; return number * number;&#125;; 함수표현식으로 정의한 함수는 함수명을 생략할 수 있다. 이러한 함수를 익명 함수(anonymous function)이라 한다. 1234567891011// 기명 함수표현식(named function expression) 재귀함수, 디버그var foo = function multiply(a, b) &#123; return a * b;&#125;;// 익명 함수표현식(anonymous function expression)var bar = function(a, b) &#123; return a * b;&#125;;console.log(foo(10, 5)); // 50console.log(multiply(10, 5)); // Uncaught ReferenceError: multiply is not defined 함수 호출시 변수가 함수명처럼 사용된다. 함수가 할당된 변수를 사용해 함수를 호출하지 않고 기명 함수의 함수명을 사용해 호출하게 되면 에러가 발생한다. 이는 함수표현식에서 사용한 함수명은 외부 코드에서 접근 불가능하기 때문이다. 기명 함수표현식은 재귀함수, 디버그를 할 때 필요하다. 12345678var foo = function(a, b) &#123; return a * b;&#125;;var bar = foo;console.log(foo(10, 10)); // 100 , 10을 argument, 인수라한다.console.log(bar(10, 10)); // 100 변수 bar와 변수 foo는 동일한 익명 함수의 참조값을 갖는다. 123var square = function square(number) &#123; return number * number;&#125;; 함수명과 함수 참조값을 가진 변수명이 일치하므로 함수명으로 호출되는 듯 보이지만 사실은 변수명으로 호출된 것이다. 결국 함수선언식도 함수표현식과 동일하게 함수 리터럴 방식으로 정의되는 것이다. 1.3 Function() 생성자 함수 함수선언식과 함수표현식은 모두 함수 리터럴 방식으로 함수를 정의하는데 이것은 결국 내장 함수 Function() 생성자 함수로 함수를 생성하는 것을 단순화 시킨 것이다. 12var square = new Function('number', 'return number * number');console.log(square(10)); // 100 2. 함수 호이스팅(Function Hoisting) 위의 3가지 함수 정의 방식은 동작 방식에 약간의 차이가 있다. 예) 밑에는 함수선언식이다. -&gt; 이 방법을 사용하지 말아라. 반드시 호출전에 선언할 것. 12345var res = square(5);function square(number) &#123; return number * number;&#125; 함수 선언의 위치와는 상관없이 코드 내 어느 곳에서든지 호출이 가능한데 이것을 함수 호이스팅(Function Hoisting)이라 한다. 자바스크립트는 ES6의 let, const를 포함하여 모든 선언(var, let, const, function, function*, class)을 호이스팅(Hoisting)한다. 함수선언식으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에 바로 초기화하고 이를 VO(variable object)에 저장한다.즉, 함수 선언, 초기화, 할당이 한번에 이루어진다. 예) 밑에는 함수표현식으로 함수를 정의 -&gt; 이방법 변수호이스팅만 발생 이것을 사용. 12345var res = square(5); // TypeError: square is not a functionvar square = function(number) &#123; return number * number;&#125; 함수선언식의 경우와는 달리 TypeError가 발생하였다. 함수표현식의 경우 함수 호이스팅이 아니라 변수 호이스팅이 발생한다. 변수 호이스팅은 변수 생성 및 초기화와 할당이 분리되어 진행된다. 호이스팅된 변수는 undefined로 초기화 되고 실제값의 할당은 할당문에서 이루어진다. 함수표현식은 함수선언식과는 달리 스크립트 로딩 시점에 변수 객체(VO)에 함수를 할당하지 않고 runtime에 해석되고 실행되므로 이 두가지를 구분하는 것은 중요하다. 함수선언식으로 함수를 정의하면 사용하기에 쉽지만 대규모 애플리케이션을 개발하는 경우 인터프리터가 너무 많은 코드를 변수 객체(VO)에 저장하므로 애플리케이션의 응답속도는 현저히 떨어질 수 있으므로 주의해야 할 필요가 있다. 3. First-class object (일급 객체) 일급 객체(first-class object)란? 생성, 대입, 연산, 인자 또는 반환값으로서의 전달 등 프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상을 의미한다. 무명의 리터럴로 표현이 가능하다. 예) var foo = function() { ~~ } // 함수의 이름이 없다. 변수나 자료 구조(객체, 배열…)에 저장할 수 있다. 함수의 파라미터로 전달할 수 있다. 반환값(return value)으로 사용할 수 있다. 123456789101112131415161718192021222324252627282930313233// 1. 무명의 리터럴로 표현이 가능하다.// 2. 변수나 데이터 구조안에 담을 수 있다.var increase = function(num) &#123; return num + 1;&#125;;var decrease = function(num)&#123; return num - 1;&#125;;var obj = &#123; increase: increase, decrease: decrease&#125;;// 3. 함수의 파라미터로 전달 할 수 있다.function calc(func, num)&#123; return func(num);&#125;console.log(calc(increase, 1));console.log(calc(decrease, 1));// 4. 반환값(return value)으로 사용할 수 있다.function calc(mode)&#123; var funcs = &#123; plus: function(left, right)&#123; return left + right; &#125;, minus: function(left, right)&#123; return left - right; &#125; &#125;; return funcs[mode]; // funcs.mode 로하면 mode라는 요소를 찾는다 하지만 이것은 잘못된것 func[mode]로해야한다.&#125;console.log(calc('plus')(2,1));console.log(calc('minus')(2,1)); Javascript의 함수는 위의 조건을 모두 만족하므로 Javascript의 함수는 일급객체이다. 함수와 다른 객체를 구분 짖는 특징은 호출할 수 있다는 것이다. 4. 매개변수(Parameter, 인자) 함수의 작업 실행을 위해 추가적인 정보가 필요할 경우, 매개변수를 지정한다. 매개변수는 함수 내에서 변수와 동일하게 동작한다. 4.1 매개변수(parameter, 인자) vs 인수(argument) 매개변수는 함수 내에서 변수와 동일하게 메모리 공간을 확보하며 전달되어진 인수는 매개변수에 할당된다. 만약 인수가 전달되지 않으면 매개변수는 undefined로 초기화된다. 12345var foo = function (p1, p2) &#123; // p1,p2은 parameter 인자이다. console.log(p1, p2);&#125;;foo(1); // 1 undefined -&gt; 1은 인수이다. 4.2 Call-by-value Primitives(기본자료형) 인수는 Call-by-value(값에 의한 호출)로 동작한다. 함수 호출 시 기본자료형 인수를 함수에 매개변수로 전달할 때 매개변수에 값을 복사하여 함수로 전달하는 방식이다. 함수 내에서 매개변수를 통해 값이 변경되어도 전달이 완료된 기본자료형 값은 변경되지 않는다. 123456789function foo(primitive) &#123; primitive += 1; return primitive;&#125;var x = 0;console.log(foo(x)); // 1console.log(x); // 0 -&gt; 기본자료형 값은 변경되지 않는다. 4.3 Call-by-reference 객체 타입(참조 타입) 인수는 Call-by-reference(참조에 의한 호출)로 동작한다. 함수 호출 시 참조 타입 인수를 함수에 매개변수로 전달할 때 매개변수에 값이 복사되지 않고 객체의 참조값이 매개변수에 저장되어 함수로 전달되는 방식이다. 함수 내에서 매개변수의 참조값이 이용하여 객체의 값을 변경했을 때 전달되어진 참조형의 인수값도 같이 변경된다. 12345678910111213141516171819function changeVal(primitive, obj) &#123; primitive += 100; obj.name = 'Kim'; obj.gender = 'female';&#125;var num = 100;var obj = &#123; name: 'Lee', gender: 'male'&#125;;console.log(num); // 100console.log(obj); // Object &#123;name: 'Lee', gender: 'male'&#125;changeVal(num, obj);console.log(num); // 100console.log(obj); // Object &#123;name: 'Kim', gender: 'female'&#125; num은 기본자료형이라서 call-by-value로 복사만 되고 obj은 참조형(객체) 변수라서 call-by-reference여서 kim, female이 들어간다.; 5. 반환값 (return value) 함수는 자신을 호출한 코드에게 수행한 결과를 반환(return)할 수 있다. return 키워드는 함수를 호출한 코드에게 값을 반환할 때 사용한다. 함수는 배열 등을 이용하여 한 번에 여러 개의 값을 리턴할 수 있다. 함수는 반환을 생략할 수 있다. 이때 함수는 암묵적으로 undefined를 반환한다. 자바스크립트 해석기는 return 키워드를 만나면 함수의 실행을 중단한 후, 함수를 호출한 코드로 되돌아간다. 만일 return 키워드 이후에 다른 구문이 존재하면 그 구문은 실행되지 않는다. 123456789101112131415function calculateArea(width, height) &#123; var area = width * height; return area; // 단일 값의 반환&#125;console.log(calculateArea(3, 5)); // 15console.log(calculateArea(8, 5)); // 40function getSize(width, height, depth) &#123; var area = width * height; var volume = width * height * depth; return [area, volume]; // 복수 값의 반환&#125;console.log('area is ' + getSize(3, 2, 3)[0]); // area is 6console.log('volume is ' + getSize(3, 2, 3)[1]); // volume is 18 6. 함수 객체의 프로퍼티 함수는 객체이다. 따라서 함수도 프로퍼티를 가질 수 있다. 12345678function square(number) &#123; return number * number;&#125;square.x = 10;square.y = 20;console.log(square.x, square.y); // 10, 20 함수는 일반 객체와는 다른 함수만의 표준 프로퍼티를 갖는다. 1234function square(number) &#123; return number * number;&#125;console.dir(square); 6.1 arguments 프로퍼티 arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회가능한(iterable) 유사 배열 객체(array-like object)이다. 함수 객체의 arguments 프로퍼티는 arguments 객체를 값으로 가지며 함수 내부에서 지역변수처럼 사용된다. 즉 함수 외부에서는 사용할 수 없다 123456789function multiply(x, y) &#123; console.log(arguments); return x * y;&#125;console.log(multiply()); // &#123;&#125;console.log(multiply(1)); // &#123; '0': 1 &#125;console.log(multiply(1,2)); // &#123; '0': 1, '1': 2 &#125;console.log(multiply(1,2,3));// &#123; '0': 1, '1': 2, '2': 3 &#125; 매개변수(parameter)는 인수(argument)로 초기화된다 매개변수의 갯수보다 인수를 적게 전달했을 때(multiply(), multiply(1)) 인수가 전달되지 않은 매개변수는 undefined으로 초기화된다. 매개변수의 갯수보다 인수를 더 많이 전달한 경우, 초과된 인수는 무시된다. 즉 arguments 객체는 매개변수 갯수가 확정되지 않은 가변 인자 함수를 구현할 때 유용하게 사용된다. 12345678910111213function sum() &#123; var res = 0; for (var i=0; i&lt;arguments.length; i++) &#123; res += arguments[i]; &#125; return res;&#125;console.log(sum()); // 0console.log(sum(1,2)); // 3console.log(sum(1,2,3)); // 6 arguments 객체는 배열의 형태로 인자값 정보를 담고 있지만 실제 배열이 아닌 유사배열객체(array-like object)이다. 유사배열객체란 length 프로퍼티를 가진 객체를 말한다. 배열 메서드를 사용하려면 Function.prototype.call, Function.prototype.apply를 사용하여야 하는 번거로움이 있다. 123456789function sum() &#123; // arguments 객체를 배열로 변환 var array = Array.prototype.slice.call(arguments); return array.reduce(function (pre, cur) &#123; return pre + cur; &#125;);&#125;console.log(sum(1, 2, 3, 4, 5)); // 15 call 함수를 사용하여서 arguments객체를 배열로 변환하였다. 6.2 caller 프로퍼티 caller 프로퍼티는 자신을 호출한 함수를 의미한다. 123456789101112131415function foo(func) &#123; var res = func(); return res;&#125;function bar() &#123; if (bar.caller == null) &#123; return 'The function was called from the top!'; &#125; else &#123; return 'This function\\'s caller :\\n' + bar.caller; &#125;&#125;console.log(foo(bar));console.log(bar()); bar.caller == null인경우는 전역에서 바로 부르는것 6.3 length 프로퍼티 length 프로퍼티는 함수 정의 시 작성된 매개변수 갯수를 의미한다. 123456789101112function foo() &#123;&#125;console.log(foo.length); // 0function bar(x) &#123; return x;&#125;console.log(bar.length); // 1function baz(x, y) &#123; return x * y;&#125;console.log(baz.length); // 2 6.4 name 프로퍼티 함수명을 나타낸다. 기명함수의 경우 함수명을 값으로 갖고 익명함수의 경우 빈문자열을 값으로 갖는다. 1234567891011// 기명 함수표현식(named function expression)var namedFunc = function multiply(a, b) &#123; return a * b;&#125;;// 익명 함수표현식(anonymous function expression)var anonymousFunc = function(a, b) &#123; return a * b;&#125;;console.log(namedFunc.name); // multiplyconsole.log(anonymousFunc.name); // '' 6.5 proto 프로퍼티 ECMAScript spec에서는 모든 객체는 자신의 프로토타입을 가리키는 [[Prototype]]이라는 숨겨진 프로퍼티를 가진다 라고 되어있다. -&gt; 부모가 있다라는 의미이다. proto과 [[Prototype]]은 같은 개념이다. proto로 부모를 찾을 수 있다. 최상위는 object.prototype이다. 자식은 부모의 것을 사용할 수 있고 그 반대는 안된다. 12345function square(number) &#123; return number * number;&#125;console.dir(square); 함수의 프로토타입 객체는 Function.prototype이며 이것 역시 함수이다. square.proto를 하면 squre의 부모인 Function prototype이 나온다. 6.6 prototype 프로퍼티1var foo = new Person(); 생성자함수가 foo 객체를 만들었을때 생성자 이름에 prototype이 붙은 애가 양부의 역할을 하는데 이때 은 foo객체의 부모이며 의 부모는 Object-prototype이고 Person() 생성자의 prototype을 Person.prototype이라고 불른다. 이때 Person() 생성자의 부모는 funtion-prototype이다. 다들 똑같은 객체이다. 함수 객체만이 가지고 있는 프로퍼티으로 자바스크립트 객체지향의 근간이다. 모든 함수 객체는 prototype 프로퍼티를 갖는다. 주의해야 할 것은 prototype 프로퍼티는 프로토타입 객체를 가리키는 [[Prototype]] 프로퍼티(__proto__ 프로퍼티)와는 다르다는 것이다. [[Prototype]] 프로퍼티 모든 객체가 가지고 있는 프로퍼티이다. 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체을 가리키며 함수 객체의 경우 Function.prototype를 가리킨다. 생성한 객체가 부모를 가르킬때 사용한다. prototype 프로퍼티 함수 객체만 가지고 있는 프로퍼티이다. 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다. 함수가 생성될 때 만들어 지며 constructor 프로퍼티를 가지는 객체를 가리킨다. 이 constructor 프로퍼티는 함수 객체 자신을 가리킨다. 생성자 함수가 생성한 객체의 부모역할을 할 객체를 가르킨다. constructor 프로퍼티는 Person.prototype이 Person 생성자 함수를 가르킨다. 123456789101112function square(number) &#123; return number * number;&#125;// console.dir(square);console.dir(square.__proto__);console.dir(square.prototype);console.log(square.__proto__ === Function.prototype); // true ①console.log(square.__proto__ === square.prototype); // falseconsole.log(square.prototype.constructor === square); // true ②console.log(square.__proto__.constructor === square.prototype.constructor); // false [[Prototype]] 프로퍼티는 함수 객체의 부모 객체(Function.prototype)를 가리키며 prototype 프로퍼티는 함수객체가 생성자 함수로 사용되어 객체를 생성할 때 생성된 객체의 부모 객체 역할을 하는 객체를 가리킨다.; 7. 함수의 다양한 형태7.1 즉시호출함수표현식 (IIFE, Immediately Invoke Function Expression) 함수의 정의(선언)와 동시에 실행(호출)되는 함수를 즉시호출함수라고 한다. 최초 한번만 호출되며 다시 호출할 수는 없다. 이러한 특징을 이용하여 최초 한번만 실행이 필요한 초기화 처리등에 사용할 수 있다. 전역문제를 가장 쉽게해결하는 IIFE(즉시호출함수표현식). 12345678910111213// 기명 즉시실행함수(named immediately-invoked function expression)(function myFunction() &#123; var a = 3; var b = 5; return a * b;&#125;());// 익명 즉시실행함수(immediately-invoked function expression)(function() &#123; var a = 3; var b = 5; return a * b;&#125;()); 코드의 복잡성을 막기위해서 즉시실행함수의 전체를 한번 막아줘야한다. 자바스크립트에서 가장 큰 문제점 중의 하나는 글로벌 스코프에 정의된 것은 코드 내의 어디서든지 접근이 가능하다는 것이다. 외부에 공유되면 곤란하거나 공유될 필요가 없는 프로퍼티나 메서드가 있다. 다른 스크립트 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 원치 않는 결과를 가져올 수 있다. 즉시실행함수 내에 처리 로직을 모아 두면 혹시 있을 수도 있는 변수명 충돌을 방지할 수 있어 이를 위한 목적으로 사용되기도 한다. 즉시실행함수 내에 정의해 두면 라이브러리의 변수들이 독립된 영역 내에 있게 되므로 여러 라이브러리들은 동시에 사용하더라도 변수명 충돌과 같은 문제를 방지할 수 있다. 1234567(function() &#123; var foo = 1; // 지역 console.log(foo);&#125;());var foo = 100; // 전역console.log(foo); 7.2 내부 함수 (Inner function) 내부함수 child는 자신을 포함하고 있는 부모함수 parent의 변수에 접근할 수 있다. 하지만 부모함수는 자식함수(내부함수)의 변수에 접근할 수 없다. closer와 관계가 있다. 1234567891011function parent(param) &#123; var parentVar = param; function child() &#123; var childVar = 'lee'; console.log(parentVar + ' ' + childVar); // Hello lee &#125; child(); console.log(parentVar + ' ' + childVar); // Uncaught ReferenceError: childVar is not defined&#125;parent('Hello'); 또한 내부함수는 부모함수 외부에서 접근할 수 없다. 12345678function sayHello(name)&#123; var text = 'Hello ' + name; var logHello = function()&#123; console.log(text); &#125; logHello();&#125;sayHello('lee'); // Hello leelogHello('lee'); // logHello is not defined 7.3 콜백 함수 (Callback function) 콜백함수는 함수를 명시적으로 호출하는 방식이 아니라 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수를 말한다. 콜백함수가 자주 사용되는 대표적인 예는 이벤트 핸들러 처리이다. 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button id=\"myButton\"&gt;Click me&lt;/button&gt; &lt;script&gt; var button = document.getElementById('myButton'); button.addEventListener('click', function() &#123; console.log('button clicked!'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 콜백 함수는 매개변수를 통해 전달되고 전달받은 함수의 내부에서 어느 특정시점에 실행된다. 123setTimeout(function()&#123; console.log('1초 후 출력된다.');&#125;, 1000); setTimeout method는 전역 메소드이다. 콜백 함수는 주로 비동기식 처리 모델(Asynchronous processing model)에 사용된다. 동기식 처리 모델이란 처리가 종료하면 호출될 함수(콜백함수)를 미리 매개변수에 전달하고 처리가 종료하면 콜백함수를 호출하는 것이다. 123456789function doSomething() &#123; var name = 'Lee'; setTimeout(function() &#123; console.log('My name is ' + name); &#125;, 100);&#125;doSomething(); // My name is Lee","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Function","slug":"JavaScript/Function","permalink":"http://yoursite.com/categories/JavaScript/Function/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://yoursite.com/tags/Function/"}]},{"title":"JavaScript Operator","slug":"js-study-operator","date":"2017-07-31T03:54:00.000Z","updated":"2017-11-05T04:13:12.000Z","comments":true,"path":"2017/07/31/js-study-operator/","link":"","permalink":"http://yoursite.com/2017/07/31/js-study-operator/","excerpt":"","text":"Javascript Operator 1. 산술 연술자 (Arithmetic Operators)1234567891011121314151617var x = 5;var y = 2;var z;z = x + y; // 7z = x - y; // 3z = x * y; // 10z = x / y; // 2.5z = x % y; // 1z = x++; // 5 선대입후증가 즉 먼저 z에게 값을준다 그래서 z= 5 그 뒤에 x=6이된다.z = ++x; // 7 선증가후대입 x=6인 값에 ++하니 z=7이된다.z = x--; // 7 선대입후감소 z = --x; // 5 선감소후대입var str1 = '5' + 5; // '55'var str2 = 5 + '5'; // '55'var str3 = 'Hello' + 5; // 'Hello5' + 연산자는 덧셈 연산과 문자열 연결 연산을 수행한다. 연산 대상이 모두 숫자인 경우 : 덧셈 연산 그 외의 경우 : 문자열 연결 연산 2. 대입 연산자 (Assignment Operators)123456789101112131415var x;x = 10; // 10x += 5; // 15x -= 5; // 10x *= 5; // 50x /= 5; // 10x %= 5; // 0var txt1 = 'Good';var txt2 = 'Morning';var txt3 = txt1 + ' ' + txt2; // Good Morningtxt1 = 'What a very ';txt1 += 'nice day'; // What a very nice day 3. 비교 연산자 (Comparison Operators) == : 동등비교 형변환 후, 비교한다. === : 일치비교 타입까지 일치하여라 true를 반환 != : 부등비교 !== : 불일치비교 ? : 삼항 연산자 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var x = 5x == 5 // truex == '5' // true '5'를 숫자로 형변환을 해버려서 true로 나타낸다.x == 8 // falsex === 5 // truex === '5' // falsex != 8 // truex != 5 // falsex != '5' // falsex !== 8 // truex !== 5 // falsex !== '5' // truex &gt; 0 // truex &gt; 5 // falsex &gt; 8 // falsex &lt; 0 // falsex &lt; 5 // falsex &lt; 8 // truex &gt;= 0 // truex &gt;= 5 // truex &gt;= 8 // falsex &lt;= 0 // falsex &lt;= 5 // truex &lt;= 8 // true//삼항연산자(ternary operator)// 조건 ? 조건이 ture일때 반환할 값 : 조건이 false일때 반환할 값var condition = true;var result = condition ? 'true' : 'false';console.log(result); // 'true'var now = new Date();var greeting = 'Good' + ((now.getHours() &gt; 17) ? ' evening.' : ' day.');// id의 길이가 INPUT_ID_MIN_LEN보다 작으면 에러 메시지를 출력한다.var id = 'lee';var INPUT_ID_MIN_LEN = 5;var errMsg = id.length &lt; INPUT_ID_MIN_LEN ? '아이디는 5자리 이상으로 입력하세요' : '성공';console.log(errMsg); // '아이디는 5자리 이상으로 입력하세요' 4. 논리 연산자 (Logical Operator)12345678910111213141516171819202122// &amp;&amp; (논리곱) 연산자var a1 = true &amp;&amp; true; // t &amp;&amp; t returns truevar a2 = true &amp;&amp; false; // t &amp;&amp; f returns falsevar a3 = false &amp;&amp; true; // f &amp;&amp; t returns falsevar a4 = false &amp;&amp; (3 == 4); // f &amp;&amp; f returns falsevar a5 = 'Cat' &amp;&amp; 'Dog'; // t &amp;&amp; t returns Dogvar a6 = false &amp;&amp; 'Cat'; // f &amp;&amp; t returns falsevar a7 = 'Cat' &amp;&amp; false; // t &amp;&amp; f returns false// || (논리 합) 연산자var o1 = true || true; // t || t returns truevar o2 = false || true; // f || t returns truevar o3 = true || false; // t || f returns truevar o4 = false || (3 == 4); // f || f returns falsevar o5 = 'Cat' || 'Dog'; // t || t returns Catvar o6 = false || 'Cat'; // f || t returns Catvar o7 = 'Cat' || false; // t || f returns Cat// ! (논리 부정) 연산자var n1 = !true; // falsevar n2 = !false; // truevar n3 = !'Cat'; // false 5. 단축 평가 논리연산자가 Boolean 값과 함께 사용되지 않을 경우, 둘중 1개가 반환된다. true || anything true false || anything anything true &amp;&amp; anything anything false &amp;&amp; anything false JavaScript는 빈문자열을 true로 인식한다. 6. 타입 연산자 (Type Operator) typeof : 변수의 자료형을 문자열로 반환한다. instanceof : 객체가 동일 객체형의 인스터스이면 true를 반환한다.123456789101112131415typeof 'John' // returns stringtypeof 3.14 // returns numbertypeof NaN // returns numbertypeof false // returns booleantypeof [1, 2, 3, 4] // returns objecttypeof &#123;name:'John', age:34&#125; // returns objecttypeof new Date() // returns objecttypeof function () &#123;&#125; // returns function typeof myCar // returns undefined (설계적 결함)typeof null // returns object (설계적 결함)function Person()&#123;&#125;var me = new Person()me instanceof Person // true 7. !! !!은 피연산자를 boolen으로 변환하는 것이다. 12345678console.log(!!1); // trueconsole.log(!!0); // falseconsole.log(!!&apos;string&apos;); // trueconsole.log(!!&apos;&apos;); // falseconsole.log(!!null); // falseconsole.log(!!undefined); // falseconsole.log(!!&#123;&#125;); // trueconsole.log(!![]); // true 객체(배열 포함)의 경우 빈 객체라도 존재하기만하면 true로 변환된다. 객체의 존재 확인 후 그 결과를 반환해야 하는 경우, !!를 사용하면 강제로 피연산자를 boolean으로 형 변환 할 수 있다. 123456789function checkExist(obj) &#123; return !!obj;&#125;var obj;console.log(checkExist(obj)); // falseobj = &#123;&#125;;console.log(checkExist(obj)); // true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Operator","slug":"JavaScript/Operator","permalink":"http://yoursite.com/categories/JavaScript/Operator/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Operator","slug":"Operator","permalink":"http://yoursite.com/tags/Operator/"}]},{"title":"JavaScript Object","slug":"js-study-object","date":"2017-07-31T03:54:00.000Z","updated":"2017-11-04T09:22:01.000Z","comments":true,"path":"2017/07/31/js-study-object/","link":"","permalink":"http://yoursite.com/2017/07/31/js-study-object/","excerpt":"","text":"Javascript Object 1. 객체(Object)란? 자바스크립트는 객체기반의 스크립트 언어이며 이루고 있는 거의 모든것은 객체이다 객체 = 키 + 데이터 + 동작 이름(키) + 값으로 구성된 데이터(프로퍼티) + 동작을 나타내는(메서드) 1.1 프로퍼티(Property) 객체는 이름(name)과 값(value)의 쌍인 프로퍼티들을 포함하는 컨테이너라고 할 수 있다. 프로퍼티 이름 : 빈 문자열을 포함하는 문자열과 숫자 프로퍼티 값 : undefined을 제외한 모든 값 1.2 메서드(Method) 메서드는 객체에 제한되어 있는 함수를 의미한다. 2. 객체 생성 방법 자바스크립트는 클래스라는 개념이 없고 별도의 객체 생성 방법이 존재한다. 객체 리터럴, object() 생성자 함수, 생성자 함수 3가지의 방법이 존재한다. 2.1 객체 리터럴 중괄호({})를 사용하여 객체를 생성하는데 {} 내에 아무것도 기술하지 않으면 빈 객체가 생성된다. {} 내에 1개 이상의 프로퍼티 이름(Property name): 프로퍼티 값(Property value)을 기술하면 해당 프로퍼티가 추가된 객체를 생성할 수 있다. 123456789101112131415var emptyObject = &#123;&#125;; // empty object 즉 property가 없다.console.log(typeof emptyObject); // objectvar person = &#123; name: 'Lee', gender: 'male', sayHello: function () &#123; console.log('Hi! My name is ' + this.name); &#125;&#125;;console.log(typeof person); // objectconsole.log(person); // &#123; name: 'Lee', gender: 'male', sayHello: [Function: sayHello] &#125;person.sayHello(); // Hi! My name is Lee person은 2개의 property(name,gender)와 1개의 method(syHello())를 가지고 있다. 객체내에서 method가 다른 property를 선택할때는 this를 가르킨다. 2.2 Object() 생성자 함수 new 연산자와 Object() 생성자 함수를 사용하여 빈 객체를 생성할 수 있다. 12345678910111213// 빈 객체의 생성var person = new Object();// 프로퍼티 추가person.name = 'Lee';person.gender = 'male';person.sayHello = function () &#123; console.log('Hi! My name is ' + this.name);&#125;;console.log(typeof person); // objectconsole.log(person); // &#123; name: 'Lee', gender: 'male', sayHello: [Function] &#125;person.sayHello(); // Hi! My name is Lee 객체 리터럴 방식으로 생성된 객체는 결국 내장(Built-in) 함수인 Object() 생성자 함수로 객체를 생성하는 것을 단순화 시킨 short-hand(축약법)이다. 2.3 생성자 함수 동일한 프로퍼티를 갖는 객체를 한번에 만든다. 1234567891011121314151617181920// 생성자 함수function Person(name, gender) &#123; this.name = name; this.gender = gender; this.sayHello = function()&#123; console.log('Hi! My name is ' + this.name); &#125;;&#125;// 인스턴스의 생성var person1 = new Person('Lee', 'male');var person2 = new Person('Kim', 'female');console.log('person1: ', typeof person1);console.log('person2: ', typeof person2);console.log('person1: ', person1);console.log('person2: ', person2);person1.sayHello();person2.sayHello(); 생성자 함수 이름은 일반적으로 대문자로 시작한다. 프로퍼티 또는 메서드명 앞에 기술한 this는 생성자 함수로 생성될 인스턴스(instance)를 가리킨다. 따라서 this에 연결되어 있는 프로퍼티와 메서드는 public이다. 생성자 함수 내에서 선언된 일반 변수는 private이다. 즉 생성자 함수 내부에서는 자유롭게 접근이 가능하나 외부에서 접근할 수 있는 방법이 없다. 12345678910111213141516function Person(name, gender) &#123; var married = 'yes'; // private this.name = name; // public this.gender = gender; // public this.sayHello = function()&#123; // public console.log('Hi! My name is ' + this.name); &#125;;&#125;var person = new Person('Lee', 'male');console.log(typeof person);console.log(person);console.log(person.gender); // 'male'console.log(person.married); // undefined 3. 객체 프로퍼티 접근3.1 프로퍼티 이름 ‘’로 묶어주는 이유는 - 를 연산자로 인식하기 때문이다. last_name(Snake) = ok, lastName(Kamel) = ok, last-name(kebab) = no (일반적으로 카멜사용) 프로퍼티 값은 undefined을 제외한 모든 값과 표현식이 올 수 있으며 프로퍼티 값이 함수인 경우 이를 메서드라 한다. 예약어를 프로퍼티 이름으로 사용하여서는 않된다. 12345678var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male', function: 1 // OK. 하지만 예약어는 사용하지 말아야 한다.&#125;;console.log(person.function); 3.2 프로퍼티 값 읽기 객체의 프로퍼티에 접근하는 방법 마침표 . 표기법 대괄호 [] 표기법 -&gt; kebab 형식일때 사용한다. 123456789101112131415var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;console.log(person);console.log(person.first-name); // NaN: undefined-nameconsole.log(person[first-name]); // ReferenceError: first is not definedconsole.log(person['first-name']); // 'Ung-mo'console.log(person.gender); // 'male'console.log(person[gender]); // ReferenceError: gender is not definedconsole.log(person['gender']); // 'male' 객체에 존재하지 않는 프로퍼티를 참조하면 undefined를 반환한다. 1234567var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;console.log(person.age); // undefined 3.3 프로퍼티 값 갱신 새로운 값을 할당하면 프로퍼티 값은 갱신된다. 12345678var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;person['first-name'] = 'Kim';console.log(person['first-name'] ); // 'Kim' 3,4 프로퍼티 동적 생성 객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면 하면 해당 프로퍼티를 객체에 추가하고 값을 할당한다. 12345678var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;person.age = 20;console.log(person.age); // 20 3.5 프로퍼티 삭제 delete 연산자를 사용하여서 삭제가능하다. 객체에다가 delete를 사용하면 무시된다.1234567891011var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;delete person.gender;console.log(person.gender); // undefineddelete person;console.log(person); // Object &#123;first-name: 'Ung-mo', last-name: 'Lee'&#125; 3.6 for-in 문 for-in 문을 사용하면 객체에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다. 사용하지 않는 것이좋다. ES6에서 새로추가된 for-of 를 사용하여라. 순서가 보장되지 않고, 만들지 않은 값이 같이 나오기도 한다. 4. Pass-by-reference 참조형이란? 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미한다. 객체형과 다르게 기본자료형의 값은 값(value)으로 전달된다. 즉, 복사되어 전달된다. 이를 pass-by-value라 하며 한번 값이 정해지면 변경할 수 없다(immutable). 123456789101112// Pass-by-referencevar foo = &#123; val: 10&#125;var bar = foo;console.log(foo.val, bar.val); // 10 10console.log(foo === bar); // truebar.val = 20; // val에 20을 넣으면 bar도 자동으로 반영된다 둘은 reference관계라서 그렇다.console.log(foo.val, bar.val); // 20 20console.log(foo === bar); // true pass-by-reference는 변수 foo, bar 모두 동일한 객체를 참조하고 있다. 따라서 참조하고 있는 객체의 val 값이 변경되면 변수 foo, bar 모두 동일한 객체를 참조하고 있으므로 두 변수 모두 변경된 객체의 프로퍼티 값을 참조하게 된다. 객체는 참조(Reference) 방식으로 전달된다. 결코 복사되지 않는다. 예) pass-by-value 12345678910var foo = &#123; val: 10 &#125;;var bar = &#123; val: 10 &#125;;console.log(foo.val, bar.val); // 10 10console.log(foo === bar); // falsevar baz = bar;console.log(baz.val, bar.val); // 10 10console.log(baz === bar); // true foo와 변수 bar는 비록 내용을 같지만 별개의 객체를 생성하여 참조값을 할당하였다. 따라서 변수 foo와 변수 bar의 참조값은 동일하지 않다. 변수 baz에는 변수 bar의 값을 할당하였다. 결국 변수 baz와 변수 bar는 동일한 객체를 가리키는 참조값을 저장하고 있다. 따라서 변수 baz와 변수 bar의 참조값은 동일하다. 5. Pass-by-value 기본자료형의 값은 값(value)으로 전달된다. 즉, 복사되어 전달된다. 이를 pass-by-value라 한다. 기본자료형은 값이 한번 정해지면 변경할 수 없다.(immutable) 12345678910// Pass-by-valuevar a = 1;var b = a;console.log(a, b); // 1 1console.log(a === b); // truea = 10;console.log(a, b); // 10 1console.log(a === b); // false 6. 객체의 분류 객체는 아래와 같이 분류된다.; DOM : 정보를 가진 객체이다. BOM : browser를 컨트롤하기위한 객체들을 나타낸다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Object","slug":"JavaScript/Object","permalink":"http://yoursite.com/categories/JavaScript/Object/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Object","slug":"Object","permalink":"http://yoursite.com/tags/Object/"}]},{"title":"JavaScript Data-Type Variable","slug":"js-study-data-type-variable","date":"2017-07-31T03:54:00.000Z","updated":"2017-11-05T03:58:39.000Z","comments":true,"path":"2017/07/31/js-study-data-type-variable/","link":"","permalink":"http://yoursite.com/2017/07/31/js-study-data-type-variable/","excerpt":"","text":"Javascript Data type &amp; Variable 변수란?: 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자이다. 자료형은 데이터의 성질을 나타낸다. javascript 영역이 입력되는 값을 판단하여서 메모리에 저장한다. JavaScript는 동적 타이핑 언어로 변수의 Type annotation이 필요없이 값이 할당되는 과정에서 자동으로 자료형이 결정된다. 할당되기 전에는 undefined형이다. typeof를 통하여 변수의 type을 알 수 있다. 12345678var str = 'Hello';var num = 1;var bool = true;var foo = 'string';console.log(typeof foo); // stringfoo = 1;console.log(typeof foo); // number 1.Data Type (자료형) 기본 자료형(변경 불가능) Boolean null undefined Number String Symbol(ECMAScript 6 추가) 객체형(변경 가능) object 1.1 Primitive Data Type (기본자료형) 기본자료형의 값은 변경 불가능한 값이다. (pass-by- value) 1.1.1 Boolean true, false 두가지의 값을 가질 수 있다. 비어있는 문자열, null, undefined, 숫자 0은 false로 간주된다. 1.1.2 null 값을 할당한 이후에 그 값의 관계를 끊는다. JavaScript는 case-sensitive(대소문자구분)하므로 null은 항상 소문자로 작성해야한다. var foo = null; 을하면 typeof가 null이 나와야하는데 object가 나온다 설계상의 오류이다. 즉 typeof로 check하면 안되고 (foo === null)로 체크해야한다. 1.1.3 undefined 값을 할당하지 않은 변수는 undefined값을 가진다. 12345678var foo;console.log(foo); // undefinedfoo = &#123; name: 'Lee', gender: 'male'&#125;console.log(foo.bar); // bar가 존재하지 않아서 undefined가 나온다. 1.1.4 Number 자바스크립트는 Number인 하나의 숫자 자료형만 존재한다. +/- Infinity, NaN(not-a-number) 정수를 +0으로 나누면 + Infinity, -0으로 나누면 - Infinity이다. NaN은 연산은 가능하지만 숫자로 표시를 못하는 경우 1.1.5 String String은 텍스트 데이터를 나타내는데 사용한다. ‘’, “”사이에 값을 넣을 수 있지만 주로 ‘’를 사용한다. 1234var str = \"string\";console.log(str[0]); // s console.log(typeof str); // type = stringconsole.log(str[3]); // i 자바스크립트의 문자열은 변경 불가능(immutable)하다. 이것은 한 번 문자열이 생성되면, 그 문자열을 변경할 수 없다는걸 의미한다. 변경 불가능(immutable) 한번 생성된 문자열은 read only로서 수정되지 않는다. 새로운 문자를 할당하는 것은 가능하다 += 를 사용한다. 재할당은 그 부분에다가 하는 것이아닌 새로운 부분에다가 만들고 변수가 그곳을 알려주는 것이다. 1234567891011121314var str = 'string';console.log(str); // stringstr = 'String'; // 재할당console.log(str); // Stringstr += ' test';console.log(str); // String teststr.substring(0, 3);console.log(str); // Strstr = str.toUpperCase();console.log(str); // STR 재할당이란? 기존에 string을 따로두고 새로운 곳에 String으로 만들어 둔다. 메서드란? .앞에는 기본적으로 객체이고 뒤에는 함수인데 이것을 합쳐서 이야기한다. 기본자료형은 안에 wrapper가 존재하기에 객체의 역할을 할 수 있다. 1.1.6 Symbol Symbol은 에플리케이션 전체에서 유일하며 변경 불가능한(immutable) 기본 자료형(primitive)이다. 주로 객체의 프로퍼티 키(property key)로 사용한다. 자료형을 symbol이라는 함수로 나타내며 이값은 에플리케이션에서 유일한 값으로 나타난다. 123456var key = Symbol('key');console.log(typeof key); // symbolvar obj = &#123;&#125;;obj[key] = 'value';console.log(obj[key]); // value 1.2 객체형 (object type, 참조형) 객체는 이름과 값을 가지는 데이터를 의미하는 프로퍼티와 동작을 의미하는 메서드를 포함하고 있는 독립적 주체이다.(pass-by-reference) 변경가능한 데이터이다. 데이터를 의미하는 프로퍼티(property)와 동작을 의미하는 메서드(method)를 포함하고 있는 독립적 주체이다. 객체의 종류 함수 배열 날짜 정규식 2. 변수(Varible) 값을 유지할 필요가 있을 때 사용한다. 변수명 생성 규칙 반드시 영문자(특수문자 제외), underscore ( _ ), 또는 달러 기호($)로 시작하여야 한다. 이어지는 문자에는 숫자(0~9)도 사용할 수 있다. JavaScript는 대/소문자를 구별하므로 사용할 수 있는 문자는 “A” ~ “Z” (대문자)와 “a” ~ “z” (소문자)이다. var keyword를 사용하여서 선언을한다. 123456789101112var name; // 변수 name 선언name = 'Lee'; // 변수 name에 값 'Lee'가 저장(할당)되었다.var age = 30; // 선언과 할당var person = 'Lee', address = 'Seoul', price = 200;var price = 10;var tax = 1;var total = price + tax; 선언이 안되어 있는 값에 접근하면 Reference Error 예외가 발생한다.123var x;console.log(x); // undefinedconsole.log(y); // ReferenceError 2.1 변수의 중복 선언 변수는 중복 선언이 가능하다. 123456var x = 1;console.log(x); // 1// 변수의 중복 선언var x = 100;console.log(x); // 100 이기능은 기존의 선언된 값이 의도되지않게 재할당이 될 위험이 있다.(협업시 문제 발생 가능성 증가) 2.2 변수 선언 시 var 키워드 생략 허용12x = 1;console.log(x); // 1 var를 사용하지 않았기 때문에 전역 변수로 선언이 된다. 전역 변수란? 소스코드 모든 영역에서 변수를 사용할 수 있다. 2.3 동적 타이핑 (Dynamic Typing) Typing 변수의 type을 설정하는 것을 나타낸다. 변수의 Type annotation이 필요없이 값이 할당되는 과정에서 자동으로 자료형이 결정된다. 같은 변수에 여러 data type의 값을 대입할 수 있다. type을 선언하지 않았다면 runtime에러가 발생할 확률이 높다. 1234567891011121314151617181920var foo;console.log(typeof foo); // undefinedfoo = null;console.log(typeof foo); // objectfoo = &#123;&#125;;console.log(typeof foo); // objectfoo = 3;console.log(typeof foo); // numberfoo = 3.14;console.log(typeof foo); // numberfoo = 'Hi'; console.log(typeof foo); // stringfoo = true; console.log(typeof foo); // boolean 하나의 변수로 여러개의 type을 설정할 수 있지만 위험할 수 있다. 2.4 변수 호이스팅 (Variable Hoisting) 자바스크립트의 모든 선언문은 호이스팅된다. 호이스팅이란 var 선언문이나 function 선언문을 해당 Scope의 선두로 옮겨진것 처럼보여지는 것을 말한다. javascript의 변수는 function-level scope를 가진다. Function-level scope : 함수 내부에서 선언한 변수는 지역변수이며, 함수 외부에서 선언한 변수는 모두 전역 변수이다. 즉 함수 블록만 지역이다. 함수내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다.함수 외부에서 선언한 변수는 함수내부에서 사용가능하다. 1234567console.log(foo); // ① undefinedvar foo = 123;console.log(foo); // ② 123&#123; var foo = 456;&#125;console.log(foo); // ③ 456 undefined인 이유는 변수 호이스팅으로 인해서 밑에 foo가 선언된 값이 선두로 옮겨진 것 처럼 보여지는 것이라서 그렇다. 변수의 생성단계 선언 단계 : 변수 객체에 변수를 등록한다. 이 변수 객체는 scope가 참조하는 대상이 된다. 초기화 단계 : 변수 객체에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다. 할당 단계 : undefined로 초기화된 변수에 실제값을 할당한다. var keyword로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 타언어에서는 if, for문 등의 { ~~ } 안에는 또다른 scope(지역 범위)으로 구분이 되지만 javascript에서는 구분이 되지 않는다. javascript는 함수만 scope로 구분한다. 2.5 var keyword로 선언된 변수의 문제점 Function-level scope 전역 변수의 남발가능성 농후 for loop 초기화식에서 사용한 변수를 for loop 외부 or 전역에서 참조할 수 있다. var keyword 생략 허용 의도하지 않은 변수의 전역화 중복 선언 허용 의도하지 않은 변수값 변경 변수 호이스팅 변수를 선언하기 전에 참조가 가능하다. 변수의 범위는 좁을수록 좋다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Data-Type","slug":"JavaScript/Data-Type","permalink":"http://yoursite.com/categories/JavaScript/Data-Type/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Data-Type","slug":"Data-Type","permalink":"http://yoursite.com/tags/Data-Type/"}]},{"title":"JavaScript-Control-Flow","slug":"js-study-control-flow","date":"2017-07-31T03:54:00.000Z","updated":"2017-10-31T13:24:32.000Z","comments":true,"path":"2017/07/31/js-study-control-flow/","link":"","permalink":"http://yoursite.com/2017/07/31/js-study-control-flow/","excerpt":"","text":"Javascript Control Flow 1. 블록 구문(Block statement) 중괄호로 범위가 정해진 구문을 블록 구문이라고 한다. 1234567891011121314151617181920// 함수function foo() &#123; var x = 1, y = 2; console.log(x + y);&#125;foo();// 객체리터럴var obj = &#123; x: 1, y: 2&#125;;console.log(obj.x + obj.y);// 흐름 제어 구문(control flow statement)var x = 0;while (x &lt; 10) &#123; x++;&#125;console.log(x); 2. 조건문 (Conditional statement) 조건식을 가지고 코드블럭을 실행할지 않할지에 대한 의사결정을 하는 것이다. 프로그래밍은 요구사항의 집합을 분석하여 적절한 자료구조와 함수의 집합으로 변환한 후 그 흐름을 제어하는 것이다. 2.1 if 문 if문을 통하여 논리적 참, 거짓을 구별한다. 12345if(조건문) &#123; // 조건식이 참이면 이 코드블록이 실행된다.&#125; else &#123; // 조건식이 거짓이면 이 코드블록이 실행된다.&#125; 1234567891011121314151617181920212223242526272829var hour = 20;var greeting;// if 문if (hour &lt; 18) &#123; greeting = 'Good day';&#125;console.log(greeting);// if-else 문if (hour &lt; 18) &#123; greeting = 'Good day';&#125; else &#123; greeting = 'Good evening';&#125;console.log(greeting);// if-else if 문if (hour &lt; 10) &#123; greeting = 'Good morning';&#125; else if (hour &lt; 20) &#123; greeting = 'Good day';&#125; else &#123; greeting = 'Good evening';&#125;console.log(greeting); 2.2 switch 문 switch변수의 값과 일치되는 case문으로 실행 순서가 이동하게 된다. 일치하는 값이 없다면 default로 이동한다. 1234567891011121314151617var color = 'red';// color = switch 변수switch (color) &#123; // color == 'yellow'인 경우 case 'yellow': console.log('yellow color'); // color == 'red'인 경우 case 'red': console.log('red color'); // color == 'blue'인 경우 case 'blue': console.log('blue color'); // 그외의 경우 default: console.log('unknown color');&#125; 이렇게 하면 break를 선언하지 않았기 때문에 red,blue,unknown까지 출력이된다. 123456789101112131415var color = 'red';switch (color) &#123; case 'yellow': console.log('yellow color'); break; case 'red': console.log('red color'); break; case 'blue': console.log('blue color'); break; default: console.log('unknown color');&#125; 3. 반복문(Loop) 주어진 조건식이 참인 경우 코드 블록을 반복해서 실행한다. 3.1 for 문 for문은 특정 조건이 거짓으로 판별될 때까지 반복한다. 123for ([초기문]; [조건문]; [증감문]) &#123; 구문;&#125; 여러 종류의 for문이 존재한다. 12345678910111213141516171819202122232425var array = ['one', 'two', 'three', 'four'];for (var i = 0; i &lt; array.length; i++) &#123; // console.log(array[i]); console.log('[' + i + '] = ' + array[i]);&#125;// for-infor (var index in array) &#123; console.log('[' + index + '] = ' + array[index]);&#125;// foreacharray.forEach(function (element, index, arr) &#123; console.log('[' + index + '] = ' + element);&#125;);// for-of (ES6)for (const element of array) &#123; console.log(element);&#125;// array.entries(): 배열의 key/value의 쌍을 반환하는 iterator를 반환for (const [index, value] of array.entries()) &#123; console.log('[' + index + '] = ' + value);&#125; for문에 어떤 식도 선언하지 않으면 무한루프가 된다. 3.2 while 문 조건문이 거짓이 되면 실행을 종료하고 반복문을 빠져나간다. 조건문이 언제나 참이면 무한루프가 된다. 무한루프를 탈출하기 위해서는 break문을 사용한다. break문을 감싸는 반복문 하나를 탈출한다. 12345678var i = 0;// 무한루프while (true) &#123; console.log(i); i++; // i가 10이면 exit! if (i === 10) break;&#125; 3.3 do-while 문 코드블록은 조건문을 확인하기 전에 무조건 1회 실행된다. 그후 조건문을 확인한다. 12345var i = 0;do &#123; console.log(i); i++;&#125; while (i &lt; 3); 3.4 continue continue문은 이후 구문의 실행을 스킵하고 반복문의 조건문으로 이동한다. 예참조 -&gt; 짝수에서는 console.log를 안한다.12345 for (var i = 0; i &lt; 5; i++) &#123; if (i % 2 == 0) continue; console.log(i); // 홀수만 출력&#125; 4. 평가(Evaluating) 일반적 표현식외에도 문자열, 숫자, 변수, 내장값등을 조건식으로 사용할 수 있다. 12345678910111213141516171819202122232425if (1) &#123; // true console.log('1');&#125;if ('str') &#123; // true console.log('2');&#125;if (true) &#123; //true console.log('3');&#125;if (null) &#123; // false console.log('4');&#125;var x = '';if (x) &#123; // false console.log('5'); &#125;if (!x) &#123; //true console.log('6'); &#125; 4.1 암묵적 강제 형 변환(Type coercion) context를 고려하여 내부적으로 자료형을 강제 형변환시킨다. 1234567console.log('1' &gt; 0); // trueconsole.log(1 + '2'); // '12'console.log(2 - '1'); // 1console.log('10' == 10); // trueconsole.log('10' === 10); // false -&gt; type이 다르다.console.log(undefined == null); // trueconsole.log(undefined === null); // false -&gt; type이 다르다. 4.2 Type Conversion Table 부정적 값은 = 0, false, undefined 등으로 나타내진다. 긍정적 값은 = 1, true 등으로 나타내진다. 4.3 Data type conversion 형 변환시 편리하다. 12345678910111213var val = '123';console.log(typeof val + ': ' + val); // string: 123// sting -&gt; numberval *= 1; // string에 수를 곱하면 type이 number로 변환된다.// val = Number(val);// val = parseInt(val);console.log(typeof val + ': ' + val); // number: 123// number -&gt; sting val += ''; // 숫자에 빈문자열을 더해준다.// val = String(val);console.log(typeof val + ': ' + val); // string: 123 val *= 1; // string에 수를 곱하면 type이 number로 변환된다.string-&gt;number val += ‘’; // 숫자에 빈문자열을 더해준다. number-&gt;string 4.4 Truthy &amp; Falsy values 아래 값들은 Boolean context에서 false로 평가된다. false undefined null 0 NaN (Not a Number) ‘’ (빈문자열) 4.5 Checking equality 동등비교시 (==, !=)이 아닌 일치연산자(===, !==)을 사용해야한다.12345678// logs false !!!console.log(null == false);console.log(undefined == false);console.log(null == 0);console.log(undefined == 0);console.log(undefined === null);console.log(NaN == null);console.log(NaN == NaN); 4.6 Checking existence 객체나 배열(배열도 객체이다)이 값을 가지고 있으면 truthy value로 취급된다. 12345if (document.getElementById('header')) &#123; // 요소가 존재함 : 필요한 작업을 수행&#125; else &#123; // 요소가 존재하지 않음 : 필요한 작업을 수행&#125; 객체의 존재를 boolean으로 비교하면 안된다. 1if (document.getElementById('header') == true) // false 주의 사항 : b가 false라는 값을 가진 객체가 된다. 12var b = new Boolean(false);if (b) // true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Control Flow","slug":"JavaScript/Control-Flow","permalink":"http://yoursite.com/categories/JavaScript/Control-Flow/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Control Flow","slug":"Control-Flow","permalink":"http://yoursite.com/tags/Control-Flow/"}]},{"title":"JavaScript-Introduction","slug":"js-study-introduction","date":"2017-07-28T03:54:00.000Z","updated":"2017-10-29T12:37:22.000Z","comments":true,"path":"2017/07/28/js-study-introduction/","link":"","permalink":"http://yoursite.com/2017/07/28/js-study-introduction/","excerpt":"","text":"Javascript Introduction 1. Introduction 웹브라우저에서 동작하는 유일한 언어이다. jQuery의 등장으로 DOM(Document Object Model)를 보다 쉽게 제어할 수 있게 되었다. javascript는 interpreter language 컴파일러가 필요없다 동시에 번역한다. 명령형, 함수형, 프로토타입 기반 객체지향형 언어이다. 자유도(3가지가 다된다)가 높다보니 어렵다. Node.js의 등장으로 Full stack 개발 언어가 되었다. 2. 브라우저 동작 원리 javascript는 위치가 의미가 있다 dom을 만들기 때문이다. HTML 파서는 script 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진에 제어 권한을 넘긴다. 자바스크립트 엔진의 실행이 완료된 후 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. 이것은 script 태그의 위치에 의해 DOM의 생성이 지연될 수 있음을 의미한다. 3. History ECMAScript 3 : 가장 범용적으로 지원되는 버전이다 (1999.12) ECMAScript 5 : HTML5와 함께 출현한 표준안이다. JSON(JavaScript Object Notation)과 Strict Mode가 추가되었다. 인터넷 익스플로러 9이상이나 그 외 브라우저에서만 작동한다.(2009.12) ECMAScript 6 : let, const 키워드, Arrow Function, class, Symbol 타입 등이 추가되었다. 4. Browsers Support 대부분의 브라우저는 ES6를 지원하고 있지만 100%는 아니다. 그리고 Node.js의 경우 v4부터 지원을 시작하였다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Introduction","slug":"JavaScript/Introduction","permalink":"http://yoursite.com/categories/JavaScript/Introduction/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Introduction","slug":"Introduction","permalink":"http://yoursite.com/tags/Introduction/"}]},{"title":"JavaScript-Syntax","slug":"js-study-syntax","date":"2017-07-28T03:54:00.000Z","updated":"2017-10-31T11:56:57.000Z","comments":true,"path":"2017/07/28/js-study-syntax/","link":"","permalink":"http://yoursite.com/2017/07/28/js-study-syntax/","excerpt":"","text":"Javascript Syntax basics 1. Hello world 정적인 HTML을 동적으로 변경할 수 있는 유일한 방법은 js를 사용하는 것이다. 1234function myFunction() &#123; var myHeader = document.getElementById('demo'); myHeader.innerHTML = 'Hello world!';&#125; 2. 외부의 Javascript 실행하기 HTML과 Javascript는 역할(관심사 Concern)이 다르므로 분리된 파일로 작성하는 것이 바람직하다. 1&lt;script src=\"extern.js\"&gt;&lt;/script&gt; 코드의 실행과정 1.script 요소를 만나면 웹페이지의 파싱을 잠시 중단한다. 2.src 어트리뷰트에 정의된 자바스크립트 파일을 로드한 후 실행한다. 3.중단된 웹페이지의 파싱을 계속 진행한다. body 요소의 가장 아래에 스크립트를 위치시키는 것은 좋은 아이디어이다. HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다. HTML은 script를 만나면 멈추게 된다. 스크립트 로딩 지연으로 인한 병목 현상을 근복적으로 방지하기 위한 어트리뷰트가 추가되었다. 12&lt;script async src=&quot;extern.js&quot;&gt;&lt;/script&gt;&lt;script defer src=&quot;extern.js&quot;&gt;&lt;/script&gt; async = 스크립트는 다운로드 완료 직후 실행된다. defer = 스크립트는 웹페이지 파싱 완료 직후 실행된다. async와 defer 어트리뷰트는 웹페이지 파싱과 외부 스크립트 파일의 다운로드가 동시에 진행된다는 면에서는 동일하다. 하지만 스크립트의 실행 시점이 다르다. IE9이상을 쓸거면 defer가 좋다. 3. JavaScript Output alert box -&gt; alert() HTML output -&gt; document.write() HTML element -&gt; innerHTML Browser console -&gt; console.log() 4. Javascript Syntax Basics4.1 구문(statement) 단계별로 수행될 명령들의 집합이다. 각각의 명령을 statement(구문)이라 하며 statement가 실행되면 무슨 일인가가 일어나게 된다. 구문은 값(Value), 연산자(Operator), 표현식(Expression), 키워드(Keyword), 주석(Comment)으로 구성되며 세미콜론( ; )으로 끝나야 한다. 구문은 block으로 그룹화 되며 이것을 함수라고 부른다. 조건문이나 반복문의 사용으로 제어될 수 있으며 이것을 Control Flow라고 한다. 4.2 표현식(Expression) 결과론 적으로 값 1개로 수렴되는 것이다. 4.2 변수(variable) 값을 저장하거나 참조하기 위해 사용된다. 메모리와 관련이 있다. 유지할 필요가 있는 값을 경우 변수를 사용한다.12var x; // 변수의 선언과 초기화x = 6; // 정수값의 할당 4.4 값(Value)12String str = \"Hello World\";&lt;1&gt; &lt;2&gt; &lt;3&gt; 자바스크립트는 7가지의 데이터 타입을 제공한다. 기본 자료형 Boolean null undefined Number String Symbol(New In ECMAScript 6) object(객체) 12345678910111213// literal : Number10.501001// literal : String'Hello'\"World\"// literal : Object&#123; name: 'Lee', gender: 'male' &#125;// literal : Array[ 'Black', 'Gray', 'White' ]; 4.5 연산자(Operator) 산술 연산자, 대입 연산자, 문자열 연산자, 비교 연산자, 논리 연산자 1234567891011121314// 대입 연산자var color = 'red';// 산술 연산자var area = 5 * 4;// 문자열 연산자var str = 'Hi! ' + 'My name is Lee';// 비교 연산자var foo = 3 &gt; 5; // false// 논리 연산자var bar = (5 &gt; 3) &amp;&amp; (2 &lt; 4); // true 4.6 키워드(keyword) 규정을 미리 정의해둔 것이다. 4.7 주석(Comment) // //(1줄 짜리) or / /(여러줄 짜리) 방법이 있다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Syntax","slug":"JavaScript/Syntax","permalink":"http://yoursite.com/categories/JavaScript/Syntax/"}],"tags":[{"name":"Syntax","slug":"Syntax","permalink":"http://yoursite.com/tags/Syntax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript-Coding","slug":"js-study-coding","date":"2017-07-28T03:54:00.000Z","updated":"2017-10-29T12:35:14.000Z","comments":true,"path":"2017/07/28/js-study-coding/","link":"","permalink":"http://yoursite.com/2017/07/28/js-study-coding/","excerpt":"","text":"Javascript Coding 1. Computational thinking coding은 수행되어져야 하는 명령을 컴퓨터에 전달하는 일종의 커뮤니케이션이다. compiler은 인간의 언어를 컴퓨터 언어로 변환시킨다. 문제 해결 능력 : 요구사항을 명확히 이해한 후 해결과제가 일치하는 능력 2. Syntax &amp; Semantics 컴퓨터가 이해할 수 있는 언어인 기계어로 명령을 전달해야 한다. compiler, interpreter 컴퓨터가 이해할 수 있는 기계어로 변환하여 주는 일종의 번역기 이다. compiler : 인간의 언어에 가까운 고급 언어로 작성된 원시 프로그램을 입력으로 받아 기계어(機械語)로 된 목적 프로그램을 출력하기 위해 사용되는 언어 번역 프로그램 interpreter : interpreter language 컴파일러가 필요없다 동시에 번역한다. 단점 : 동시에 통역하기에 에러를 검출하기가 힘들다. 문법에는 당연히 맞게 써야하며 요구사항이 실현 되어야 의미가 있다. 프로그래밍은 요구사항의 집합을 분석하여 적절한 자료구조와 함수의 집합으로 변환한 후 그 흐름을 제어하는 것이다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Syntax","slug":"JavaScript/Syntax","permalink":"http://yoursite.com/categories/JavaScript/Syntax/"}],"tags":[{"name":"Syntax","slug":"Syntax","permalink":"http://yoursite.com/tags/Syntax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"CSS-Syntax","slug":"css-study-syntax","date":"2017-07-19T03:54:00.000Z","updated":"2017-10-15T12:27:18.000Z","comments":true,"path":"2017/07/19/css-study-syntax/","link":"","permalink":"http://yoursite.com/2017/07/19/css-study-syntax/","excerpt":"","text":"#CSS-Syntax CSS는 HTML요소의 style을 표현한다. 1.Selector(선택자) styling하려는 요소를 선택한다. 태그명, id(#), class(.) 명으로 가져올 수 있다. 2. Property(속성) ;를 사용하여 여러개의 property를 지정할 수 있다. 3. Value(속성 값) property에 따라서 특정 값을 입력할 수 있다. 4. HTML과 CSS의 연동 Rendering Engine이란?? HTML file을 읽는 능력이 있어야한다.&lt;순차적으로 읽는다.&gt;Html file 읽히는 도중에 CSS file을 서버에서 loading한다.HTML file 읽히는 도중에 JavaScript file도 읽는다 단! Js Engine으로 읽는다.한줄 씩 읽는 것을 parsing 이라고 하며 그 기계를 parser라고하며 Rendering Engine안에 parser, loader가 존재한다.Html 이 parsing을 하면 DOM이 컴퓨터의 메모리에 올라가 있는다.Css 이 parsing을 하면 CSSOM이 컴퓨터의 메모리에 올라가 있는다.결과론 적으로는 DOM + CSSOM = Render Tree가 생성된다. browser 동작원리 4,1 Link style HTML에서 외부에 있는 CSS 파일을 로드하는 방식이다. &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt; 4.2 Embedding style style tag 안에다가 입력하는 방식이다. 4.3 Inline style HTML 요소의 style property에 css를 기술하는 방식이다. Link style을 사용하는 것이 좋다. 5. Reset CSS 사용하기 기본적인 HTML 요소의 CSS를 초기화하는 용도로 사용한다. bootstrap등의 framework를 사용하면 Reset CSS를 사용하지 않아도 된다. Reset CSS 6. CSS Version CSS1 : 1996, CSS2 : 1998, CSS3 : 2005","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"},{"name":"Syntax","slug":"CSS/Syntax","permalink":"http://yoursite.com/categories/CSS/Syntax/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Syntax","slug":"Syntax","permalink":"http://yoursite.com/tags/Syntax/"}]},{"title":"CSS-Selector","slug":"css-study-seletor","date":"2017-07-19T03:54:00.000Z","updated":"2017-10-08T13:18:06.000Z","comments":true,"path":"2017/07/19/css-study-seletor/","link":"","permalink":"http://yoursite.com/2017/07/19/css-study-seletor/","excerpt":"","text":"CSS-Selector , 를 사용하여서 여러개의 selector를 지정할 수 있다.1h1, p &#123;color: red; &#125; 1. Universal Selector (전체 셀렉터) 를 사용하여서 모든 selector를 선택한다.12/* 모든 요소를 선택 */* &#123; color: red; &#125; 2. Tag Selector (태그 셀렉터) 태그명을 사용하여서 해당되는 selector를 선택한다.12/* 모든 p 태그 요소를 선택 */p &#123; color: red; &#125; 3. ID Selector(ID Selector) #id 을 사용하여서 해당 id를 가진 요소를 선택한다. id attribute 값은 중복될 수 없는 유일한 값이다.12345678/* id 어트리뷰트 값이 p1인 요소를 선택 */#p1 &#123; color: red; &#125;``` ## 4. Class Selector(클래스 셀렉터)- .class를 통하여 일치하는 요소를 선택한다.- class attribute 값은 중복될 수 있다. / class 어트리뷰트 값이 container인 모든 요소를 선택 // color 어트리뷰트는 자식 요소에 상속된다. /.container { color: red; }/ not supported in IE / #p2 { color: initial; }1234## 5. Attribute Selector(어트리뷰트 셀렉터)- selector[attribute] 지정된 어트리뷰트를 갖는 모든 요소를 선택한다. / a 요소 중에 href 어트리뷰트를 갖는 모든 요소 /a[href] { color: red; }12- selector[attribure=&quot;value&quot;] 지정된 어트리뷰트를 가지며 지정된 값과 어트리뷰트의 값이 일치하는 모든 요소를 선택한다. / a 요소 중에 target 어트리뷰트의 값이 “_blank”인 모든 요소 /a[target=”_blank”] { color: red; }12- selector[attribute~=&quot;value&quot;] 지정된 어트리뷰트의 값이 지정된 값을 (`공백으로 분리된`) 단어로 포함하는 요소를 선택한다. / h1 요소 중에 title 어트리뷰트 값에 “first”를 단어로 포함하는 요소 /h1[title~=”first”] { color: red; }12- selector[attribute|=&quot;value&quot;] 지정된 어트리뷰트의 값과 일치하거나 지정 어트리뷰트 값 뒤 연이은 `하이픈(“값-“)`으로 시작하는 요소를 선택한다. / p 요소 중에 lang 어트리뷰트 값이 “en”과 일치하거나 “en-“로 시작하는 요소 /p[lang|=”en”] { color: red; }12- selector[attribute^=&quot;value&quot;] 지정된 어트리뷰트 값으로 `시작하는 요소`를 선택한다. / a 요소 중에 href 어트리뷰트 값이 “https://&quot;로 시작하는 요소 /a[href^=”https://“] { color: red; }12- selector(attribute$=&quot;value&quot;) 지정된 어트리뷰트 값으로 `끝나는 요소`를 선택한다. / a 요소 중에 href 어트리뷰트 값이 “.html”로 끝나는 요소 /a[href$=”.html”] { color: red; }12- selector[attribute*=&quot;value&quot;] 지정된 어트리뷰트 값을 `포함하는 요소`를 선택한다. / div 요소 중에서 class 어트리뷰트 값에 “test”를 포함하는 요소 /div[class=”test”] { color: red; }/ div 요소 중에서 class 어트리뷰트 값에 “test”를 단어로 포함하는 요소 */div[class~=”test”] { background-color: yellow; }12345## 6. Combinator(복합 셀렉터)### 6.1 후손 셀렉터(Descendant Combinator)- space로 구분한다. / div 요소의 후손요소 중 p 요소 /div p { color: red; } paragraph 1 paragraph 2 paragraph 3 / 3개다 허용이다 /123### 6.2 자식 셀렉터(Child Combinator)- SelectorA &gt; SelectorB A의 모든 자식 요소 중 B와 일치하는 요소를 선택한다. / div 요소의 자식요소 중 p 요소 /div &gt; p { color: red; } paragraph 1 paragraph 2 paragraph 3 =&gt; 애만 아니다. 123456### 6.3 동위 셀렉터(Sibling Combinator)- 동위 셀렉터는 동위 관계에서 뒤에 위치하는 요소를 선택할 때 사용한다.#### 6.3.1 인접 형제 셀렉터- SelectorA + SelectorB A바로 뒤에 나오는 B만 선택된다. / p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소를 선택한다. /p + ul { color: red; } A div element. Coffee Tea Milk The first paragraph./ 이 부분 바로 밑에 ul만 선택 / Coffee Tea Milk Another list Coffee Tea Milk 123#### 6.3.2 일반 형제 셀렉터- SelectorA ~ SelectorB A 뒤에 위치하는 B 요소를 모두 선택한다./ p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소를 모두 선택한다./p ~ ul { color: red; } A div element. Coffee Tea Milk The first paragraph. / 이 밑에 ul 다 선택된다. / Coffee Tea Milk Another list Coffee Tea Milk 123456789101112131415## 7. 가상 클래스 셀렉터- 요소의 특정 상태에 따라 스타일을 정의할 때 사용된다.### 7.1 링크 셀렉터, 동적 셀렉터- 마우스가 올라와 있을 때 :hover- 방문하지 않은 링크일 때 :link- 방문한 링크일 때 :visited- 클릭된 상태일 때 :active- 포커스가 들어와 있을 때 :focus### 7.2 UI 요소 상태 셀렉터- 체크 상태일 때 :checked- 사용 가능한 상태일 때 :enabled- 사용 불가능한 상태일 때 :disabled / input 요소가 사용 가능한 상태일 때, input 요소 바로 뒤에 위치하는 인접 형제 span 요소를 선택 / input:enabled + span { color: blue; } / input 요소가 사용 불가능한 상태일 때, input 요소 바로 뒤에 위치하는 인접 형제 span 요소를 선택 / input:disabled + span { color: gray; text-decoration: line-through; } / input 요소가 체크 상태일 때, input 요소 바로 뒤에 위치하는 인접 형제 span 요소를 선택 / input:checked + span { color: red; }1234### 7.3 구조 가상 클래스 셀렉터- first-child 셀렉터에 해당하는 모든 요소 중 첫번째 자식인 요소를 선택한다.- last-child 셀렉터에 해당하는 모든 요소 중 마지막 자식인 요소를 선택한다./ p 요소 중에서 첫번째 자식을 선택 /p:first-child { color: red; }/ p 요소 중에서 마지막 자식을 선택 // body 요소의 두번째 p 요소는 마지막 자식 요소가 아니다.body 요소의 마지막 자식 요소는 div 요소이다. /p:last-child { color: blue; } This paragraph is the first child of its parent (body). Welcome to My Homepage This paragraph is not the first child of its parent. This paragraph is the first child of its parent (div). This paragraph is not the first child of its parent. 12345- nth-child(n) 셀렉터에 해당하는 모든 요소 중 앞에서 n번째 자식인 요소를 선택한다.- nth-last-child(n) 셀렉터에 해당하는 모든 요소 중 뒤에서 n번째 자식인 요소를 선택한다.&gt; n은 0부터 시작하는 정수이다. 0과 음수는 생략되기 때문에 2n+1, 2n-1은 결과적으로 같은 수열을 생성한다. /* ol 요소의 자식 요소인 li 요소 중에서 짝수번째 요소만을 선택 */ ol &gt; li:nth-child(2n) { color: orange; } /* ol 요소의 자식 요소인 li 요소 중에서 홀수번째 요소만을 선택 */ ol &gt; li:nth-child(2n+1) { color: green; } /* ol 요소의 자식 요소인 li 요소 중에서 첫번쨰 요소만을 선택 */ ol &gt; li:first-child { color: red; } /* ol 요소의 자식 요소인 li 요소 중에서 마지막 요소만을 선택 */ ol &gt; li:last-child { color: blue; } /* ol 요소의 자식 요소인 li 요소 중에서 4번째 요소 요소만을 선택 */ ol &gt; li:nth-child(4) { background: brown; } /* ul 요소의 모든 자식 요소 중에서 뒤에서부터 시작하여 홀수번째 요소만을 선택 */ ul &gt; :nth-last-child(2n+1) { color: red; } /* ul 요소의 모든 자식 요소 중에서 뒤에서부터 시작하여 짝수번째 요소만을 선택 */ ul &gt; :nth-last-child(2n) { color: blue; } 12345- :first-of-type 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 첫번째 등장하는 요소를 선택한다.- :last-of-type 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 마지막에 등장하는 요소를 선택한다.- :nth-of-type(n) 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 앞에서 n번째에 등장하는 요소를 선택한다.- :nth-last-of-type(n) 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 뒤에서 n번째에 등장하는 요소를 선택한다. /* p 요소의 부모 요소의 자식 요소 중 첫번째 등장하는 p 요소 */ p:first-of-type { color: red; } /* p 요소의 부모 요소의 자식 요소 중 마지막 등장하는 p 요소 */ p:last-of-type { color: blue; } /* p 요소의 부모 요소의 자식 요소 중 앞에서 2번째에 등장하는 p 요소 */ p:nth-of-type(2) { color: green; } /* p 요소의 부모 요소의 자식 요소 중 뒤에서 2번째에 등장하는 p 요소 */ p:nth-last-of-type(2) { color: orange;} /* p 요소 중에서 첫번째 자식을 선택 */ p:first-child { background: brown;} 1234### 7.4 부정 셀렉터- :not(셀렉터) 셀렉터에 해당하지 않는 모든 요소를 선택한다. / input 요소 중에서 type 어트리뷰트의 값이 password가 아닌 요소를 선택 / input:not([type=password]){background: yellow;}``` 8. 가상 요소 셀렉터 특정 부분에 스타일을 적용하기 위하여 사용된다. 요소 콘텐츠의 첫글자 또는 첫줄 요소 콘텐츠의 앞 또는 뒤 가상 요소에는 ::를 사용한다. ::first-letter 콘텐츠의 첫글자를 선택한다. ::first-line 콘텐츠의 첫줄을 선택한다. 블록 요소에만 적용할 수 있다. ::after 콘텐츠의 뒤에 위치하는 공간을 선택한다. 일반적으로 content 어트리뷰트와 함께 사용된다. ::before 콘텐츠의 앞에 위치하는 공간을 선택한다. 일반적으로 content 어트리뷰트와 함께 사용된다. ::selection 드래그한 콘텐츠를 선택한다. iOS Safari 등 일부 브라우저에서 동작 않는다.","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"},{"name":"Selector","slug":"CSS/Selector","permalink":"http://yoursite.com/categories/CSS/Selector/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Selector","slug":"Selector","permalink":"http://yoursite.com/tags/Selector/"}]}]}